{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Introduction","text":"<p><code>Pait</code> is a Python API development tool that helps developers quickly write API route functions. It has feature such as parameter type checking, type conversion, and automatic API documentation. It is suitable for back-end interface development.</p> <p>In addition, it is designed as an adapter that can work with multiple Python web application frameworks (see Web Framework Support for details), Based on <code>Pait</code>, can quickly develop applications that adapt to each WEB framework without considering the differences of different WEB frameworks, such as grpc-gateway.</p>"},{"location":"#feature","title":"Feature","text":"<ul> <li> Integrate into the Type Hints ecosystem to provide a safe and efficient API interface coding method.</li> <li> Automatic verification and type conversion of request parameters (depends on <code>Pydantic</code> and <code>inspect</code>, currently supports <code>Pydantic</code> V1 and V2 versions).</li> <li> Automatically generate openapi files and support UI components such as <code>Swagger</code>,<code>Redoc</code>,<code>RapiDoc</code> and <code>Elements</code>.</li> <li> TestClient support, response result verification of test cases\u3002</li> <li> Plugin expansion, such as parameter relationship dependency verification, Mock response, etc.\u3002</li> <li> gRPC GateWay (After version 1.0, this feature has been migrated to grpc-gateway)</li> <li> Automated API testing</li> <li> WebSocket support</li> <li> SSE support</li> </ul>"},{"location":"#install","title":"Install","text":"<p>Note</p> <p>Only supports Python 3.8+ version</p> <pre><code>pip install pait --pre\n</code></pre>"},{"location":"#usage","title":"Usage","text":""},{"location":"#parameter-verification-and-document-generation","title":"Parameter verification and document generation","text":"<p>The main feature of <code>Pait</code> is to provide parameter verification and document generation. The usage is very simple, as follows:</p> FlaskStarletteSanicTornado docs_source_code/introduction/flask_demo.py<pre><code>from typing import Type\n\nfrom flask import Flask, Response, jsonify\nfrom pydantic import BaseModel, Field\n\nfrom pait.app.flask import pait\nfrom pait.field import Json\nfrom pait.model.response import JsonResponseModel\nfrom pait.openapi.doc_route import AddDocRoute\n\n\nclass DemoResponseModel(JsonResponseModel):\n    class ResponseModel(BaseModel):\n        uid: int = Field()\n        user_name: str = Field()\n\n    description: str = \"demo response\"\n    response_data: Type[BaseModel] = ResponseModel\n\n\n@pait(response_model_list=[DemoResponseModel])\ndef demo_post(\n    uid: int = Json.t(description=\"user id\", gt=10, lt=1000),\n    username: str = Json.t(description=\"user name\", min_length=2, max_length=4),\n) -&gt; Response:\n    return jsonify({\"uid\": uid, \"user_name\": username})\n\n\napp = Flask(\"demo\")\napp.add_url_rule(\"/api\", \"demo\", demo_post, methods=[\"POST\"])\nAddDocRoute(app)\n\n\nif __name__ == \"__main__\":\n    app.run(port=8000)\n</code></pre> docs_source_code/introduction/starlette_demo.py<pre><code>from typing import Type\n\nfrom pydantic import BaseModel, Field\nfrom starlette.applications import Starlette\nfrom starlette.responses import JSONResponse\nfrom starlette.routing import Route\n\nfrom pait.app.starlette import pait\nfrom pait.field import Json\nfrom pait.model.response import JsonResponseModel\nfrom pait.openapi.doc_route import AddDocRoute\n\n\nclass DemoResponseModel(JsonResponseModel):\n    class ResponseModel(BaseModel):\n        uid: int = Field()\n        user_name: str = Field()\n\n    description: str = \"demo response\"\n    response_data: Type[BaseModel] = ResponseModel\n\n\n@pait(response_model_list=[DemoResponseModel])\nasync def demo_post(\n    uid: int = Json.t(description=\"user id\", gt=10, lt=1000),\n    username: str = Json.t(description=\"user name\", min_length=2, max_length=4),\n) -&gt; JSONResponse:\n    return JSONResponse({\"uid\": uid, \"user_name\": username})\n\n\napp = Starlette(routes=[Route(\"/api\", demo_post, methods=[\"POST\"])])\nAddDocRoute(app)\n\n\nif __name__ == \"__main__\":\n    import uvicorn\n\n    uvicorn.run(app)\n</code></pre> docs_source_code/introduction/sanic_demo.py<pre><code>from typing import Type\n\nfrom pydantic import BaseModel, Field\nfrom sanic.app import Sanic\nfrom sanic.response import HTTPResponse, json\n\nfrom pait.app.sanic import pait\nfrom pait.field import Json\nfrom pait.model.response import JsonResponseModel\nfrom pait.openapi.doc_route import AddDocRoute\n\n\nclass DemoResponseModel(JsonResponseModel):\n    class ResponseModel(BaseModel):\n        uid: int = Field()\n        user_name: str = Field()\n\n    description: str = \"demo response\"\n    response_data: Type[BaseModel] = ResponseModel\n\n\n@pait(response_model_list=[DemoResponseModel])\nasync def demo_post(\n    uid: int = Json.t(description=\"user id\", gt=10, lt=1000),\n    username: str = Json.t(description=\"user name\", min_length=2, max_length=4),\n) -&gt; HTTPResponse:\n    return json({\"uid\": uid, \"user_name\": username})\n\n\napp = Sanic(name=\"demo\")\napp.add_route(demo_post, \"/api\", methods=[\"POST\"])\nAddDocRoute(app)\n\n\nif __name__ == \"__main__\":\n    import uvicorn\n\n    uvicorn.run(app)\n</code></pre> docs_source_code/introduction/tornado_demo.py<pre><code>from typing import Type\n\nfrom pydantic import BaseModel, Field\nfrom tornado.ioloop import IOLoop\nfrom tornado.web import Application, RequestHandler\n\nfrom pait.app.tornado import pait\nfrom pait.field import Json\nfrom pait.model.response import JsonResponseModel\nfrom pait.openapi.doc_route import AddDocRoute\n\n\nclass DemoResponseModel(JsonResponseModel):\n    class ResponseModel(BaseModel):\n        uid: int = Field()\n        user_name: str = Field()\n\n    description: str = \"demo response\"\n    response_data: Type[BaseModel] = ResponseModel\n\n\nclass DemoHandler(RequestHandler):\n    @pait(response_model_list=[DemoResponseModel])\n    def post(\n        self,\n        uid: int = Json.t(description=\"user id\", gt=10, lt=1000),\n        username: str = Json.t(description=\"user name\", min_length=2, max_length=4),\n    ) -&gt; None:\n        self.write({\"uid\": uid, \"user_name\": username})\n\n\napp: Application = Application([(r\"/api\", DemoHandler)])\nAddDocRoute(app)\n\n\nif __name__ == \"__main__\":\n    app.listen(8000)\n    IOLoop.instance().start()\n</code></pre> <p>There are three sections of highlighted code in the example code. The <code>@pait</code> in the first highlighted code will decorate the route function and automatically extract the request parameter data from the route function when the program starts. In addition, the response object of the route function is declared as <code>DemoResponseModel</code> through the <code>response_model_list</code> attribute. The <code>description</code> and <code>response_data</code> attributes of the <code>DemoResponseModel</code> object are used to describe the response object description of the route function and the structure type of the response object respectively.</p> <p>The parameter format of the route function in the second highlighted code is a format that conforms to the <code>Pait</code> specification. During initialization, <code>@pait</code> will actively parse the route function and generate dependency injection rules based on the function signature of the route function. When a request hits the route function, <code>Pait</code> will get the corresponding value from the <code>Request</code> object according to the dependency injection rules and inject it into the route function.</p> <p>The main job of the highlighted code in the third paragraph is to register the <code>OpenAPI</code> route with the <code>app</code> instance and provide the <code>OpenAPI</code> document feature for the web framework.</p> <p>After everything is ready, start running the code and visit: http://127.0.0.1:8000/swagger in the browser to see the SwaggerUI page. Two sets of interfaces will be displayed as shown below: </p> <p>The named <code>pait_doc</code> belongs to the <code>OpenAPI</code> interface that comes with <code>Pait</code>, and the other group is the <code>default</code> containing the newly created <code>/api</code>. After clicking on the <code>/api</code>, it will Pop-up interface details: </p> <p>The data is generated by <code>Pait</code> parse the route's function signature and the <code>DemoResponseModel</code> object. In the details page, you can click the <code>try it out</code> button, then enter the parameters and click the <code>Excute</code> button, you can see the <code>curl</code> command generation results and the server response results, as shown below: </p> <p>Note</p> <p>Want to know more? Immediately enter the Type Conversion and Parameter Verification chapter</p>"},{"location":"#plugin","title":"Plugin","text":"<p>In addition to parameter verification and <code>OpenAPI</code> feature, <code>Pait</code> can also expand its feature through the plugin system. For example, the Mock response plugin can automatically generate response values and return data based on the response model, even if the route function does not have any logic implementation, such as the following code:</p> FlaskStarletteSanicTornado docs_source_code/introduction/flask_demo_with_mock_plugin.py<pre><code>from typing import Type\n\nfrom flask import Flask, Response\nfrom pydantic import BaseModel, Field\n\nfrom pait.app.flask import pait\nfrom pait.app.flask.plugin.mock_response import MockPlugin\nfrom pait.field import Json\nfrom pait.model.response import JsonResponseModel\nfrom pait.openapi.doc_route import AddDocRoute\n\n\nclass DemoResponseModel(JsonResponseModel):\n    class ResponseModel(BaseModel):\n        uid: int = Field(example=999)\n        username: str = Field()\n\n    description: str = \"demo response\"\n    response_data: Type[BaseModel] = ResponseModel\n\n\n@pait(response_model_list=[DemoResponseModel], plugin_list=[MockPlugin.build()])\ndef demo_post(  # type: ignore\n    uid: int = Json.t(description=\"user id\", gt=10, lt=1000),\n    username: str = Json.t(description=\"user name\", min_length=2, max_length=4),\n) -&gt; Response:\n    pass\n\n\napp = Flask(\"demo\")\napp.add_url_rule(\"/api\", \"demo\", demo_post, methods=[\"POST\"])\nAddDocRoute(app)\n\n\nif __name__ == \"__main__\":\n    app.run(port=8000)\n</code></pre> docs_source_code/introduction/starlette_demo_with_mock_plugin.py<pre><code>from typing import Type\n\nfrom pydantic import BaseModel, Field\nfrom starlette.applications import Starlette\nfrom starlette.responses import JSONResponse\nfrom starlette.routing import Route\n\nfrom pait.app.starlette import pait\nfrom pait.app.starlette.plugin.mock_response import MockPlugin\nfrom pait.field import Json\nfrom pait.model.response import JsonResponseModel\nfrom pait.openapi.doc_route import AddDocRoute\n\n\nclass DemoResponseModel(JsonResponseModel):\n    class ResponseModel(BaseModel):\n        uid: int = Field(example=999)\n        username: str = Field()\n\n    description: str = \"demo response\"\n    response_data: Type[BaseModel] = ResponseModel\n\n\n@pait(response_model_list=[DemoResponseModel], plugin_list=[MockPlugin.build()])\nasync def demo_post(  # type: ignore[empty-body]\n    uid: int = Json.t(description=\"user id\", gt=10, lt=1000),\n    username: str = Json.t(description=\"user name\", min_length=2, max_length=4),\n) -&gt; JSONResponse:\n    pass\n\n\napp = Starlette(routes=[Route(\"/api\", demo_post, methods=[\"POST\"])])\nAddDocRoute(app)\n\n\nif __name__ == \"__main__\":\n    import uvicorn\n\n    uvicorn.run(app)\n</code></pre> docs_source_code/introduction/sanic_demo_with_mock_plugin.py<pre><code>from typing import Type\n\nfrom pydantic import BaseModel, Field\nfrom sanic.app import Sanic\nfrom sanic.response import HTTPResponse\n\nfrom pait.app.sanic import pait\nfrom pait.app.sanic.plugin.mock_response import MockPlugin\nfrom pait.field import Json\nfrom pait.model.response import JsonResponseModel\nfrom pait.openapi.doc_route import AddDocRoute\n\n\nclass DemoResponseModel(JsonResponseModel):\n    class ResponseModel(BaseModel):\n        uid: int = Field(example=999)\n        username: str = Field()\n\n    description: str = \"demo response\"\n    response_data: Type[BaseModel] = ResponseModel\n\n\n@pait(response_model_list=[DemoResponseModel], plugin_list=[MockPlugin.build()])\nasync def demo_post(  # type: ignore[empty-body]\n    uid: int = Json.t(description=\"user id\", gt=10, lt=1000),\n    username: str = Json.t(description=\"user name\", min_length=2, max_length=4),\n) -&gt; HTTPResponse:\n    pass\n\n\napp = Sanic(name=\"demo\")\napp.add_route(demo_post, \"/api\", methods=[\"POST\"])\nAddDocRoute(app)\n\n\nif __name__ == \"__main__\":\n    import uvicorn\n\n    uvicorn.run(app)\n</code></pre> docs_source_code/introduction/tornado_demo_with_mock_plugin.py<pre><code>from typing import Type\n\nfrom pydantic import BaseModel, Field\nfrom tornado.ioloop import IOLoop\nfrom tornado.web import Application, RequestHandler\n\nfrom pait.app.tornado import pait\nfrom pait.app.tornado.plugin.mock_response import MockPlugin\nfrom pait.field import Json\nfrom pait.model.response import JsonResponseModel\nfrom pait.openapi.doc_route import AddDocRoute\n\n\nclass DemoResponseModel(JsonResponseModel):\n    class ResponseModel(BaseModel):\n        uid: int = Field(example=999)\n        username: str = Field()\n\n    description: str = \"demo response\"\n    response_data: Type[BaseModel] = ResponseModel\n\n\nclass DemoHandler(RequestHandler):\n    @pait(response_model_list=[DemoResponseModel], plugin_list=[MockPlugin.build()])\n    async def post(\n        self,\n        uid: int = Json.t(description=\"user id\", gt=10, lt=1000),\n        username: str = Json.t(description=\"user name\", min_length=2, max_length=4),\n    ) -&gt; None:\n        pass\n\n\napp: Application = Application([(r\"/api\", DemoHandler)])\nAddDocRoute(app)\n\n\nif __name__ == \"__main__\":\n    app.listen(8000)\n    IOLoop.instance().start()\n</code></pre> <p>This code is changed based on the code of Parameter verification and document generation. It removes the logic code of the route function and introduces the highlighted part of the code.</p> <p>Among them, the <code>uid: int = Field(example=999)</code> of the <code>DemoResponseModel</code> response model specifies that the mock value of uid in the response structure is 999. The <code>@pait</code> decorator adds a plugin named <code>MockPlugin</code> through the <code>plugin_list</code> attribute. The plugin can generate a mock response based on the <code>response_model_list</code>.</p> <p>After everything is ready, start running the code and re-click the <code>Excute</code> button on the <code>Swagger</code> page or run the <code>curl</code> command generated by the <code>Swagger</code> page in the terminal: <pre><code>&gt; curl -X 'POST' \\\n  'http://127.0.0.1:8000/api' \\\n  -H 'accept: application/json' \\\n  -H 'Content-Type: application/json' \\\n  -d '{\n  \"uid\": 666,\n  \"user_name\": \"so1n\"\n}'\n</code></pre> Finally, can see the following output whether on the <code>Swagger</code> page or in the terminal: <pre><code>{\"uid\":999,\"username\":\"\"}\n</code></pre> As you can see from the returned results, although the route function does not perform any operation, the routeing function can still return a response.</p> <p>This response result is automatically generated by the Mock plugin, where the <code>uid</code> value of <code>999</code> is the same as the value set in the <code>uid: int = Field(example=999)</code> in the response model, and the <code>username</code> is the default empty string in the response result because it is not set in <code>example</code>.</p> <p>Note</p> <p>In addition to the <code>MockPlugin</code>, <code>Pait</code> also has other plugins and feature. For details, please see the description of Plugin.</p>"},{"location":"#performance","title":"Performance","text":"<p>The main operating principle of <code>Pait</code> is to convert the function signature of the route function into <code>Pydantic Model</code> through the reflection mechanism when the program is started, and then verify and convert the request parameters through <code>Pydantic Model</code> when the request hits the route.</p> <p>These two stages are all automatically handled internally by <code>Pait</code>. The first stage only slightly increases the startup time of the program, while the second stage increases the response time of the routing, but it only consumes 0.00005(s) more than manual processing. The specific benchmark data and subsequent optimization are described in #27.</p>"},{"location":"#web-framework-support","title":"Web framework support","text":"<p>The internal implementation of <code>Pait</code> is an adapter that adapts to different web frameworks, and implements various feature based on the adapter. Currently, the web frameworks supported by the <code>Pait</code> adapter are as follows:</p> Web Framework Request Response Plugin OpenAPI App attribute set&amp;get HTTP Exception SimpleRoute TestHelper Flask \u221a \u221a \u221a \u221a \u221a \u221a \u221a \u221a Sanic \u221a \u221a \u221a \u221a \u221a \u221a \u221a \u221a Startlette \u221a \u221a \u221a \u221a \u221a \u221a \u221a \u221a Tornado \u221a \u221a \u221a \u221a \u221a \u221a \u221a \u221a"},{"location":"#example","title":"Example","text":"<p><code>Pait</code> provides complete code examples for the web frameworks it supports, can learn more by accessing the sample code:</p> <ul> <li> <p>flask example</p> </li> <li> <p>sanic example</p> </li> <li> <p>starlette example</p> </li> <li> <p>tornado example</p> </li> </ul>"},{"location":"1_1_introduction/","title":"Introduction","text":"<p><code>Pait</code> is an auxiliary framework and it will not change the usage of Web frameworks. Therefore, before introducing the use of <code>Pait</code>, let's first take a look at the usage of different Web frameworks.</p> FlaskStarletteSanicTornado docs_source_code/introduction/flask_hello_world_demo.py<pre><code>from flask import Flask, Response, jsonify, request\n\n\ndef demo_post() -&gt; Response:\n    request_dict = request.json or {}\n    uid_str: str = request_dict.get(\"uid\", \"\")\n    username: str = request_dict.get(\"username\", \"\")\n\n    uid = int(uid_str)  # Don't think about type conversion exceptions for now\n    if not (10 &lt; uid &lt; 1000):\n        raise ValueError(\"invalid uid\")\n    if not (2 &lt;= len(username) &lt;= 4):\n        raise ValueError(\"invalid name\")\n    # get the corresponding value and return it\n    return jsonify({\"uid\": uid, \"username\": username})\n\n\napp = Flask(\"demo\")\napp.add_url_rule(\"/api\", \"demo\", demo_post, methods=[\"POST\"])\n\n\nif __name__ == \"__main__\":\n    app.run(port=8000)\n</code></pre> docs_source_code/introduction/starlette_hello_world_demo.py<pre><code>from starlette.applications import Starlette\nfrom starlette.requests import Request\nfrom starlette.responses import JSONResponse\nfrom starlette.routing import Route\n\n\nasync def demo_post(request: Request) -&gt; JSONResponse:\n    request_dict = await request.json()\n    uid_str: str = request_dict.get(\"uid\", \"\")\n    username: str = request_dict.get(\"username\", \"\")\n\n    uid = int(uid_str)  # Don't think about type conversion exceptions for now\n    if not (10 &lt; uid &lt; 1000):\n        raise ValueError(\"invalid uid\")\n    if not (2 &lt;= len(username) &lt;= 4):\n        raise ValueError(\"invalid name\")\n    # get the corresponding value and return it\n    return JSONResponse({\"uid\": uid, \"username\": username})\n\n\napp = Starlette(routes=[Route(\"/api\", demo_post, methods=[\"POST\"])])\n\n\nif __name__ == \"__main__\":\n    import uvicorn\n\n    uvicorn.run(app)\n</code></pre> docs_source_code/introduction/sanic_hello_world_demo.py<pre><code>from sanic.app import Sanic\nfrom sanic.request import Request\nfrom sanic.response import HTTPResponse, json\n\n\nasync def demo_post(request: Request) -&gt; HTTPResponse:\n    request_dict = await request.json()\n    uid_str: str = request_dict.get(\"uid\", \"\")\n    username: str = request_dict.get(\"username\", \"\")\n\n    uid = int(uid_str)  # Don't think about type conversion exceptions for now\n    if not (10 &lt; uid &lt; 1000):\n        raise ValueError(\"invalid uid\")\n    if not (2 &lt;= len(username) &lt;= 4):\n        raise ValueError(\"invalid name\")\n    # get the corresponding value and return it\n    return json({\"uid\": uid, \"username\": username})\n\n\napp = Sanic(name=\"demo\")\napp.add_route(demo_post, \"/api\", methods=[\"POST\"])\n\n\nif __name__ == \"__main__\":\n    import uvicorn\n\n    uvicorn.run(app)\n</code></pre> docs_source_code/introduction/tornado_hello_world_demo.py<pre><code>import json\n\nfrom tornado.ioloop import IOLoop\nfrom tornado.web import Application, RequestHandler\n\n\nclass DemoHandler(RequestHandler):\n    def post(self) -&gt; None:\n        request_dict = json.loads(self.request.body.decode())\n        uid_str: str = request_dict.get(\"uid\", \"\")\n        username: str = request_dict.get(\"username\", \"\")\n\n        uid = int(uid_str)  # Don't think about type conversion exceptions for now\n        if not (10 &lt; uid &lt; 1000):\n            raise ValueError(\"invalid uid\")\n        if not (2 &lt;= len(username) &lt;= 4):\n            raise ValueError(\"invalid name\")\n        # get the corresponding value and return it\n        self.write({\"uid\": uid, \"username\": username})\n\n\napp: Application = Application([(r\"/api\", DemoHandler)])\n\n\nif __name__ == \"__main__\":\n    app.listen(8000)\n    IOLoop.instance().start()\n</code></pre> <p>The logic of this sample code is consistent with the sample code on the homepage. The main feature of the sample code is to register a route into an instance of the Web framework at startup, and after receiving a request with the URL <code>/api</code> and method <code>POST</code> at runtime, the request will be handed over to the route function for processing. The logic of the route function is also very simple. It will verify the data first and return the data only if it meets the requirements. Otherwise, an error will be thrown directly.</p> <p>Next, we will use <code>Pait</code> in the example code. Their functions are the same, as follows:</p> FlaskStarletteSanicTornado docs_source_code/introduction/flask_demo.py<pre><code>from typing import Type\n\nfrom flask import Flask, Response, jsonify\nfrom pydantic import BaseModel, Field\n\nfrom pait.app.flask import pait\nfrom pait.field import Json\n\n\n@pait()\ndef demo_post(\n    uid: int = Json.t(description=\"user id\", gt=10, lt=1000),\n    username: str = Json.t(description=\"user name\", min_length=2, max_length=4),\n) -&gt; Response:\n    return jsonify({\"uid\": uid, \"user_name\": username})\n\n\napp = Flask(\"demo\")\napp.add_url_rule(\"/api\", \"demo\", demo_post, methods=[\"POST\"])\napp.run(port=8000)\n</code></pre> docs_source_code/introduction/starlette_demo.py<pre><code>from typing import Type\n\nfrom pydantic import BaseModel, Field\nfrom starlette.applications import Starlette\nfrom starlette.responses import JSONResponse\nfrom starlette.routing import Route\n\nfrom pait.app.starlette import pait\nfrom pait.field import Json\n\n\n@pait()\nasync def demo_post(\n    uid: int = Json.t(description=\"user id\", gt=10, lt=1000),\n    username: str = Json.t(description=\"user name\", min_length=2, max_length=4),\n) -&gt; JSONResponse:\n    return JSONResponse({\"uid\": uid, \"user_name\": username})\n\n\napp = Starlette(routes=[Route(\"/api\", demo_post, methods=[\"POST\"])])\n\nimport uvicorn\nuvicorn.run(app)\n</code></pre> docs_source_code/introduction/sanic_demo.py<pre><code>from typing import Type\n\nfrom pydantic import BaseModel, Field\nfrom sanic.app import Sanic\nfrom sanic.response import HTTPResponse, json\n\nfrom pait.app.sanic import pait\nfrom pait.field import Json\n\n\n@pait()\nasync def demo_post(\n    uid: int = Json.t(description=\"user id\", gt=10, lt=1000),\n    username: str = Json.t(description=\"user name\", min_length=2, max_length=4),\n) -&gt; HTTPResponse:\n    return json({\"uid\": uid, \"user_name\": username})\n\n\napp = Sanic(name=\"demo\")\napp.add_route(demo_post, \"/api\", methods=[\"POST\"])\n\nimport uvicorn\nuvicorn.run(app)\n</code></pre> docs_source_code/introduction/tornado_demo.py<pre><code>from typing import Type\n\nfrom pydantic import BaseModel, Field\nfrom tornado.ioloop import IOLoop\nfrom tornado.web import Application, RequestHandler\n\nfrom pait.app.tornado import pait\nfrom pait.field import Json\nfrom pait.model.response import JsonResponseModel\nfrom pait.openapi.doc_route import AddDocRoute\n\n\nclass DemoResponseModel(JsonResponseModel):\n    class ResponseModel(BaseModel):\n        uid: int = Field()\n        user_name: str = Field()\n\n    description: str = \"demo response\"\n    response_data: Type[BaseModel] = ResponseModel\n\n\nclass DemoHandler(RequestHandler):\n    @pait(response_model_list=[DemoResponseModel])\n    def post(\n        self,\n        uid: int = Json.t(description=\"user id\", gt=10, lt=1000),\n        username: str = Json.t(description=\"user name\", min_length=2, max_length=4),\n    ) -&gt; None:\n        self.write({\"uid\": uid, \"user_name\": username})\n\n\napp: Application = Application([(r\"/api\", DemoHandler)])\nAddDocRoute(app)\n\n\nif __name__ == \"__main__\":\n    app.listen(8000)\n    IOLoop.instance().start()\n</code></pre> <p>The <code>@pait</code> decorator of the first highlighted code in the sample is the core of all functions of <code>Pait</code>. After using <code>@pait</code> to decorate the route function, <code>Pait</code> will get the function signature through <code>inspect</code> and generate Dependency injection rules. For example, the parameters of the route function in the second highlighted code are all filled in with key parameters in the format of <code>&lt;name&gt;:&lt;type&gt;=&lt;default&gt;</code>. <code>Pait</code> automatically transforms key parameters into its own dependency injection rules at initialization time with the following rules:</p> Key Meaning Feature name Parameter Name <code>Pait</code> will use name as the key to get the corresponding value from the requested resource. type Parameter Type Used for parameter verification or conversion default <code>Field</code> object of <code>Pait</code> Different <code>Field</code> types represent obtaining values from different request types; the properties of the <code>Field</code> object tell <code>Pait</code> how to get the value from the request and verify it. <p>Taking the <code>uid</code> parameter above as an example, first, <code>Pait</code> will get json data from the request obj. Second , use <code>uid</code> as the key to get the corresponding value from the json data and convert and verify whether it is<code>int</code> type. Last, determine whether the value is between 10-1000, if not, an error will be reported directly, if so, it will be assigned to the <code>uid</code> variable.</p> <p>By comparing the first sample code with the code after using <code>Pait</code>,can see that the code after using <code>Pait</code> is simpler, clearer and also improves the robustness of the code.</p> <p>Note</p> <p>When using <code>Json()</code> , <code>mypy</code> will detect a type mismatch, so you can ignore this problem through <code>Json.i()</code>. If you need <code>mypy</code> to check the values of <code>default</code>, <code>default_factory</code> and <code>example</code> attributes in <code>Json</code>, it is recommended to use <code>Json.t()</code> directly.</p>"},{"location":"1_2_how_to_use_field/","title":"How to use Field","text":"<p>The <code>Field</code> object plays a vital role in <code>Pait</code>. In addition to get data sources through the <code>Field</code> object, <code>Pait</code> can also implement other feature. However, this chapter only focuses on parameter verification.</p>"},{"location":"1_2_how_to_use_field/#1kind-of-field","title":"1.Kind of Field","text":"<p>In addition to the Json mentioned above(Introduction), <code>Field</code> also has other class, their names and functions are as follows:</p> <ul> <li>Body: Get the json data of the current request</li> <li>Cookie: Get the cookie data of the current request (note that the current cookie data will be converted into a Python dictionary, which means that the key of the cookie cannot be repeated. At the same time, when the Field is a cookie, the type is preferably str)</li> <li>File\uff1aGet the file object of the current request, which is consistent with the file object of the web framework</li> <li>Form\uff1aGet the form data of the current request. If there are multiple duplicate Keys, only the first value will be returned</li> <li>Json: Get the json data of the current request</li> <li>Header: Get the header data of the current request</li> <li>Path: Get the path data of the current request, such as <code>/api/{version}/test</code>, will get the version data</li> <li>Query: Get the data corresponding to the Url parameter of the current request. If there are multiple duplicate keys, only the first value will be returned</li> <li>MultiForm\uff1aGet the form data of the current request, and return the data list corresponding to the Key</li> <li>MultiQuery\uff1aGet the data corresponding to the Url parameter of the current request, and return the data list corresponding to the Key</li> </ul> <p><code>Field</code> is easy to use, just use <code>Field</code> in the <code>default</code> of <code>&lt;name&gt;:&lt;type&gt;=&lt;default&gt;</code>, using this code as an example.</p> FlaskStarletteSanicTornado docs_source_code/introduction/how_to_use_field/flask_demo.py<pre><code>from enum import Enum\nfrom typing import List, Optional\n\nfrom flask import Flask\n\nfrom pait.app.flask import pait\nfrom pait.field import Cookie, Form, MultiForm, MultiQuery, Path, Query\n\n\nclass SexEnum(str, Enum):\n    man: str = \"man\"\n    woman: str = \"woman\"\n\n\n@pait()\ndef demo_route(\n    a: str = Form.t(description=\"form data\"),\n    b: str = Form.t(description=\"form data\"),\n    c: List[str] = MultiForm.t(description=\"form data\"),\n    cookie: dict = Cookie.t(raw_return=True, description=\"cookie\"),\n    multi_user_name: List[str] = MultiQuery.t(description=\"user name\", min_length=2, max_length=4),\n    age: int = Path.t(description=\"age\", gt=1, lt=100),\n    uid: int = Query.t(description=\"user id\", gt=10, lt=1000),\n    user_name: str = Query.t(description=\"user name\", min_length=2, max_length=4),\n    email: Optional[str] = Query.t(default=\"example@xxx.com\", description=\"user email\"),\n    sex: SexEnum = Query.t(description=\"sex\"),\n) -&gt; dict:\n    return {\n        \"code\": 0,\n        \"msg\": \"\",\n        \"data\": {\n            \"form_a\": a,\n            \"form_b\": b,\n            \"form_c\": c,\n            \"cookie\": cookie,\n            \"multi_user_name\": multi_user_name,\n            \"age\": age,\n            \"uid\": uid,\n            \"user_name\": user_name,\n            \"email\": email,\n            \"sex\": sex,\n        },\n    }\n\n\napp = Flask(\"demo\")\napp.add_url_rule(\"/api/demo/&lt;age&gt;\", \"demo\", demo_route, methods=[\"POST\"])\n\n\nif __name__ == \"__main__\":\n    app.run(port=8000)\n</code></pre> docs_source_code/introduction/how_to_use_field/starlette_demo.py<pre><code>from enum import Enum\nfrom typing import List, Optional\n\nfrom starlette.applications import Starlette\nfrom starlette.responses import JSONResponse\n\nfrom pait.app.starlette import pait\nfrom pait.field import Cookie, Form, MultiForm, MultiQuery, Path, Query\n\n\nclass SexEnum(str, Enum):\n    man: str = \"man\"\n    woman: str = \"woman\"\n\n\n@pait()\nasync def demo_route(\n    a: str = Form.t(description=\"form data\"),\n    b: str = Form.t(description=\"form data\"),\n    c: List[str] = MultiForm.t(description=\"form data\"),\n    cookie: dict = Cookie.t(raw_return=True, description=\"cookie\"),\n    multi_user_name: List[str] = MultiQuery.t(description=\"user name\", min_length=2, max_length=4),\n    age: int = Path.t(description=\"age\", gt=1, lt=100),\n    uid: int = Query.t(description=\"user id\", gt=10, lt=1000),\n    user_name: str = Query.t(description=\"user name\", min_length=2, max_length=4),\n    email: Optional[str] = Query.t(default=\"example@xxx.com\", description=\"user email\"),\n    sex: SexEnum = Query.t(description=\"sex\"),\n) -&gt; JSONResponse:\n    return JSONResponse(\n        {\n            \"code\": 0,\n            \"msg\": \"\",\n            \"data\": {\n                \"form_a\": a,\n                \"form_b\": b,\n                \"form_c\": c,\n                \"cookie\": cookie,\n                \"multi_user_name\": multi_user_name,\n                \"age\": age,\n                \"uid\": uid,\n                \"user_name\": user_name,\n                \"email\": email,\n                \"sex\": sex,\n            },\n        }\n    )\n\n\napp: Starlette = Starlette()\napp.add_route(\"/api/demo/{age}\", demo_route, methods=[\"POST\"])\n\n\nif __name__ == \"__main__\":\n    import uvicorn\n\n    uvicorn.run(app)\n</code></pre> docs_source_code/introduction/how_to_use_field/sanic_demo.py<pre><code>from enum import Enum\nfrom typing import List, Optional\n\nfrom sanic import HTTPResponse, Sanic, json\n\nfrom pait.app.sanic import pait\nfrom pait.field import Cookie, Form, MultiForm, MultiQuery, Path, Query\n\n\nclass SexEnum(str, Enum):\n    man: str = \"man\"\n    woman: str = \"woman\"\n\n\n@pait()\nasync def demo_route(\n    a: str = Form.t(description=\"form data\"),\n    b: str = Form.t(description=\"form data\"),\n    c: List[str] = MultiForm.t(description=\"form data\"),\n    cookie: dict = Cookie.t(raw_return=True, description=\"cookie\"),\n    multi_user_name: List[str] = MultiQuery.t(description=\"user name\", min_length=2, max_length=4),\n    age: int = Path.t(description=\"age\", gt=1, lt=100),\n    uid: int = Query.t(description=\"user id\", gt=10, lt=1000),\n    user_name: str = Query.t(description=\"user name\", min_length=2, max_length=4),\n    email: Optional[str] = Query.t(default=\"example@xxx.com\", description=\"user email\"),\n    sex: SexEnum = Query.t(description=\"sex\"),\n) -&gt; HTTPResponse:\n    return json(\n        {\n            \"code\": 0,\n            \"msg\": \"\",\n            \"data\": {\n                \"form_a\": a,\n                \"form_b\": b,\n                \"form_c\": c,\n                \"cookie\": cookie,\n                \"multi_user_name\": multi_user_name,\n                \"age\": age,\n                \"uid\": uid,\n                \"user_name\": user_name,\n                \"email\": email,\n                \"sex\": sex,\n            },\n        }\n    )\n\n\napp: Sanic = Sanic(name=\"demo\")\napp.add_route(demo_route, \"/api/demo/&lt;age&gt;\", methods={\"POST\"})\n\n\nif __name__ == \"__main__\":\n    app.run()\n</code></pre> docs_source_code/introduction/how_to_use_field/tornado_demo.py<pre><code>from enum import Enum\nfrom typing import List, Optional\n\nfrom tornado.ioloop import IOLoop\nfrom tornado.web import Application, RequestHandler\n\nfrom pait.app.tornado import pait\nfrom pait.field import Cookie, Form, MultiForm, MultiQuery, Path, Query\nfrom pait.openapi.doc_route import AddDocRoute\n\n\nclass SexEnum(str, Enum):\n    man: str = \"man\"\n    woman: str = \"woman\"\n\n\nclass DemoHandler(RequestHandler):\n    @pait()\n    async def post(\n        self,\n        a: str = Form.t(description=\"form data\"),\n        b: str = Form.t(description=\"form data\"),\n        c: List[str] = MultiForm.t(description=\"form data\"),\n        cookie: dict = Cookie.t(raw_return=True, description=\"cookie\"),\n        multi_user_name: List[str] = MultiQuery.t(description=\"user name\", min_length=2, max_length=4),\n        age: int = Path.t(description=\"age\", gt=1, lt=100),\n        uid: int = Query.t(description=\"user id\", gt=10, lt=1000),\n        user_name: str = Query.t(description=\"user name\", min_length=2, max_length=4),\n        email: Optional[str] = Query.t(default=\"example@xxx.com\", description=\"user email\"),\n        sex: SexEnum = Query.t(description=\"sex\"),\n    ) -&gt; None:\n        self.write(\n            {\n                \"code\": 0,\n                \"msg\": \"\",\n                \"data\": {\n                    \"form_a\": a,\n                    \"form_b\": b,\n                    \"form_c\": c,\n                    \"cookie\": cookie,\n                    \"multi_user_name\": multi_user_name,\n                    \"age\": age,\n                    \"uid\": uid,\n                    \"user_name\": user_name,\n                    \"email\": email,\n                    \"sex\": sex,\n                },\n            }\n        )\n\n\napp: Application = Application([(r\"/api/demo/(?P&lt;age&gt;\\w+)\", DemoHandler)])\nAddDocRoute(app)\n\n\nif __name__ == \"__main__\":\n    app.listen(8000)\n    IOLoop.instance().start()\n</code></pre> <p>Note</p> <p>In order to ensure that the sample code can run smoothly anywhere, the usage of the <code>File</code> field is not demonstrated here. For specific usage, please refer to the route function corresponding to <code>/api/pait-base-field</code> in the <code>field_route.py</code> file in the sample code of different web frameworks.</p> <p>The sample code demonstrates how to get the request parameters from the request object through different types of <code>Field</code> and assemble them into a certain format and return them. Next, use the <code>curl</code> command to a request test: <pre><code>curl -X 'POST' \\\n  'http://127.0.0.1:8000/api/demo/12?uid=99&amp;user_name=so1n&amp;multi_user_name=so1n' \\\n  -H 'accept: application/json' \\\n  -H 'Cookie: cookie=cookie=test cookie' \\\n  -H 'Content-Type: multipart/form-data' \\\n  -F 'form_a=a' \\\n  -F 'form_b=b' \\\n  -F 'multi_form_c=string,string'\n</code></pre></p> <p>Under normal circumstances, you will see the following output in the terminal: <pre><code>{\n    \"code\": 0,\n    \"msg\": \"\",\n    \"data\": {\n        \"accept\": \"application/json\",\n        \"form_a\": \"a\",\n        \"form_b\": \"b\",\n        \"form_c\": [\n            \"string,string\"\n        ],\n        \"cookie\": {\n            \"cookie\": \"cookie=test cookie\"\n        },\n        \"multi_user_name\": [\n            \"so1n\"\n        ],\n        \"age\": 12,\n        \"uid\": 99,\n        \"user_name\": \"so1n\",\n        \"email\": \"example@xxx.com\"\n    }\n}\n</code></pre> It can be found from the output results that <code>Pait</code> can accurately obtain the corresponding value from the request object through the <code>Field</code> type.</p>"},{"location":"1_2_how_to_use_field/#2field-feature","title":"2.Field feature","text":"<p>From the above example, can see that the <code>url</code> does not carry the <code>email</code> parameter, but the <code>email</code> in the response value is <code>example@xxx.com</code>. This is because <code>Pait</code> will assign the <code>default</code> of <code>Field</code> to the variable when the <code>email</code> value cannot be obtained through the request body.</p> <p>In addition to the default value, <code>Field</code> also has many functions, most of which are derived from <code>pydantic.Field</code>.</p>"},{"location":"1_2_how_to_use_field/#21default","title":"2.1.default","text":"<p><code>Pait</code> gets the default value of the parameter by the <code>default</code> attribute of <code>Field</code>. When the <code>default</code> attribute of the <code>Field</code> is not null and the request body does not have a corresponding value, <code>Pait</code> injects the value of <code>default</code> into the corresponding variable.</p> <p>The following is a simple sample code. Both route functions in the sample code directly return the obtained value <code>demo_value</code>. The <code>demo</code> has a default value of the string -- <code>123</code>, while the <code>demo1</code> has no default value:</p> FlaskStarletteSanicTornado docs_source_code/introduction/how_to_use_field/flask_with_default_demo.py<pre><code>from flask import Flask\n\nfrom pait import field\nfrom pait.app.flask import pait\nfrom pait.exceptions import TipException\n\n\ndef api_exception(exc: Exception) -&gt; str:\n    if isinstance(exc, TipException):\n        exc = exc.exc\n    return str(exc)\n\n\n@pait()\ndef demo(demo_value: str = field.Query.t(default=\"123\")) -&gt; str:\n    return demo_value\n\n\n@pait()\ndef demo1(demo_value: str = field.Query.t()) -&gt; str:\n    return demo_value\n\n\napp = Flask(\"demo\")\napp.add_url_rule(\"/api/demo\", view_func=demo, methods=[\"GET\"])\napp.add_url_rule(\"/api/demo1\", view_func=demo1, methods=[\"GET\"])\napp.errorhandler(Exception)(api_exception)\n\n\nif __name__ == \"__main__\":\n    app.run(port=8000)\n</code></pre> docs_source_code/introduction/how_to_use_field/starlette_with_default_demo.py<pre><code>from starlette.applications import Starlette\nfrom starlette.requests import Request\nfrom starlette.responses import PlainTextResponse\nfrom starlette.routing import Route\n\nfrom pait import field\nfrom pait.app.starlette import pait\nfrom pait.exceptions import TipException\n\n\nasync def api_exception(request: Request, exc: Exception) -&gt; PlainTextResponse:\n    if isinstance(exc, TipException):\n        exc = exc.exc\n    return PlainTextResponse(str(exc))\n\n\n@pait()\nasync def demo(demo_value: str = field.Query.t(default=\"123\")) -&gt; PlainTextResponse:\n    return PlainTextResponse(demo_value)\n\n\n@pait()\nasync def demo1(demo_value: str = field.Query.t()) -&gt; PlainTextResponse:\n    return PlainTextResponse(demo_value)\n\n\napp = Starlette(\n    routes=[\n        Route(\"/api/demo\", demo, methods=[\"GET\"]),\n        Route(\"/api/demo1\", demo1, methods=[\"GET\"]),\n    ]\n)\napp.add_exception_handler(Exception, api_exception)\n\n\nif __name__ == \"__main__\":\n    import uvicorn\n\n    uvicorn.run(app)\n</code></pre> docs_source_code/introduction/how_to_use_field/sanic_with_default_demo.py<pre><code>from sanic import HTTPResponse, Request, Sanic\n\nfrom pait import field\nfrom pait.app.sanic import pait\nfrom pait.exceptions import TipException\n\n\nasync def api_exception(request: Request, exc: Exception) -&gt; HTTPResponse:\n    if isinstance(exc, TipException):\n        exc = exc.exc\n    return HTTPResponse(str(exc))\n\n\n@pait()\nasync def demo(demo_value: str = field.Query.t(default=\"123\")) -&gt; HTTPResponse:\n    return HTTPResponse(demo_value)\n\n\n@pait()\nasync def demo1(demo_value: str = field.Query.t()) -&gt; HTTPResponse:\n    return HTTPResponse(demo_value)\n\n\napp = Sanic(\"demo\")\napp.add_route(demo, \"/api/demo\", methods={\"GET\"})\napp.add_route(demo1, \"/api/demo1\", methods={\"GET\"})\napp.exception(Exception)(api_exception)\n\n\nif __name__ == \"__main__\":\n    import uvicorn\n\n    uvicorn.run(app)\n</code></pre> docs_source_code/introduction/how_to_use_field/tornado_with_default_demo.py<pre><code>from tornado.ioloop import IOLoop\nfrom tornado.web import Application, RequestHandler\n\nfrom pait import field\nfrom pait.app.tornado import pait\nfrom pait.exceptions import TipException\nfrom pait.openapi.doc_route import AddDocRoute\n\n\nclass _Handler(RequestHandler):\n    def _handle_request_exception(self, exc: BaseException) -&gt; None:\n        if isinstance(exc, TipException):\n            exc = exc.exc\n        self.write(str(exc))\n        self.finish()\n\n\nclass DemoHandler(_Handler):\n    @pait()\n    async def get(self, demo_value: str = field.Query.t(default=\"123\")) -&gt; None:\n        self.write(demo_value)\n\n\nclass Demo1Handler(_Handler):\n    @pait()\n    async def get(self, demo_value: str = field.Query.t()) -&gt; None:\n        self.write(demo_value)\n\n\napp: Application = Application([(r\"/api/demo\", DemoHandler), (r\"/api/demo1\", Demo1Handler)])\nAddDocRoute(app)\n\n\nif __name__ == \"__main__\":\n    app.listen(8000)\n    IOLoop.instance().start()\n</code></pre> <p>After running the code and calling <code>curl</code>, can see that the <code>/api/demo</code> route returns 123 by default when the <code>demo_value</code> parameter is not passed, while the <code>/api/demo1</code> route throws an error that the <code>demo_value</code> value was not found, as follows.</p> curl \"http://127.0.0.1:8000/api/demo\"123curl \"http://127.0.0.1:8000/api/demo1\"Can not found demo_value value <p>When the <code>demo value</code> parameter passed is 456, both the <code>/api/demo</code> and <code>/api/demo 1</code> routes will return 456:</p> curl \"http://127.0.0.1:8000/api/demo?demo_value=456\"456curl \"http://127.0.0.1:8000/api/demo1?demo_value=456\"456 <p>Note</p> <p>Error handling uses <code>Tip Exception</code>. You can learn about the function of <code>TipException</code> through Exception Tip.</p>"},{"location":"1_2_how_to_use_field/#22default_factory","title":"2.2.default_factory","text":"<p>The feature of <code>default_factory</code> is similar to <code>default</code>, except that the value received by <code>default_factory</code> is a function, which will be executed  and inject the return value into the variable when the request hits the route function and <code>Pait</code> cannot find the required value of the variable from the request object.</p> <p>Sample code is as follows, the default value of the first route function is the current time, the default value of the second route function is uuid, and their return values are generated each time a request is received.</p> FlaskStarletteSanicTornado docs_source_code/introduction/how_to_use_field/flask_with_default_factory_demo.py<pre><code>import datetime\nimport uuid\n\nfrom flask import Flask\n\nfrom pait import field\nfrom pait.app.flask import pait\nfrom pait.exceptions import TipException\n\n\ndef api_exception(exc: Exception) -&gt; str:\n    if isinstance(exc, TipException):\n        exc = exc.exc\n    return str(exc)\n\n\n@pait()\ndef demo(demo_value: datetime.datetime = field.Query.t(default_factory=datetime.datetime.now)) -&gt; str:\n    return str(demo_value)\n\n\n@pait()\ndef demo1(demo_value: str = field.Query.t(default_factory=lambda: uuid.uuid4().hex)) -&gt; str:\n    return demo_value\n\n\napp = Flask(\"demo\")\napp.add_url_rule(\"/api/demo\", view_func=demo, methods=[\"GET\"])\napp.add_url_rule(\"/api/demo1\", view_func=demo1, methods=[\"GET\"])\napp.errorhandler(Exception)(api_exception)\n\n\nif __name__ == \"__main__\":\n    app.run(port=8000)\n</code></pre> docs_source_code/introduction/how_to_use_field/starlette_with_default_factory_demo.py<pre><code>import datetime\nimport uuid\n\nfrom starlette.applications import Starlette\nfrom starlette.requests import Request\nfrom starlette.responses import PlainTextResponse\nfrom starlette.routing import Route\n\nfrom pait import field\nfrom pait.app.starlette import pait\nfrom pait.exceptions import TipException\n\n\nasync def api_exception(request: Request, exc: Exception) -&gt; PlainTextResponse:\n    if isinstance(exc, TipException):\n        exc = exc.exc\n    return PlainTextResponse(str(exc))\n\n\n@pait()\nasync def demo(\n    demo_value: datetime.datetime = field.Query.t(default_factory=datetime.datetime.now),\n) -&gt; PlainTextResponse:\n    return PlainTextResponse(str(demo_value))\n\n\n@pait()\nasync def demo1(demo_value: str = field.Query.t(default_factory=lambda: uuid.uuid4().hex)) -&gt; PlainTextResponse:\n    return PlainTextResponse(demo_value)\n\n\napp = Starlette(\n    routes=[\n        Route(\"/api/demo\", demo, methods=[\"GET\"]),\n        Route(\"/api/demo1\", demo1, methods=[\"GET\"]),\n    ]\n)\napp.add_exception_handler(Exception, api_exception)\n\n\nif __name__ == \"__main__\":\n    import uvicorn\n\n    uvicorn.run(app)\n</code></pre> docs_source_code/introduction/how_to_use_field/sanic_with_default_factory_demo.py<pre><code>import datetime\nimport uuid\n\nfrom sanic import HTTPResponse, Request, Sanic\n\nfrom pait import field\nfrom pait.app.sanic import pait\nfrom pait.exceptions import TipException\n\n\nasync def api_exception(request: Request, exc: Exception) -&gt; HTTPResponse:\n    if isinstance(exc, TipException):\n        exc = exc.exc\n    return HTTPResponse(str(exc))\n\n\n@pait()\nasync def demo(demo_value: datetime.datetime = field.Query.t(default_factory=datetime.datetime.now)) -&gt; HTTPResponse:\n    return HTTPResponse(str(demo_value))\n\n\n@pait()\nasync def demo1(demo_value: str = field.Query.t(default_factory=lambda: uuid.uuid4().hex)) -&gt; HTTPResponse:\n    return HTTPResponse(demo_value)\n\n\napp = Sanic(\"demo\")\napp.add_route(demo, \"/api/demo\", methods={\"GET\"})\napp.add_route(demo1, \"/api/demo1\", methods={\"GET\"})\napp.exception(Exception)(api_exception)\n\n\nif __name__ == \"__main__\":\n    import uvicorn\n\n    uvicorn.run(app)\n</code></pre> docs_source_code/introduction/how_to_use_field/tornado_with_default_factory_demo.py<pre><code>import datetime\nimport uuid\n\nfrom tornado.ioloop import IOLoop\nfrom tornado.web import Application, RequestHandler\n\nfrom pait import field\nfrom pait.app.tornado import pait\nfrom pait.exceptions import TipException\nfrom pait.openapi.doc_route import AddDocRoute\n\n\nclass _Handler(RequestHandler):\n    def _handle_request_exception(self, exc: BaseException) -&gt; None:\n        if isinstance(exc, TipException):\n            exc = exc.exc\n        self.write(str(exc))\n        self.finish()\n\n\nclass DemoHandler(_Handler):\n    @pait()\n    async def get(self, demo_value: datetime.datetime = field.Query.t(default_factory=datetime.datetime.now)) -&gt; None:\n        self.write(str(demo_value))\n\n\nclass Demo1Handler(_Handler):\n    @pait()\n    async def get(self, demo_value: str = field.Query.t(default_factory=lambda: uuid.uuid4().hex)) -&gt; None:\n        self.write(demo_value)\n\n\napp: Application = Application([(r\"/api/demo\", DemoHandler), (r\"/api/demo1\", Demo1Handler)])\nAddDocRoute(app)\n\n\nif __name__ == \"__main__\":\n    app.listen(8000)\n    IOLoop.instance().start()\n</code></pre> <p>After running the code and calling <code>curl</code>, can find that the results displayed are different each time:</p> curl \"http://127.0.0.1:8000/api/demo\"2022-02-07T14:54:29.127519curl \"http://127.0.0.1:8000/api/demo\"2022-02-07T14:54:33.789994curl \"http://127.0.0.1:8000/api/demo1\"7e4659e18103471da9db91ed4843d962curl \"http://127.0.0.1:8000/api/demo1\"ef84f04fa9fc4ea9a8b44449c76146b8"},{"location":"1_2_how_to_use_field/#23alias","title":"2.3.alias","text":"<p>Normally <code>Pait</code> will get data from the request body with the parameter name key, but some parameter names such as <code>Content-Type</code> are not available in <code>Python</code>. In this case, can use <code>alias</code> to set an alias for the variable, as shown in the following sample code:</p> FlaskStarletteSanicTornado docs_source_code/introduction/how_to_use_field/flask_with_alias_demo.py<pre><code>from flask import Flask\n\nfrom pait import field\nfrom pait.app.flask import pait\n\n\n@pait()\ndef demo(content_type: str = field.Header.t(alias=\"Content-Type\")) -&gt; str:\n    return content_type\n\n\napp = Flask(\"demo\")\n\napp.add_url_rule(\"/api/demo\", view_func=demo, methods=[\"GET\"])\n\n\nif __name__ == \"__main__\":\n    app.run(port=8000)\n</code></pre> docs_source_code/introduction/how_to_use_field/starlette_with_alias_demo.py<pre><code>from starlette.applications import Starlette\nfrom starlette.responses import PlainTextResponse\nfrom starlette.routing import Route\n\nfrom pait import field\nfrom pait.app.starlette import pait\n\n\n@pait()\nasync def demo(content_type: str = field.Header.t(alias=\"Content-Type\")) -&gt; PlainTextResponse:\n    return PlainTextResponse(content_type)\n\n\napp = Starlette(\n    routes=[\n        Route(\"/api/demo\", demo, methods=[\"GET\"]),\n    ]\n)\n\n\nif __name__ == \"__main__\":\n    import uvicorn\n\n    uvicorn.run(app)\n</code></pre> docs_source_code/introduction/how_to_use_field/sanic_with_alias_demo.py<pre><code>from sanic import HTTPResponse, Sanic\n\nfrom pait import field\nfrom pait.app.sanic import pait\n\n\n@pait()\nasync def demo(content_type: str = field.Header.t(alias=\"Content-Type\")) -&gt; HTTPResponse:\n    return HTTPResponse(content_type)\n\n\napp = Sanic(\"demo\")\napp.add_route(demo, \"/api/demo\", methods={\"GET\"})\n\n\nif __name__ == \"__main__\":\n    import uvicorn\n\n    uvicorn.run(app)\n</code></pre> docs_source_code/introduction/how_to_use_field/tornado_with_alias_demo.py<pre><code>from tornado.ioloop import IOLoop\nfrom tornado.web import Application, RequestHandler\n\nfrom pait import field\nfrom pait.app.tornado import pait\nfrom pait.openapi.doc_route import AddDocRoute\n\n\nclass DemoHandler(RequestHandler):\n    @pait()\n    async def get(self, content_type: str = field.Header.t(alias=\"Content-Type\")) -&gt; None:\n        self.write(content_type)\n\n\napp: Application = Application([(r\"/api/demo\", DemoHandler)])\nAddDocRoute(app)\n\n\nif __name__ == \"__main__\":\n    app.listen(8000)\n    IOLoop.instance().start()\n</code></pre> <p>After running the code and calling the <code>curl</code> command, can find that <code>Pait</code> extracts the value of <code>Content-Type</code> from the header of the request body and assigns it to the <code>content type</code> variable, so the route function can return the value <code>123</code> normally:</p> curl \"http://127.0.0.1:8000/api/demo\" -H \"Content-Type:123\"123"},{"location":"1_2_how_to_use_field/#24gt-ge-lt-le-and-multiple-of-numeric-type-checks","title":"2.4.GT, GE, LT, LE, and multiple of numeric type checks","text":"<p><code>gt</code>, <code>ge</code>, <code>lt</code>, <code>le</code>, and <code>multiple_of</code> all belong to <code>pydantic</code>\u2019s numerical type checks. They are only used for numerical types and have different functions:</p> <ul> <li>gt\uff1aA type that is only used for numeric values. It will check whether the value is greater than this value and also add the <code>exclusiveMinimum</code> attribute to the OpenAPI.\u3002</li> <li>ge\uff1aA type that is only used for numeric values. It will check whether the value is greater than or equal this value and also add the <code>exclusiveMaximum</code> attribute to the OpenAPI.\u3002</li> <li>lt\uff1aA type that is only used for numeric values. It will check whether the value is less than this value and also add the <code>exclusiveMinimum</code> attribute to the OpenAPI.\u3002</li> <li>le\uff1aA type that is only used for numeric values. It will check whether the value is less than or equal this value and also add the <code>exclusiveMaximum</code> attribute to the OpenAPI.\u3002</li> <li>multiple_of\uff1aOnly used for numbers, it will check whether the number is a multiple of the specified value\u3002</li> </ul> <p>Usage:</p> FlaskStarletteSanicTornado docs_source_code/introduction/how_to_use_field/flask_with_num_check_demo.py<pre><code>from flask import Flask, Response, jsonify\nfrom pydantic import ValidationError\n\nfrom pait import field\nfrom pait.app.flask import pait\nfrom pait.exceptions import TipException\n\n\ndef api_exception(exc: Exception) -&gt; Response:\n    if isinstance(exc, TipException):\n        exc = exc.exc\n    if isinstance(exc, ValidationError):\n        return jsonify({\"data\": exc.errors()})\n    return jsonify({\"data\": str(exc)})\n\n\n@pait()\ndef demo(\n    demo_value1: int = field.Query.i(gt=1, lt=10),\n    demo_value2: int = field.Query.i(ge=1, le=1),\n    demo_value3: int = field.Query.i(multiple_of=3),\n) -&gt; dict:\n    return {\"data\": [demo_value1, demo_value2, demo_value3]}\n\n\napp = Flask(\"demo\")\napp.add_url_rule(\"/api/demo\", view_func=demo, methods=[\"GET\"])\napp.errorhandler(Exception)(api_exception)\n\n\nif __name__ == \"__main__\":\n    app.run(port=8000)\n</code></pre> docs_source_code/introduction/how_to_use_field/starlette_with_num_check_demo.py<pre><code>from pydantic import ValidationError\nfrom starlette.applications import Starlette\nfrom starlette.requests import Request\nfrom starlette.responses import JSONResponse\nfrom starlette.routing import Route\n\nfrom pait import field\nfrom pait.app.starlette import pait\nfrom pait.exceptions import TipException\n\n\nasync def api_exception(request: Request, exc: Exception) -&gt; JSONResponse:\n    if isinstance(exc, TipException):\n        exc = exc.exc\n    if isinstance(exc, ValidationError):\n        return JSONResponse({\"data\": exc.errors()})\n    return JSONResponse({\"data\": str(exc)})\n\n\n@pait()\nasync def demo(\n    demo_value1: int = field.Query.i(gt=1, lt=10),\n    demo_value2: int = field.Query.i(ge=1, le=1),\n    demo_value3: int = field.Query.i(multiple_of=3),\n) -&gt; JSONResponse:\n    return JSONResponse({\"data\": [demo_value1, demo_value2, demo_value3]})\n\n\napp = Starlette(\n    routes=[\n        Route(\"/api/demo\", demo, methods=[\"GET\"]),\n    ]\n)\napp.add_exception_handler(Exception, api_exception)\n\n\nif __name__ == \"__main__\":\n    import uvicorn\n\n    uvicorn.run(app)\n</code></pre> docs_source_code/introduction/how_to_use_field/sanic_with_num_check_demo.py<pre><code>from pydantic import ValidationError\nfrom sanic import HTTPResponse, Request, Sanic, json\n\nfrom pait import field\nfrom pait.app.sanic import pait\nfrom pait.exceptions import TipException\n\n\nasync def api_exception(request: Request, exc: Exception) -&gt; HTTPResponse:\n    if isinstance(exc, TipException):\n        exc = exc.exc\n    if isinstance(exc, ValidationError):\n        return json({\"data\": exc.errors()})\n    return json({\"data\": str(exc)})\n\n\n@pait()\nasync def demo(\n    demo_value1: int = field.Query.i(gt=1, lt=10),\n    demo_value2: int = field.Query.i(ge=1, le=1),\n    demo_value3: int = field.Query.i(multiple_of=3),\n) -&gt; HTTPResponse:\n    return json({\"data\": [demo_value1, demo_value2, demo_value3]})\n\n\napp = Sanic(\"demo\")\napp.add_route(demo, \"/api/demo\", methods={\"GET\"})\napp.exception(Exception)(api_exception)\n\n\nif __name__ == \"__main__\":\n    import uvicorn\n\n    uvicorn.run(app)\n</code></pre> docs_source_code/introduction/how_to_use_field/tornado_with_num_check_demo.py<pre><code>from pydantic import ValidationError\nfrom tornado.ioloop import IOLoop\nfrom tornado.web import Application, RequestHandler\n\nfrom pait import field\nfrom pait.app.tornado import pait\nfrom pait.exceptions import TipException\nfrom pait.openapi.doc_route import AddDocRoute\n\n\nclass _Handler(RequestHandler):\n    def _handle_request_exception(self, exc: BaseException) -&gt; None:\n        if isinstance(exc, TipException):\n            exc = exc.exc\n\n        if isinstance(exc, ValidationError):\n            self.write({\"data\": exc.errors()})\n        else:\n            self.write({\"data\": str(exc)})\n        self.finish()\n\n\nclass DemoHandler(_Handler):\n    @pait()\n    async def get(\n        self,\n        demo_value1: int = field.Query.i(gt=1, lt=10),\n        demo_value2: int = field.Query.i(ge=1, le=1),\n        demo_value3: int = field.Query.i(multiple_of=3),\n    ) -&gt; None:\n        self.write({\"data\": [demo_value1, demo_value2, demo_value3]})\n\n\napp: Application = Application([(r\"/api/demo\", DemoHandler)])\nAddDocRoute(app)\n\n\nif __name__ == \"__main__\":\n    app.listen(8000)\n    IOLoop.instance().start()\n</code></pre> <p>This sample code has only one route function, but it accepts three parameters <code>demo_value1</code>, <code>demo_value2</code> and <code>demo_value3</code>. They only receive three parameters that are greater than 1 and less than 10, equal to 1 and a multiple of 3 respectively.</p> <p>After running the code and calling the <code>curl</code> command, can find that the first request meets the requirements and gets the correct response result. However, the values of the <code>demo_value 1</code>, <code>demo_value 2</code> and <code>demo_value 3</code> parameters of the second, third and fourth requests are not within the required range, so <code>Pait</code> will generate error message by <code>Pydantic.Validation Error</code>, it can be easily seen that the three parameters do not meet the restrictions set by the route function: <pre><code>\u279c  ~ curl \"http://127.0.0.1:8000/api/demo?demo_value1=2&amp;demo_value2=1&amp;demo_value3=3\"\n{\"data\":[2,1,3]}\n\u279c  ~ curl \"http://127.0.0.1:8000/api/demo?demo_value1=11&amp;demo_value2=1&amp;demo_value3=3\"\n{\n    \"data\": [\n        {\n            \"ctx\": {\"limit_value\": 10},\n            \"loc\": [\"query\", \"demo_value1\"],\n            \"msg\": \"ensure this value is less than 10\",\n            \"type\": \"value_error.number.not_lt\"\n        }\n    ]\n}\n\u279c  ~ curl \"http://127.0.0.1:8000/api/demo?demo_value1=2&amp;demo_value2=2&amp;demo_value3=3\"\n{\n    \"data\": [\n        {\n            \"ctx\": {\"limit_value\": 1},\n            \"loc\": [\"query\", \"demo_value2\"],\n            \"msg\": \"ensure this value is less than or equal to 1\",\n            \"type\": \"value_error.number.not_le\"\n        }\n    ]\n}\n\u279c  ~ curl \"http://127.0.0.1:8000/api/demo?demo_value1=2&amp;demo_value2=1&amp;demo_value3=4\"\n{\n    \"data\": [\n        {\n            \"ctx\": {\"multiple_of\": 3},\n            \"loc\": [\"query\", \"demo_value3\"],\n            \"msg\": \"ensure this value is a multiple of 3\",\n            \"type\": \"value_error.number.not_multiple\"\n        }\n    ]\n}\n</code></pre></p>"},{"location":"1_2_how_to_use_field/#25sequence-verification-min_itemsmax_items","title":"2.5.Sequence verification: min_items\uff0cmax_items","text":"<p><code>min items</code> and <code>max items</code> both belong to the <code>Sequence</code> type check of <code>pydantic</code> and are only used for the <code>Sequence</code> type. Their functions are different:</p> <ul> <li>min_items\uff1aOnly used for <code>Sequence</code> type, it will check whether <code>Sequence</code> length is greater than or equal to the specified value.\u3002</li> <li>max_items\uff1a Only used for <code>Sequence</code> type, it will check whether <code>Sequence</code> length is less than or equal to the specified value.</li> </ul> <p>Note</p> <p>If using Pydantic version greater than 2.0.0, please use <code>min_length</code> and <code>max_length</code> instead of <code>min_items</code> and <code>max_items</code>.</p> <p>Sample code is as follows, the route function through the <code>field.MultiQuery</code> from the request Url to obtain the parameter <code>demo_value</code> of the array and return to the caller, where the length of the array is limited to between 1 and 2:</p> FlaskStarletteSanicTornado docs_source_code/introduction/how_to_use_field/flask_with_item_check_demo.py<pre><code>from typing import List\n\nfrom flask import Flask, Response, jsonify\nfrom pydantic import ValidationError\n\nfrom pait import field\nfrom pait.app.flask import pait\nfrom pait.exceptions import TipException\n\n\ndef api_exception(exc: Exception) -&gt; Response:\n    if isinstance(exc, TipException):\n        exc = exc.exc\n    if isinstance(exc, ValidationError):\n        return jsonify({\"data\": exc.errors()})\n    return jsonify({\"data\": str(exc)})\n\n\n@pait()\ndef demo(\n    demo_value: List[int] = field.MultiQuery.i(min_items=1, max_items=2),\n) -&gt; dict:\n    return {\"data\": demo_value}\n\n\napp = Flask(\"demo\")\napp.add_url_rule(\"/api/demo\", view_func=demo, methods=[\"GET\"])\napp.errorhandler(Exception)(api_exception)\n\n\nif __name__ == \"__main__\":\n    app.run(port=8000)\n</code></pre> docs_source_code/introduction/how_to_use_field/starlette_with_item_check_demo.py<pre><code>from typing import List\n\nfrom pydantic import ValidationError\nfrom starlette.applications import Starlette\nfrom starlette.requests import Request\nfrom starlette.responses import JSONResponse\nfrom starlette.routing import Route\n\nfrom pait import field\nfrom pait.app.starlette import pait\nfrom pait.exceptions import TipException\n\n\nasync def api_exception(request: Request, exc: Exception) -&gt; JSONResponse:\n    if isinstance(exc, TipException):\n        exc = exc.exc\n    if isinstance(exc, ValidationError):\n        return JSONResponse({\"data\": exc.errors()})\n    return JSONResponse({\"data\": str(exc)})\n\n\n@pait()\nasync def demo(\n    demo_value: List[int] = field.MultiQuery.i(min_items=1, max_items=2),\n) -&gt; JSONResponse:\n    return JSONResponse({\"data\": demo_value})\n\n\napp = Starlette(\n    routes=[\n        Route(\"/api/demo\", demo, methods=[\"GET\"]),\n    ]\n)\napp.add_exception_handler(Exception, api_exception)\n\n\nif __name__ == \"__main__\":\n    import uvicorn\n\n    uvicorn.run(app)\n</code></pre> docs_source_code/introduction/how_to_use_field/sanic_with_item_check_demo.py<pre><code>from typing import List\n\nfrom pydantic import ValidationError\nfrom sanic import HTTPResponse, Request, Sanic, json\n\nfrom pait import field\nfrom pait.app.sanic import pait\nfrom pait.exceptions import TipException\n\n\nasync def api_exception(request: Request, exc: Exception) -&gt; HTTPResponse:\n    if isinstance(exc, TipException):\n        exc = exc.exc\n    if isinstance(exc, ValidationError):\n        return json({\"data\": exc.errors()})\n    return json({\"data\": str(exc)})\n\n\n@pait()\nasync def demo(demo_value: List[int] = field.MultiQuery.i(min_items=1, max_items=2)) -&gt; HTTPResponse:\n    return json({\"data\": demo_value})\n\n\napp = Sanic(\"demo\")\napp.add_route(demo, \"/api/demo\", methods={\"GET\"})\napp.exception(Exception)(api_exception)\n\n\nif __name__ == \"__main__\":\n    import uvicorn\n\n    uvicorn.run(app)\n</code></pre> docs_source_code/introduction/how_to_use_field/tornado_with_item_check_demo.py<pre><code>from typing import List\n\nfrom pydantic import ValidationError\nfrom tornado.ioloop import IOLoop\nfrom tornado.web import Application, RequestHandler\n\nfrom pait import field\nfrom pait.app.tornado import pait\nfrom pait.exceptions import TipException\nfrom pait.openapi.doc_route import AddDocRoute\n\n\nclass _Handler(RequestHandler):\n    def _handle_request_exception(self, exc: BaseException) -&gt; None:\n        if isinstance(exc, TipException):\n            exc = exc.exc\n\n        if isinstance(exc, ValidationError):\n            self.write({\"data\": exc.errors()})\n        else:\n            self.write({\"data\": str(exc)})\n        self.finish()\n\n\nclass DemoHandler(_Handler):\n    @pait()\n    async def get(self, demo_value: List[int] = field.MultiQuery.i(min_items=1, max_items=2)) -&gt; None:\n        self.write({\"data\": demo_value})\n\n\napp: Application = Application([(r\"/api/demo\", DemoHandler)])\nAddDocRoute(app)\n\n\nif __name__ == \"__main__\":\n    app.listen(8000)\n    IOLoop.instance().start()\n</code></pre> <p>As in 2.4, by calling the <code>curl</code> command can find that legal parameters will be allowed, and illegal parameters will throw an error: <pre><code>\u279c  ~ curl \"http://127.0.0.1:8000/api/demo?demo_value=1\"\n{\"data\":[1]}\n\u279c  ~ curl \"http://127.0.0.1:8000/api/demo?demo_value=1&amp;demo_value=2\"\n{\"data\":[1,2]}\n\u279c  ~ curl \"http://127.0.0.1:8000/api/demo?demo_value=1&amp;demo_value=2&amp;demo_value=3\"\n{\n    \"data\": [\n        {\n            \"loc\": [\n                \"demo_value\"\n            ],\n            \"msg\": \"ensure this value has at most 2 items\",\n            \"type\": \"value_error.list.max_items\",\n            \"ctx\": {\n                \"limit_value\": 2\n            }\n        }\n    ]\n}\n</code></pre></p>"},{"location":"1_2_how_to_use_field/#26string-verification-min_lengthmax_lengthregex","title":"2.6.String verification: min_length\uff0cmax_length\uff0cregex","text":"<p><code>min_length</code>, <code>max_length</code> and <code>regex</code> are all part of <code>pydantic</code>'s string type checking, which is only used for string types and they serve different purposes:</p> <ul> <li>min_length\uff1aOnly used for string type, it will check whether the length of the string is greater than or equal to the specified value.</li> <li>max_length\uff1aOnly used for string type, it will check whether the length of the string is less than or equal to the specified value.</li> <li>regex\uff1aOnly used for string types, it will check whether the string conforms to the regular expression.</li> </ul> <p>Note</p> <p>If using Pydantic version greater than 2.0.0, please use <code>pattern</code> instead of <code>regex</code>.</p> <p>The sample code is as follows, the route function needs to obtain a value with a length of 6 and starting with the English letter <code>u</code> from the Url:</p> FlaskStarletteSanicTornado docs_source_code/introduction/how_to_use_field/flask_with_string_check_demo.py<pre><code>from flask import Flask, Response, jsonify\nfrom pydantic import ValidationError\n\nfrom pait import field\nfrom pait.app.flask import pait\nfrom pait.exceptions import TipException\n\n\ndef api_exception(exc: Exception) -&gt; Response:\n    if isinstance(exc, TipException):\n        exc = exc.exc\n    if isinstance(exc, ValidationError):\n        return jsonify({\"data\": exc.errors()})\n    return jsonify({\"data\": str(exc)})\n\n\n@pait()\ndef demo(demo_value: str = field.Query.i(min_length=6, max_length=6, regex=\"^u\")) -&gt; dict:\n    return {\"data\": demo_value}\n\n\napp = Flask(\"demo\")\napp.add_url_rule(\"/api/demo\", view_func=demo, methods=[\"GET\"])\napp.errorhandler(Exception)(api_exception)\n\n\nif __name__ == \"__main__\":\n    app.run(port=8000)\n</code></pre> docs_source_code/introduction/how_to_use_field/starlette_with_string_check_demo.py<pre><code>from pydantic import ValidationError\nfrom starlette.applications import Starlette\nfrom starlette.requests import Request\nfrom starlette.responses import JSONResponse\nfrom starlette.routing import Route\n\nfrom pait import field\nfrom pait.app.starlette import pait\nfrom pait.exceptions import TipException\n\n\nasync def api_exception(request: Request, exc: Exception) -&gt; JSONResponse:\n    if isinstance(exc, TipException):\n        exc = exc.exc\n    if isinstance(exc, ValidationError):\n        return JSONResponse({\"data\": exc.errors()})\n    return JSONResponse({\"data\": str(exc)})\n\n\n@pait()\nasync def demo(demo_value: str = field.Query.i(min_length=6, max_length=6, regex=\"^u\")) -&gt; JSONResponse:\n    return JSONResponse({\"data\": demo_value})\n\n\napp = Starlette(\n    routes=[\n        Route(\"/api/demo\", demo, methods=[\"GET\"]),\n    ]\n)\napp.add_exception_handler(Exception, api_exception)\n\n\nif __name__ == \"__main__\":\n    import uvicorn\n\n    uvicorn.run(app)\n</code></pre> docs_source_code/introduction/how_to_use_field/sanic_with_string_check_demo.py<pre><code>from pydantic import ValidationError\nfrom sanic import HTTPResponse, Request, Sanic, json\n\nfrom pait import field\nfrom pait.app.sanic import pait\nfrom pait.exceptions import TipException\n\n\nasync def api_exception(request: Request, exc: Exception) -&gt; HTTPResponse:\n    if isinstance(exc, TipException):\n        exc = exc.exc\n    if isinstance(exc, ValidationError):\n        return json({\"data\": exc.errors()})\n    return json({\"data\": str(exc)})\n\n\n@pait()\nasync def demo(demo_value: str = field.Query.i(min_length=6, max_length=6, regex=\"^u\")) -&gt; HTTPResponse:\n    return json({\"data\": demo_value})\n\n\napp = Sanic(\"demo\")\napp.add_route(demo, \"/api/demo\", methods={\"GET\"})\napp.exception(Exception)(api_exception)\n\n\nif __name__ == \"__main__\":\n    import uvicorn\n\n    uvicorn.run(app)\n</code></pre> docs_source_code/introduction/how_to_use_field/tornado_with_string_check_demo.py<pre><code>from pydantic import ValidationError\nfrom tornado.ioloop import IOLoop\nfrom tornado.web import Application, RequestHandler\n\nfrom pait import field\nfrom pait.app.tornado import pait\nfrom pait.exceptions import TipException\nfrom pait.openapi.doc_route import AddDocRoute\n\n\nclass _Handler(RequestHandler):\n    def _handle_request_exception(self, exc: BaseException) -&gt; None:\n        if isinstance(exc, TipException):\n            exc = exc.exc\n\n        if isinstance(exc, ValidationError):\n            self.write({\"data\": exc.errors()})\n        else:\n            self.write({\"data\": str(exc)})\n        self.finish()\n\n\nclass DemoHandler(_Handler):\n    @pait()\n    async def get(self, demo_value: str = field.Query.i(min_length=6, max_length=6, regex=\"^u\")) -&gt; None:\n        self.write({\"data\": demo_value})\n\n\napp: Application = Application([(r\"/api/demo\", DemoHandler)])\nAddDocRoute(app)\n\n\nif __name__ == \"__main__\":\n    app.listen(8000)\n    IOLoop.instance().start()\n</code></pre> <p>Run the code and use <code>curl</code> to make three requests. It can be seen from the results that the result of the first request is normal, the result of the second request does not meet the regular expression and the result length of the third request does not meet the requirements: <pre><code>\u279c  ~ curl \"http://127.0.0.1:8000/api/demo?demo_value=u66666\"\n{\"data\":\"u66666\"}\n\u279c  ~ curl \"http://127.0.0.1:8000/api/demo?demo_value=666666\"\n{\"data\":[{\"loc\":[\"demo_value\"],\"msg\":\"string does not match regex \\\"^u\\\"\",\"type\":\"value_error.str.regex\",\"ctx\":{\"pattern\":\"^u\"}}]}\n\u279c  ~ curl \"http://127.0.0.1:8000/api/demo?demo_value=1\"\n{\"data\":[{\"loc\":[\"demo_value\"],\"msg\":\"ensure this value has at least 6 characters\",\"type\":\"value_error.any_str.min_length\",\"ctx\":{\"limit_value\":6}}]}\n</code></pre></p>"},{"location":"1_2_how_to_use_field/#27raw_return","title":"2.7.raw_return","text":"<p>Sample code is as follows, the route function requires two values, the first value for the entire client passed the Json parameters and the second value for the client passed the Json parameters in the Key for a value:</p> FlaskStarletteSanicTornado docs_source_code/introduction/how_to_use_field/flask_with_raw_return_demo.py<pre><code>from flask import Flask, Response, jsonify\nfrom pydantic import ValidationError\n\nfrom pait import field\nfrom pait.app.flask import pait\nfrom pait.exceptions import TipException\n\n\ndef api_exception(exc: Exception) -&gt; Response:\n    if isinstance(exc, TipException):\n        exc = exc.exc\n    if isinstance(exc, ValidationError):\n        return jsonify({\"data\": exc.errors()})\n    return jsonify({\"data\": str(exc)})\n\n\n@pait()\ndef demo(\n    demo_value: dict = field.Json.i(raw_return=True),\n    a: str = field.Json.i(),\n) -&gt; dict:\n    return {\"data\": demo_value, \"a\": a}\n\n\napp = Flask(\"demo\")\napp.add_url_rule(\"/api/demo\", view_func=demo, methods=[\"POST\"])\napp.errorhandler(Exception)(api_exception)\n\n\nif __name__ == \"__main__\":\n    app.run(port=8000)\n</code></pre> docs_source_code/introduction/how_to_use_field/starlette_with_raw_return_demo.py<pre><code>from pydantic import ValidationError\nfrom starlette.applications import Starlette\nfrom starlette.requests import Request\nfrom starlette.responses import JSONResponse\nfrom starlette.routing import Route\n\nfrom pait import field\nfrom pait.app.starlette import pait\nfrom pait.exceptions import TipException\n\n\nasync def api_exception(request: Request, exc: Exception) -&gt; JSONResponse:\n    if isinstance(exc, TipException):\n        exc = exc.exc\n    if isinstance(exc, ValidationError):\n        return JSONResponse({\"data\": exc.errors()})\n    return JSONResponse({\"data\": str(exc)})\n\n\n@pait()\nasync def demo(\n    demo_value: dict = field.Json.i(raw_return=True),\n    a: str = field.Json.i(),\n) -&gt; JSONResponse:\n    return JSONResponse({\"data\": demo_value, \"a\": a})\n\n\napp = Starlette(\n    routes=[\n        Route(\"/api/demo\", demo, methods=[\"POST\"]),\n    ]\n)\napp.add_exception_handler(Exception, api_exception)\n\n\nif __name__ == \"__main__\":\n    import uvicorn\n\n    uvicorn.run(app)\n</code></pre> docs_source_code/introduction/how_to_use_field/sanic_with_raw_return_demo.py<pre><code>from pydantic import ValidationError\nfrom sanic import HTTPResponse, Request, Sanic, json\n\nfrom pait import field\nfrom pait.app.sanic import pait\nfrom pait.exceptions import TipException\n\n\nasync def api_exception(request: Request, exc: Exception) -&gt; HTTPResponse:\n    if isinstance(exc, TipException):\n        exc = exc.exc\n    if isinstance(exc, ValidationError):\n        return json({\"data\": exc.errors()})\n    return json({\"data\": str(exc)})\n\n\n@pait()\nasync def demo(\n    demo_value: dict = field.Json.i(raw_return=True),\n    a: str = field.Json.i(),\n) -&gt; HTTPResponse:\n    return json({\"data\": demo_value, \"a\": a})\n\n\napp = Sanic(\"demo\")\napp.add_route(demo, \"/api/demo\", methods={\"POST\"})\napp.exception(Exception)(api_exception)\n\n\nif __name__ == \"__main__\":\n    import uvicorn  # type: ignore\n\n    uvicorn.run(app)\n</code></pre> docs_source_code/introduction/how_to_use_field/tornado_with_raw_return_demo.py<pre><code>from pydantic import ValidationError\nfrom tornado.ioloop import IOLoop\nfrom tornado.web import Application, RequestHandler\n\nfrom pait import field\nfrom pait.app.tornado import pait\nfrom pait.exceptions import TipException\nfrom pait.openapi.doc_route import AddDocRoute\n\n\nclass _Handler(RequestHandler):\n    def _handle_request_exception(self, exc: BaseException) -&gt; None:\n        if isinstance(exc, TipException):\n            exc = exc.exc\n\n        if isinstance(exc, ValidationError):\n            self.write({\"data\": exc.errors()})\n        else:\n            self.write({\"data\": str(exc)})\n        self.finish()\n\n\nclass DemoHandler(_Handler):\n    @pait()\n    async def post(\n        self,\n        demo_value: dict = field.Json.i(raw_return=True),\n        a: str = field.Json.i(),\n    ) -&gt; None:\n        self.write({\"data\": demo_value, \"a\": a})\n\n\napp: Application = Application([(r\"/api/demo\", DemoHandler)])\nAddDocRoute(app)\n\n\nif __name__ == \"__main__\":\n    app.listen(8000)\n    IOLoop.instance().start()\n</code></pre> <p>Run the code and call the <code>curl</code> command and can find that the results are as expected:</p> curl \"http://127.0.0.1:8000/api/demo\" \\   -X POST -d '{\"a\": \"1\", \"b\": \"2\"}' \\   --header \"Content-Type: application/json\"{\"demo_value\":{\"a\":\"1\",\"b\":\"2\"},\"a\":\"1\"}"},{"location":"1_2_how_to_use_field/#28custom-query-cannot-find-value-exception","title":"2.8.Custom query cannot find value exception","text":"<p>Under normal circumstances, if there is no data required by <code>Pait</code> in the request object, <code>Pait</code> will throw a <code>Not Found Value Exception</code> exception. In addition, <code>Pait</code> also supports developers to customize exception handling through <code>not_value_exception_func</code>.</p> <p>For example, the route function in the code below has two variables. The first variable <code>demo_value1</code> does not have any <code>Field</code> attributes set. The second variable <code>demo_value2</code> sets the <code>not_value_exception_func</code> attribute to <code>lambda param: RuntimeError(f\"not found {param.name} data\")</code>:</p> FlaskStarletteSanicTornado docs_source_code/introduction/how_to_use_field/flask_with_not_found_exc_demo.py<pre><code>from flask import Flask, Response, jsonify\nfrom pydantic import ValidationError\n\nfrom pait import field\nfrom pait.app.flask import pait\nfrom pait.exceptions import TipException\n\n\ndef api_exception(exc: Exception) -&gt; Response:\n    if isinstance(exc, TipException):\n        exc = exc.exc\n    if isinstance(exc, ValidationError):\n        return jsonify({\"data\": exc.errors()})\n    return jsonify({\"data\": str(exc)})\n\n\n@pait()\ndef demo(\n    demo_value1: str = field.Query.i(),\n    demo_value2: str = field.Query.i(\n        not_value_exception_func=lambda param: RuntimeError(f\"not found {param.name} data\")\n    ),\n) -&gt; dict:\n    return {\"data\": {\"demo_value1\": demo_value1, \"demo_value2\": demo_value2}}\n\n\napp = Flask(\"demo\")\napp.add_url_rule(\"/api/demo\", view_func=demo, methods=[\"GET\"])\napp.errorhandler(Exception)(api_exception)\n\n\nif __name__ == \"__main__\":\n    app.run(port=8000)\n</code></pre> docs_source_code/introduction/how_to_use_field/starlette_with_not_found_exc_demo.py<pre><code>from pydantic import ValidationError\nfrom starlette.applications import Starlette\nfrom starlette.requests import Request\nfrom starlette.responses import JSONResponse\nfrom starlette.routing import Route\n\nfrom pait import field\nfrom pait.app.starlette import pait\nfrom pait.exceptions import TipException\n\n\nasync def api_exception(request: Request, exc: Exception) -&gt; JSONResponse:\n    if isinstance(exc, TipException):\n        exc = exc.exc\n    if isinstance(exc, ValidationError):\n        return JSONResponse({\"data\": exc.errors()})\n    return JSONResponse({\"data\": str(exc)})\n\n\n@pait()\nasync def demo(\n    demo_value1: str = field.Query.i(),\n    demo_value2: str = field.Query.i(\n        not_value_exception_func=lambda param: RuntimeError(f\"not found {param.name} data\")\n    ),\n) -&gt; JSONResponse:\n    return JSONResponse({\"data\": {\"demo_value1\": demo_value1, \"demo_value2\": demo_value2}})\n\n\napp = Starlette(\n    routes=[\n        Route(\"/api/demo\", demo, methods=[\"GET\"]),\n    ]\n)\napp.add_exception_handler(Exception, api_exception)\n\n\nif __name__ == \"__main__\":\n    import uvicorn\n\n    uvicorn.run(app)\n</code></pre> docs_source_code/introduction/how_to_use_field/sanic_with_not_found_exc_demo.py<pre><code>from pydantic import ValidationError\nfrom sanic import HTTPResponse, Request, Sanic, json\n\nfrom pait import field\nfrom pait.app.sanic import pait\nfrom pait.exceptions import TipException\n\n\nasync def api_exception(request: Request, exc: Exception) -&gt; HTTPResponse:\n    if isinstance(exc, TipException):\n        exc = exc.exc\n    if isinstance(exc, ValidationError):\n        return json({\"data\": exc.errors()})\n    return json({\"data\": str(exc)})\n\n\n@pait()\nasync def demo(\n    demo_value1: str = field.Query.i(),\n    demo_value2: str = field.Query.i(\n        not_value_exception_func=lambda param: RuntimeError(f\"not found {param.name} data\")\n    ),\n) -&gt; HTTPResponse:\n    return json({\"data\": {\"demo_value1\": demo_value1, \"demo_value2\": demo_value2}})\n\n\napp = Sanic(\"demo\")\napp.add_route(demo, \"/api/demo\", methods={\"GET\"})\napp.exception(Exception)(api_exception)\n\n\nif __name__ == \"__main__\":\n    import uvicorn\n\n    uvicorn.run(app)\n</code></pre> docs_source_code/introduction/how_to_use_field/tornado_with_not_found_exc_demo.py<pre><code>from pydantic import ValidationError\nfrom tornado.ioloop import IOLoop\nfrom tornado.web import Application, RequestHandler\n\nfrom pait import field\nfrom pait.app.tornado import pait\nfrom pait.exceptions import TipException\nfrom pait.openapi.doc_route import AddDocRoute\n\n\nclass _Handler(RequestHandler):\n    def _handle_request_exception(self, exc: BaseException) -&gt; None:\n        if isinstance(exc, TipException):\n            exc = exc.exc\n\n        if isinstance(exc, ValidationError):\n            self.write({\"data\": exc.errors()})\n        else:\n            self.write({\"data\": str(exc)})\n        self.finish()\n\n\nclass DemoHandler(_Handler):\n    @pait()\n    async def get(\n        self,\n        demo_value1: str = field.Query.i(),\n        demo_value2: str = field.Query.i(\n            not_value_exception_func=lambda param: RuntimeError(f\"not found {param.name} data\")\n        ),\n    ) -&gt; None:\n        self.write({\"data\": {\"demo_value1\": demo_value1, \"demo_value2\": demo_value2}})\n\n\napp: Application = Application([(r\"/api/demo\", DemoHandler)])\nAddDocRoute(app)\n\n\nif __name__ == \"__main__\":\n    app.listen(8000)\n    IOLoop.instance().start()\n</code></pre> <p>Then run the code and execute the following <code>curl</code> command in the terminal:</p> curl \"http://127.0.0.1:8000/api/demo?demo_value1=1&amp;demo_value2=2\"{\"data\": {\"demo_value1\": \"1\", \"demo_value2\": \"2\"}}curl \"http://127.0.0.1:8000/api/demo?demo_value2=2\"{\"data\": \"Can not found demo_value1 value\"}curl \"http://127.0.0.1:8000/api/demo?demo_value1=1\"{\"data\":\"not found demo_value2 data\"} <p>Through the output results, can see that the responses to the missing value of <code>demo_value1</code> and the missing value of <code>demo_value2</code> are different. The missing value exception message of <code>demo_value2</code> is thrown by <code>lambda param: RuntimeError(f\"not found {param.name} data\")</code>.</p>"},{"location":"1_2_how_to_use_field/#28other-feature","title":"2.8.Other Feature","text":"<p>In addition to the above feature, <code>Pait</code> also has other feature, which can be found in the corresponding module documentation:</p> Attribute document description links OpenAPI support OpenAPI's Link media_type OpenAPI OpenAPI Schememedia type\u3002 openapi_serialization OpenAPI Specify the serialization method of OpenAPI Schema. example OpenAPI Example values for documentation, mock requests and responses. values support variables and callable functions such as <code>datetime.datetim.now</code>, it is recommended to use faker used together. description OpenAPI OpenAPI parameter description openapi_include OpenAPI Defines whether this field needs to be processed by OpenAPI. The default is True. extra_param_list Plugin The extra parameter list of the plugin. The default is None."},{"location":"1_3_how_to_use_type/","title":"How to use Type","text":"<p>The type of the variable - <code>Type</code> is used to indicate the final type of the variable value. By customizing <code>Type</code>, can expand the verification rules of the variable, as shown in the following example code: <pre><code>from pait.app.any import pait\nfrom pait import field\n\n@pait()\ndef demo(\n    a: str = field.Body.i(),\n    b: int = field.Body.i(),\n) -&gt; dict:\n    return {\"a\": a, \"b\": b}\n</code></pre> When the code is run, <code>Pait</code> will internally convert the function signature into the following <code>Pydantic.BaseModel</code>: <pre><code>from pydantic import BaseModel, Field\n\nclass Demo(BaseModel):\n    a: str = Field()\n    b: int = Field()\n</code></pre></p> <p>Therefore, the <code>Type</code> in the route function can become very flexible. Can use <code>Type</code> like Pydantic Field Types. It is also possible to use some of the features of <code>Pait</code> by writing a <code>Type</code> that conforms to the <code>Pait</code> specification.</p>"},{"location":"1_3_how_to_use_type/#1the-value-of-type-is-pydanticbasemodel","title":"1.The value of Type is Pydantic.BaseModel","text":"<p>After a period of development, will find that some route function parameters can be reused. In this case, can use the scheme where the value of <code>Type</code> is <code>Pydantic.BaseModel</code> to convert the parameters of the route function into <code>pydantic.Basemodel</code>.</p> <p>The following sample code, in the first highlighted code there is a class called <code>DemoModel</code>, it has <code>uid</code>, <code>name</code> and <code>age</code> three attributes. In addition to this, there are two different route functions <code>demo</code> and <code>demo1</code> in the code. The <code>demo</code> takes all the values from the Url Path and passes them to the <code>DemoModel</code> for validation before returning the data generated by the <code>.dict</code> method. While <code>demo1</code> is very similar to the route function <code>demo</code>, but the source of the data is changed from Url Path to Json Body.</p> FlaskStarletteSanicTornado docs_source_code/introduction/how_to_use_type/flask_with_model_demo.py<pre><code>from flask import Flask, Response, jsonify\nfrom pydantic import BaseModel, Field\n\nfrom pait import _pydanitc_adapter, field\nfrom pait.app.flask import pait\n\nif _pydanitc_adapter.is_v1:\n\n    class DemoModel(BaseModel):\n        uid: str = Field(max_length=6, min_length=6, regex=\"^u\")\n        name: str = Field(min_length=4, max_length=10)\n        age: int = Field(ge=0, le=100)\n\nelse:\n\n    class DemoModel(BaseModel):  # type: ignore\n        uid: str = Field(max_length=6, min_length=6, pattern=\"^u\")\n        name: str = Field(min_length=4, max_length=10)\n        age: int = Field(ge=0, le=100)\n\n\n@pait()\ndef demo(demo_model: DemoModel = field.Query.i(raw_return=True)) -&gt; Response:\n    return jsonify(demo_model.dict())\n\n\n@pait()\ndef demo1(demo_model: DemoModel = field.Json.i(raw_return=True)) -&gt; Response:\n    return jsonify(demo_model.dict())\n\n\napp = Flask(\"demo\")\napp.add_url_rule(\"/api/demo\", \"demo\", demo, methods=[\"GET\"])\napp.add_url_rule(\"/api/demo1\", \"demo1\", demo1, methods=[\"POST\"])\n\n\nif __name__ == \"__main__\":\n    app.run(port=8000)\n</code></pre> docs_source_code/introduction/how_to_use_type/starlette_with_model_demo.py<pre><code>from pydantic import BaseModel, Field\nfrom starlette.applications import Starlette\nfrom starlette.responses import JSONResponse\nfrom starlette.routing import Route\n\nfrom pait import _pydanitc_adapter, field\nfrom pait.app.starlette import pait\n\nif _pydanitc_adapter.is_v1:\n\n    class DemoModel(BaseModel):\n        uid: str = Field(max_length=6, min_length=6, regex=\"^u\")\n        name: str = Field(min_length=4, max_length=10)\n        age: int = Field(ge=0, le=100)\n\nelse:\n\n    class DemoModel(BaseModel):  # type: ignore\n        uid: str = Field(max_length=6, min_length=6, pattern=\"^u\")\n        name: str = Field(min_length=4, max_length=10)\n        age: int = Field(ge=0, le=100)\n\n\n@pait()\nasync def demo(demo_model: DemoModel = field.Query.i(raw_return=True)) -&gt; JSONResponse:\n    return JSONResponse(demo_model.dict())\n\n\n@pait()\nasync def demo1(demo_model: DemoModel = field.Json.i(raw_return=True)) -&gt; JSONResponse:\n    return JSONResponse(demo_model.dict())\n\n\napp = Starlette(routes=[Route(\"/api/demo\", demo, methods=[\"GET\"]), Route(\"/api/demo1\", demo1, methods=[\"POST\"])])\n\n\nif __name__ == \"__main__\":\n    import uvicorn\n\n    uvicorn.run(app)\n</code></pre> docs_source_code/introduction/how_to_use_type/sanic_with_model_demo.py<pre><code>from pydantic import BaseModel, Field\nfrom sanic import Sanic, json, response\n\nfrom pait import _pydanitc_adapter, field\nfrom pait.app.sanic import pait\n\nif _pydanitc_adapter.is_v1:\n\n    class DemoModel(BaseModel):\n        uid: str = Field(max_length=6, min_length=6, regex=\"^u\")\n        name: str = Field(min_length=4, max_length=10)\n        age: int = Field(ge=0, le=100)\n\nelse:\n\n    class DemoModel(BaseModel):  # type: ignore\n        uid: str = Field(max_length=6, min_length=6, pattern=\"^u\")\n        name: str = Field(min_length=4, max_length=10)\n        age: int = Field(ge=0, le=100)\n\n\n@pait()\nasync def demo(demo_model: DemoModel = field.Query.i(raw_return=True)) -&gt; response.HTTPResponse:\n    return json(demo_model.dict())\n\n\n@pait()\nasync def demo1(demo_model: DemoModel = field.Json.i(raw_return=True)) -&gt; response.HTTPResponse:\n    return json(demo_model.dict())\n\n\napp = Sanic(name=\"demo\")\napp.add_route(demo, \"/api/demo\", methods=[\"GET\"])\napp.add_route(demo1, \"/api/demo1\", methods=[\"POST\"])\n\n\nif __name__ == \"__main__\":\n    import uvicorn\n\n    uvicorn.run(app)\n</code></pre> docs_source_code/introduction/how_to_use_type/tornado_with_model_demo.py<pre><code>from pydantic import BaseModel, Field\nfrom tornado.ioloop import IOLoop\nfrom tornado.web import Application, RequestHandler\n\nfrom pait import _pydanitc_adapter, field\nfrom pait.app.tornado import pait\n\nif _pydanitc_adapter.is_v1:\n\n    class DemoModel(BaseModel):\n        uid: str = Field(max_length=6, min_length=6, regex=\"^u\")\n        name: str = Field(min_length=4, max_length=10)\n        age: int = Field(ge=0, le=100)\n\nelse:\n\n    class DemoModel(BaseModel):  # type: ignore\n        uid: str = Field(max_length=6, min_length=6, pattern=\"^u\")\n        name: str = Field(min_length=4, max_length=10)\n        age: int = Field(ge=0, le=100)\n\n\nclass DemoHandler(RequestHandler):\n    @pait()\n    def get(self, demo_model: DemoModel = field.Query.i(raw_return=True)) -&gt; None:\n        self.write(demo_model.dict())\n\n\nclass Demo1Handler(RequestHandler):\n    @pait()\n    def post(self, demo_model: DemoModel = field.Json.i(raw_return=True)) -&gt; None:\n        self.write(demo_model.dict())\n\n\napp: Application = Application([(r\"/api/demo\", DemoHandler), (r\"/api/demo1\", Demo1Handler)])\n\n\nif __name__ == \"__main__\":\n    app.listen(8000)\n    IOLoop.instance().start()\n</code></pre> <p>Note</p> <p>If the <code>raw_return</code> of the <code>Field</code> object is not True, <code>Pait</code> will obtain the value from the requested resource with the Key as <code>demo_model</code></p> <p>Next run the code and call the <code>curl</code> command: <pre><code>\u279c  ~ curl \"http://127.0.0.1:8000/api/demo?uid=u12345&amp;name=so1n&amp;age=10\"\n{\"uid\":\"u12345\",\"name\":\"so1n\",\"age\":10}\n\u279c  ~ curl \"http://127.0.0.1:8000/api/demo1\" -X POST -d '{\"uid\": \"u12345\", \"name\": \"so1n\", \"age\": 10}' --header \"Content-Type: application/json\"\n{\"uid\":\"u12345\",\"name\":\"so1n\",\"age\":10}\n</code></pre></p> <p>The output shows that both route functions work fine, but in this case all the fields of <code>BaseModel</code> can only use the same <code>Field</code> type, so another approach can be taken.</p>"},{"location":"1_3_how_to_use_type/#2the-value-of-type-is-the-special-pydanticbasemodel","title":"2.The value of Type is the special Pydantic.BaseModel","text":"<p>The <code>Field</code> object of <code>Pait</code> is a <code>pydantic.FieldInfo</code> object that carries the resource identifier, so it can be used in <code>pydantic.BaseModel</code>. In this way the <code>DemoModel</code> object mentioned earlier can be rewritten as follows. <pre><code>from pait import field\n\nfrom pydantic import BaseModel\n\nclass DemoModel(BaseModel):\n    uid: str = field.Query.i(max_length=6, min_length=6, regex=\"^u\")\n    name: str = field.Body.i(min_length=4, max_length=10)\n    age: int = field.Header.i(ge=0, le=100)\n</code></pre> can see that the <code>Field</code> object is different for each property of <code>DemoModel</code>, but in order for <code>Pait</code> to load <code>DemoModel</code> correctly the form of the parameters filled in needs to be changed from <code>&lt;name&gt;:&lt;type&gt;=&lt;default&gt;</code> to <code>&lt;name&gt;:&lt;type&gt;</code>. as follows: <pre><code>@pait()\ndef demo(demo_model: DemoModel) -&gt; None:\n    pass\n</code></pre></p>"},{"location":"1_3_how_to_use_type/#21defaultfield","title":"2.1.DefaultField","text":"<p>In addition, can also use the <code>DefaultField</code> of <code>Pait</code>, which can automatically replace the <code>Field</code> of each attribute in <code>pydantic.BaseModel</code> according to the <code>Field</code> defined by the route function. The following is still the same Ordinary <code>DemoModel</code>: <pre><code>from pydantic import BaseModel, Field\n\nclass DemoModel(BaseModel):\n    uid: str = Field(max_length=6, min_length=6, regex=\"^u\")\n    name: str = Field(min_length=4, max_length=10)\n    age: int = Field(ge=0, le=100)\n</code></pre> Then, The <code>DefaultField</code> for the <code>demo</code> route is specified as <code>Query</code> and the <code>DefaultField</code> for the <code>demo1</code> route is specified as <code>Body</code> via the <code>default_field_class</code> attribute in the <code>pait</code> decorator: <pre><code>from pait import field\nfrom pait.app.any import pait\n\n@pait(default_field_class=field.Query)\ndef demo(demo_model: DemoModel) -&gt; None:\n    pass\n\n@pait(default_field_class=field.Body)\ndef demo1(demo_model: DemoModel) -&gt; None:\n    pass\n</code></pre> In this way, it is possible to use the same <code>DemoModel</code> in a route function that uses a different request resource, the complete code is as follows:</p> FlaskStarletteSanicTornado docs_source_code/introduction/how_to_use_type/flask_with_pait_model_demo.py<pre><code>from uuid import uuid4\n\nfrom flask import Flask, Response, jsonify\nfrom pydantic import BaseModel, Field\n\nfrom pait import _pydanitc_adapter, field\nfrom pait.app.flask import pait\n\nif _pydanitc_adapter.is_v1:\n\n    class DemoModel(BaseModel):\n        uid: str = Field(..., max_length=6, min_length=6, regex=\"^u\")\n        name: str = Field(..., min_length=4, max_length=10)\n        age: int = Field(..., ge=0, le=100)\n\n        request_id: str = field.Header.i(default_factory=lambda: str(uuid4()))\n\nelse:\n\n    class DemoModel(BaseModel):  # type: ignore\n        uid: str = Field(..., max_length=6, min_length=6, pattern=\"^u\")\n        name: str = Field(..., min_length=4, max_length=10)\n        age: int = Field(..., ge=0, le=100)\n\n        request_id: str = field.Header.i(default_factory=lambda: str(uuid4()))\n\n\n@pait(default_field_class=field.Query)\ndef demo(demo_model: DemoModel) -&gt; Response:\n    return jsonify(demo_model.dict())\n\n\n@pait(default_field_class=field.Body)\ndef demo1(demo_model: DemoModel) -&gt; Response:\n    return jsonify(demo_model.dict())\n\n\napp = Flask(\"demo\")\napp.add_url_rule(\"/api/demo\", \"demo\", demo, methods=[\"GET\"])\napp.add_url_rule(\"/api/demo1\", \"demo1\", demo1, methods=[\"POST\"])\n\n\nif __name__ == \"__main__\":\n    app.run(port=8000)\n</code></pre> docs_source_code/introduction/how_to_use_type/starlette_with_pait_model_demo.py<pre><code>from uuid import uuid4\n\nfrom pydantic import BaseModel, Field\nfrom starlette.applications import Starlette\nfrom starlette.responses import JSONResponse\nfrom starlette.routing import Route\n\nfrom pait import _pydanitc_adapter, field\nfrom pait.app.starlette import pait\n\nif _pydanitc_adapter.is_v1:\n\n    class DemoModel(BaseModel):\n        uid: str = Field(..., max_length=6, min_length=6, regex=\"^u\")\n        name: str = Field(..., min_length=4, max_length=10)\n        age: int = Field(..., ge=0, le=100)\n\n        request_id: str = field.Header.i(default_factory=lambda: str(uuid4()))\n\nelse:\n\n    class DemoModel(BaseModel):  # type: ignore\n        uid: str = Field(..., max_length=6, min_length=6, pattern=\"^u\")\n        name: str = Field(..., min_length=4, max_length=10)\n        age: int = Field(..., ge=0, le=100)\n\n        request_id: str = field.Header.i(default_factory=lambda: str(uuid4()))\n\n\n@pait(default_field_class=field.Query)\nasync def demo(demo_model: DemoModel) -&gt; JSONResponse:\n    return JSONResponse(demo_model.dict())\n\n\n@pait(default_field_class=field.Body)\nasync def demo1(demo_model: DemoModel) -&gt; JSONResponse:\n    return JSONResponse(demo_model.dict())\n\n\napp = Starlette(routes=[Route(\"/api/demo\", demo, methods=[\"GET\"]), Route(\"/api/demo1\", demo1, methods=[\"POST\"])])\n\n\nif __name__ == \"__main__\":\n    import uvicorn\n\n    uvicorn.run(app)\n</code></pre> docs_source_code/introduction/how_to_use_type/sanic_with_pait_model_demo.py<pre><code>from uuid import uuid4\n\nfrom pydantic import BaseModel, Field\nfrom sanic import Sanic, json, response\n\nfrom pait import _pydanitc_adapter, field\nfrom pait.app.sanic import pait\n\nif _pydanitc_adapter.is_v1:\n\n    class DemoModel(BaseModel):\n        uid: str = Field(..., max_length=6, min_length=6, regex=\"^u\")\n        name: str = Field(..., min_length=4, max_length=10)\n        age: int = Field(..., ge=0, le=100)\n\n        request_id: str = field.Header.i(default_factory=lambda: str(uuid4()))\n\nelse:\n\n    class DemoModel(BaseModel):  # type: ignore\n        uid: str = Field(..., max_length=6, min_length=6, pattern=\"^u\")\n        name: str = Field(..., min_length=4, max_length=10)\n        age: int = Field(..., ge=0, le=100)\n\n        request_id: str = field.Header.i(default_factory=lambda: str(uuid4()))\n\n\n@pait(default_field_class=field.Query)\nasync def demo(demo_model: DemoModel) -&gt; response.HTTPResponse:\n    return json(demo_model.dict())\n\n\n@pait(default_field_class=field.Body)\nasync def demo1(demo_model: DemoModel) -&gt; response.HTTPResponse:\n    return json(demo_model.dict())\n\n\napp = Sanic(name=\"demo\")\napp.add_route(demo, \"/api/demo\", methods=[\"GET\"])\napp.add_route(demo1, \"/api/demo1\", methods=[\"POST\"])\n\n\nif __name__ == \"__main__\":\n    import uvicorn\n\n    uvicorn.run(app)\n</code></pre> docs_source_code/introduction/how_to_use_type/tornado_with_pait_model_demo.py<pre><code>from uuid import uuid4\n\nfrom pydantic import BaseModel, Field\nfrom tornado.ioloop import IOLoop\nfrom tornado.web import Application, RequestHandler\n\nfrom pait import _pydanitc_adapter, field\nfrom pait.app.tornado import pait\n\nif _pydanitc_adapter.is_v1:\n\n    class DemoModel(BaseModel):\n        uid: str = Field(..., max_length=6, min_length=6, regex=\"^u\")\n        name: str = Field(..., min_length=4, max_length=10)\n        age: int = Field(..., ge=0, le=100)\n\n        request_id: str = field.Header.i(default_factory=lambda: str(uuid4()))\n\nelse:\n\n    class DemoModel(BaseModel):  # type: ignore\n        uid: str = Field(..., max_length=6, min_length=6, pattern=\"^u\")\n        name: str = Field(..., min_length=4, max_length=10)\n        age: int = Field(..., ge=0, le=100)\n\n        request_id: str = field.Header.i(default_factory=lambda: str(uuid4()))\n\n\nclass DemoHandler(RequestHandler):\n    @pait(default_field_class=field.Query)\n    def get(self, demo_model: DemoModel) -&gt; None:\n        self.write(demo_model.dict())\n\n\nclass Demo1Handler(RequestHandler):\n    @pait(default_field_class=field.Body)\n    def post(self, demo_model: DemoModel) -&gt; None:\n        self.write(demo_model.dict())\n\n\napp: Application = Application([(r\"/api/demo\", DemoHandler), (r\"/api/demo1\", Demo1Handler)])\n\n\nif __name__ == \"__main__\":\n    app.listen(8000)\n    IOLoop.instance().start()\n</code></pre> <p>The <code>DemoModel</code> in the code adds a property named <code>request_id</code>, which uses a <code>Field</code> object that is a <code>Header</code> object. Since the <code>Default Field</code> function will only replace <code>pydantic.FieldInfo</code>, this means that the <code>request_id</code> property will not be affected by <code>Default Field</code> during runtime, it will still get the data from the Header. Now running the code and calling the <code>curl</code> command to see the following output: <pre><code>\u279c  ~ curl \"http://127.0.0.1:8000/api/demo?uid=u12345&amp;name=so1n&amp;age=10\"\n{\"age\":10,\"name\":\"so1n\",\"request_id\":\"6a5827f7-5767-46ef-91c6-f2ae99770865\",\"uid\":\"u12345\"}\n\u279c  ~ curl \"http://127.0.0.1:8000/api/demo1\" -X POST -d '{\"uid\": \"u12345\", \"name\": \"so1n\", \"age\": 10}' --header \"Content-Type: application/json\"\n{\"age\":10,\"name\":\"so1n\",\"request_id\":\"3279944c-6de7-4270-8536-33619641f25e\",\"uid\":\"u12345\"}\n</code></pre></p> <p>Note</p> <p>Note that under normal circumstances, <code>Pait</code> processes/checks the values of each variable in the order of the variables and throws an error if it finds an illegitimate value, and doesn't process the rest of the values. However, when the value of <code>Type</code> is <code>pydantic.BaseModel</code>, <code>Pait</code> will delegate the parameter to <code>pydantic.BaseModel</code>, and <code>pydantic.BaseModel</code> will check all the values, and then throw the error.</p>"},{"location":"1_3_how_to_use_type/#3other","title":"3.Other","text":""},{"location":"1_3_how_to_use_type/#31request-obj","title":"3.1.Request Obj","text":"<p>When using <code>Pait</code>, the <code>Request</code> object is used significantly less often, so <code>Pait</code> automatically omits the <code>Request</code> object, for example, the <code>Starlette</code> framework route function code is as follows: <pre><code>from starlette.requests import Request\n\n\nasync def demo(request: Request) -&gt; None:\n    pass\n</code></pre> After using <code>Pait</code> in the route function, the code is as follows: <pre><code>from pait.app.starlette import pait\n\n\n@pait()\nasync def demo():\n    pass\n</code></pre></p> <p>Note</p> <p>Note\uff1aThe <code>Sanic</code> framework requires that route functions must have at least one parameter.</p> <p>If need to use the <code>Request</code> object in the route function, need to define the route function parameters in the form of <code>&lt;var name&gt;: &lt;RequestType&gt;</code> so that <code>pait</code> can correctly inject the <code>Request</code> object into the corresponding variable. For example:</p> FlaskStarletteSanicTornado docs_source_code/introduction/how_to_use_type/flask_with_request_demo.py<pre><code>from flask import Flask, Request, Response, jsonify\n\nfrom pait.app.flask import pait\n\n\n@pait()\ndef demo(req: Request) -&gt; Response:\n    return jsonify({\"url\": req.path, \"method\": req.method})\n\n\napp = Flask(\"demo\")\napp.add_url_rule(\"/api/demo\", \"demo\", demo, methods=[\"GET\"])\n\n\nif __name__ == \"__main__\":\n    app.run(port=8000)\n</code></pre> docs_source_code/introduction/how_to_use_type/starlette_with_request_demo.py<pre><code>from starlette.applications import Starlette\nfrom starlette.requests import Request\nfrom starlette.responses import JSONResponse\nfrom starlette.routing import Route\n\nfrom pait.app.starlette import pait\n\n\n@pait()\nasync def demo(req: Request) -&gt; JSONResponse:\n    return JSONResponse({\"url\": str(req.url.path), \"method\": req.method})\n\n\napp = Starlette(\n    routes=[\n        Route(\"/api/demo\", demo, methods=[\"GET\"]),\n    ]\n)\n\n\nif __name__ == \"__main__\":\n    import uvicorn\n\n    uvicorn.run(app)\n</code></pre> docs_source_code/introduction/how_to_use_type/sanic_with_request_demo.py<pre><code>from sanic import Request, Sanic, json, response\n\nfrom pait.app.sanic import pait\n\n\n@pait()\nasync def demo(req: Request) -&gt; response.HTTPResponse:\n    return json({\"url\": req.path, \"method\": req.method})\n\n\napp = Sanic(name=\"demo\")\napp.add_route(demo, \"/api/demo\", methods=[\"GET\"])\n\n\nif __name__ == \"__main__\":\n    import uvicorn\n\n    uvicorn.run(app)\n</code></pre> docs_source_code/introduction/how_to_use_type/tornado_with_request_demo.py<pre><code>from tornado.httputil import HTTPServerRequest\nfrom tornado.ioloop import IOLoop\nfrom tornado.web import Application, RequestHandler\n\nfrom pait.app.tornado import pait\n\n\nclass DemoHandler(RequestHandler):\n    @pait()\n    def get(self, req: HTTPServerRequest) -&gt; None:\n        self.write({\"url\": req.uri, \"method\": req.method})\n\n\napp: Application = Application(\n    [\n        (r\"/api/demo\", DemoHandler),\n    ]\n)\n\n\nif __name__ == \"__main__\":\n    app.listen(8000)\n    IOLoop.instance().start()\n</code></pre> <p>Run the code and use the <code>curl</code> command to see the following output\uff1a <pre><code>curl \"http://127.0.0.1:8000/api/demo\"\n{\"url\": \"http://127.0.0.1:8000/api/demo\", \"method\": \"GET\"}\n</code></pre></p>"},{"location":"1_3_how_to_use_type/#32how-to-customize-a-type-that-meets-pydantic-requirements-and-has-verification-function","title":"3.2.How to customize a Type that meets Pydantic requirements and has verification function","text":"<p>As mentioned earlier, the <code>Type</code> used in a <code>Pait</code> decorated route function does the same thing as the <code>Type</code> of Pydantic, which means that the <code>Type</code> can be used to extend the checking rules to make up for the lack of a <code>Field</code> object, For example, in a business where users may be located in different countries, it is common to use timestamps to pass the time in order to prevent data errors caused by different time zones, as follows:</p> FlaskStarletteSanicTornado docs_source_code/introduction/how_to_use_type/flask_with_datetime_demo.py<pre><code>import datetime\n\nfrom flask import Flask, Response, jsonify\n\nfrom pait import field\nfrom pait.app.flask import pait\n\n\n@pait()\ndef demo(timestamp: datetime.datetime = field.Query.i()) -&gt; Response:\n    return jsonify({\"time\": timestamp.isoformat()})\n\n\napp = Flask(\"demo\")\napp.add_url_rule(\"/api/demo\", \"demo\", demo, methods=[\"GET\"])\n\n\nif __name__ == \"__main__\":\n    app.run(port=8000)\n</code></pre> docs_source_code/introduction/how_to_use_type/starlette_with_datetime_demo.py<pre><code>import datetime\n\nfrom starlette.applications import Starlette\nfrom starlette.responses import JSONResponse\nfrom starlette.routing import Route\n\nfrom pait import field\nfrom pait.app.starlette import pait\n\n\n@pait()\nasync def demo(timestamp: datetime.datetime = field.Query.i()) -&gt; JSONResponse:\n    return JSONResponse({\"time\": timestamp.isoformat()})\n\n\napp = Starlette(\n    routes=[\n        Route(\"/api/demo\", demo, methods=[\"GET\"]),\n    ]\n)\n\n\nif __name__ == \"__main__\":\n    import uvicorn\n\n    uvicorn.run(app)\n</code></pre> docs_source_code/introduction/how_to_use_type/sanic_with_datetime_demo.py<pre><code>import datetime\n\nfrom sanic import Sanic, json, response\n\nfrom pait import field\nfrom pait.app.sanic import pait\n\n\n@pait()\nasync def demo(timestamp: datetime.datetime = field.Query.i()) -&gt; response.HTTPResponse:\n    return json({\"time\": timestamp.isoformat()})\n\n\napp = Sanic(name=\"demo\")\napp.add_route(demo, \"/api/demo\", methods=[\"GET\"])\n\n\nif __name__ == \"__main__\":\n    import uvicorn\n\n    uvicorn.run(app)\n</code></pre> docs_source_code/introduction/how_to_use_type/tornado_with_datetime_demo.py<pre><code>import datetime\n\nfrom tornado.ioloop import IOLoop\nfrom tornado.web import Application, RequestHandler\n\nfrom pait import field\nfrom pait.app.tornado import pait\n\n\nclass DemoHandler(RequestHandler):\n    @pait()\n    def get(self, timestamp: datetime.datetime = field.Query.i()) -&gt; None:\n        self.write({\"time\": timestamp.isoformat()})\n\n\napp: Application = Application(\n    [\n        (r\"/api/demo\", DemoHandler),\n    ]\n)\n\n\nif __name__ == \"__main__\":\n    app.listen(8000)\n    IOLoop.instance().start()\n</code></pre> <p>However, after running the code and calling the following <code>curl</code> command, can find that <code>Pydantic</code> automatically converts the timestamp to datetime type and the time zone is UTC: <pre><code>\u279c  ~ curl \"http://127.0.0.1:8000/api/demo?timestamp=1600000000\"\n{\"time\":\"2020-09-13T12:26:40+00:00\"}\n</code></pre> This processing is fine, but assuming that the server for this business is located in some non-UTC and both the database and the program's are dependent on the time zone of the machine, the It would be necessary to perform another time zone conversion each time the data is fetched. This can be solved by writing a <code>Type</code> class that conforms to the <code>Pydantic</code> checksum rule, code show as below:</p> Pydantic V1Pydantic V2 <pre><code>import datetime\nfrom typing import Callable, Generator, Union\n\n\nclass UnixDatetime(datetime.datetime):\n\n    @classmethod\n    def __get_validators__(cls) -&gt; Generator[Callable, None, None]:\n        yield cls.validate\n\n    @classmethod\n    def validate(cls, v: Union[int, str]) -&gt; datetime.datetime:\n        if isinstance(v, str):\n            v = int(v)\n        return datetime.datetime.fromtimestamp(v)\n</code></pre> <pre><code>from pydantic import BeforeValidator\nfrom typing import Union\nfrom typing_extensions import Annotated\nfrom datetime import datetime\n\n\ndef validate(v: Union[int, str]) -&gt; datetime:\n    if isinstance(v, str):\n        v = int(v)\n    return datetime.fromtimestamp(v)\n\nUnixDatetime = Annotated[datetime, BeforeValidator(validate)]\n</code></pre> <p>through the sample code can be seen due to <code>Pydantic</code> version of the different, <code>Type</code> implementation is not the same, but their logic is the same, write the completion of the <code>Type</code> can be applied to the code:</p> FlaskStarletteSanicTornado docs_source_code/introduction/how_to_use_type/flask_with_unix_datetime_demo.py<pre><code>import datetime\nfrom typing import Callable, Generator, Union\n\nfrom flask import Flask, Response, jsonify\n\nfrom pait import field\nfrom pait._pydanitc_adapter import is_v1\nfrom pait.app.flask import pait\n\nif is_v1:\n\n    class UnixDatetime(datetime.datetime):\n        @classmethod\n        def __get_validators__(cls) -&gt; Generator[Callable, None, None]:\n            yield cls.validate\n\n        @classmethod\n        def validate(cls, v: Union[int, str]) -&gt; datetime.datetime:\n            if isinstance(v, str):\n                v = int(v)\n            return datetime.datetime.fromtimestamp(v)\n\nelse:\n    from pydantic import BeforeValidator\n    from typing_extensions import Annotated\n\n    def validate(v: Union[int, str]) -&gt; datetime.datetime:\n        if isinstance(v, str):\n            v = int(v)\n        return datetime.datetime.fromtimestamp(v)\n\n    UnixDatetime = Annotated[datetime.datetime, BeforeValidator(validate)]  # type: ignore\n\n\n@pait()\ndef demo(timestamp: UnixDatetime = field.Query.i()) -&gt; Response:\n    return jsonify({\"time\": timestamp.isoformat()})\n\n\napp = Flask(\"demo\")\napp.add_url_rule(\"/api/demo\", \"demo\", demo, methods=[\"GET\"])\n\n\nif __name__ == \"__main__\":\n    app.run(port=8000)\n</code></pre> docs_source_code/introduction/how_to_use_type/starlette_with_unix_datetime_demo.py<pre><code>import datetime\nfrom typing import Callable, Generator, Union\n\nfrom starlette.applications import Starlette\nfrom starlette.responses import JSONResponse\nfrom starlette.routing import Route\n\nfrom pait import field\nfrom pait._pydanitc_adapter import is_v1\nfrom pait.app.starlette import pait\n\nif is_v1:\n\n    class UnixDatetime(datetime.datetime):\n        @classmethod\n        def __get_validators__(cls) -&gt; Generator[Callable, None, None]:\n            yield cls.validate\n\n        @classmethod\n        def validate(cls, v: Union[int, str]) -&gt; datetime.datetime:\n            if isinstance(v, str):\n                v = int(v)\n            return datetime.datetime.fromtimestamp(v)\n\nelse:\n    from pydantic import BeforeValidator\n    from typing_extensions import Annotated\n\n    def validate(v: Union[int, str]) -&gt; datetime.datetime:\n        if isinstance(v, str):\n            v = int(v)\n        return datetime.datetime.fromtimestamp(v)\n\n    UnixDatetime = Annotated[datetime.datetime, BeforeValidator(validate)]  # type: ignore\n\n\n@pait()\nasync def demo(timestamp: UnixDatetime = field.Query.i()) -&gt; JSONResponse:\n    return JSONResponse({\"time\": timestamp.isoformat()})\n\n\napp = Starlette(\n    routes=[\n        Route(\"/api/demo\", demo, methods=[\"GET\"]),\n    ]\n)\n\n\nif __name__ == \"__main__\":\n    import uvicorn\n\n    uvicorn.run(app)\n</code></pre> docs_source_code/introduction/how_to_use_type/sanic_with_unix_datetime_demo.py<pre><code>import datetime\nfrom typing import Callable, Generator, Union\n\nfrom sanic import Sanic, json, response\n\nfrom pait import field\nfrom pait._pydanitc_adapter import is_v1\nfrom pait.app.sanic import pait\n\nif is_v1:\n\n    class UnixDatetime(datetime.datetime):\n        @classmethod\n        def __get_validators__(cls) -&gt; Generator[Callable, None, None]:\n            yield cls.validate\n\n        @classmethod\n        def validate(cls, v: Union[int, str]) -&gt; datetime.datetime:\n            if isinstance(v, str):\n                v = int(v)\n            return datetime.datetime.fromtimestamp(v)\n\nelse:\n    from pydantic import BeforeValidator\n    from typing_extensions import Annotated\n\n    def validate(v: Union[int, str]) -&gt; datetime.datetime:\n        if isinstance(v, str):\n            v = int(v)\n        return datetime.datetime.fromtimestamp(v)\n\n    UnixDatetime = Annotated[datetime.datetime, BeforeValidator(validate)]  # type: ignore\n\n\n@pait()\nasync def demo(timestamp: UnixDatetime = field.Query.i()) -&gt; response.HTTPResponse:\n    return json({\"time\": timestamp.isoformat()})\n\n\napp = Sanic(name=\"demo\")\napp.add_route(demo, \"/api/demo\", methods=[\"GET\"])\n\n\nif __name__ == \"__main__\":\n    import uvicorn\n\n    uvicorn.run(app)\n</code></pre> docs_source_code/introduction/how_to_use_type/tornado_with_unix_datetime_demo.py<pre><code>import datetime\nfrom typing import Callable, Generator, Union\n\nfrom tornado.ioloop import IOLoop\nfrom tornado.web import Application, RequestHandler\n\nfrom pait import field\nfrom pait._pydanitc_adapter import is_v1\nfrom pait.app.tornado import pait\n\nif is_v1:\n\n    class UnixDatetime(datetime.datetime):\n        @classmethod\n        def __get_validators__(cls) -&gt; Generator[Callable, None, None]:\n            yield cls.validate\n\n        @classmethod\n        def validate(cls, v: Union[int, str]) -&gt; datetime.datetime:\n            if isinstance(v, str):\n                v = int(v)\n            return datetime.datetime.fromtimestamp(v)\n\nelse:\n    from pydantic import BeforeValidator\n    from typing_extensions import Annotated\n\n    def validate(v: Union[int, str]) -&gt; datetime.datetime:\n        if isinstance(v, str):\n            v = int(v)\n        return datetime.datetime.fromtimestamp(v)\n\n    UnixDatetime = Annotated[datetime.datetime, BeforeValidator(validate)]  # type: ignore\n\n\nclass DemoHandler(RequestHandler):\n    @pait()\n    def get(self, timestamp: UnixDatetime = field.Query.i()) -&gt; None:\n        self.write({\"time\": timestamp.isoformat()})\n\n\napp: Application = Application(\n    [\n        (r\"/api/demo\", DemoHandler),\n    ]\n)\n\n\nif __name__ == \"__main__\":\n    app.listen(8000)\n    IOLoop.instance().start()\n</code></pre> <p>After re-running the modified code and calling the <code>curl</code> command, can find that the returned time value no longer has the time zone: <pre><code>\u279c  ~ curl \"http://127.0.0.1:8000/api/demo?timestamp=1600000000\"\n{\"time\":\"2020-09-13T20:26:40\"}\n</code></pre></p>"},{"location":"1_4_depend/","title":"Depend","text":"<p>The <code>Field</code> objects mentioned in the previous section are all related to the request object and their role is to inject the resources specified by the request object into the route function. The <code>Depend</code> is a special <code>Field</code> object that injects functions that conform to the <code>Pait</code> rule into the route function, which can do the following:</p> <ul> <li>Share the same logic</li> <li>Implement security verification function</li> <li>Interact with other systems (such as databases).</li> </ul> <p>Note</p> <p><code>Depend</code> only does dependency injection related to the request object, and cannot complete dependency injection feture other than the request object. If you have this need, it is recommended to implement the dependency injection function through DI tools. For specific DI tools, see Awesome Dependency Injection in Python.</p>"},{"location":"1_4_depend/#1use-of-depend","title":"1.Use of Depend","text":"<p>Usually, the business system will have the function of user Token verification, this function is very consistent with the <code>Depend</code> usage scenario. In this scenario, the user carries a Token every time who accesses the system, and the server will first determine whether the Token is legal after receiving the user's request, and if it is legal, it will be released; if it is not legal, system will return an error message.</p> <p>Most users of micro-web frameworks like <code>Flask</code> will choose to use <code>Python</code> decorators to solve this problem, as follows: <pre><code>@check_token()\ndef demo_route() -&gt; None:\n    pass\n</code></pre> In some cases, additional functionality is added, such as getting the uid data based on the Token and passing it to the route function. <pre><code>@check_token()\ndef demo_route(uid: str) -&gt; None:\n    pass\n</code></pre> However, it can be seen that this implementation is more dynamic, and it can make difficult for code inspection tools to detect if there is a problem with this code. It is only possible to prevent developers from incorrectly using the <code>check_token</code> decorator if you have a good internal specification, but there's nothing it can do to completely prevent the <code>check_token</code> decorator from being used incorrectly.</p> <p>Using <code>Pait</code>'s <code>Depend</code> can solve this problem. The sample code for <code>Pait</code>'s <code>Depend</code> is as follows:</p> FlaskStarletteSanicTornado docs_source_code/introduction/depend/flask_with_depend_demo.py<pre><code>from flask import Flask, Response, jsonify\n\nfrom pait import field\nfrom pait.app.flask import pait\nfrom pait.exceptions import TipException\n\n\ndef api_exception(exc: Exception) -&gt; Response:\n    if isinstance(exc, TipException):\n        exc = exc.exc\n    return jsonify({\"data\": str(exc)})\n\n\nfake_db_dict: dict = {\"u12345\": \"so1n\"}\n\n\ndef get_user_by_token(token: str = field.Header.i()) -&gt; str:\n    if token not in fake_db_dict:\n        raise RuntimeError(f\"Can not found by token:{token}\")\n    return fake_db_dict[token]\n\n\n@pait()\ndef demo(token: str = field.Depends.i(get_user_by_token)) -&gt; dict:\n    return {\"user\": token}\n\n\napp = Flask(\"demo\")\napp.add_url_rule(\"/api/demo\", view_func=demo, methods=[\"GET\"])\napp.errorhandler(Exception)(api_exception)\n\n\nif __name__ == \"__main__\":\n    app.run(port=8000)\n</code></pre> docs_source_code/introduction/depend/starlette_with_depend_demo.py<pre><code>from starlette.applications import Starlette\nfrom starlette.requests import Request\nfrom starlette.responses import JSONResponse\nfrom starlette.routing import Route\n\nfrom pait import field\nfrom pait.app.starlette import pait\nfrom pait.exceptions import TipException\n\n\nasync def api_exception(request: Request, exc: Exception) -&gt; JSONResponse:\n    if isinstance(exc, TipException):\n        exc = exc.exc\n    return JSONResponse({\"data\": str(exc)})\n\n\nfake_db_dict: dict = {\"u12345\": \"so1n\"}\n\n\nasync def get_user_by_token(token: str = field.Header.i()) -&gt; str:\n    if token not in fake_db_dict:\n        raise RuntimeError(f\"Can not found by token:{token}\")\n    return fake_db_dict[token]\n\n\n@pait()\nasync def demo(token: str = field.Depends.i(get_user_by_token)) -&gt; JSONResponse:\n    return JSONResponse({\"user\": token})\n\n\napp = Starlette(routes=[Route(\"/api/demo\", demo, methods=[\"GET\"])])\napp.add_exception_handler(Exception, api_exception)\n\n\nif __name__ == \"__main__\":\n    import uvicorn\n\n    uvicorn.run(app)\n</code></pre> docs_source_code/introduction/depend/sanic_with_depend_demo.py<pre><code>from sanic import HTTPResponse, Request, Sanic, json\n\nfrom pait import field\nfrom pait.app.sanic import pait\nfrom pait.exceptions import TipException\n\n\nasync def api_exception(request: Request, exc: Exception) -&gt; HTTPResponse:\n    if isinstance(exc, TipException):\n        exc = exc.exc\n    return json({\"data\": str(exc)})\n\n\nfake_db_dict: dict = {\"u12345\": \"so1n\"}\n\n\nasync def get_user_by_token(token: str = field.Header.i()) -&gt; str:\n    if token not in fake_db_dict:\n        raise RuntimeError(f\"Can not found by token:{token}\")\n    return fake_db_dict[token]\n\n\n@pait()\nasync def demo(token: str = field.Depends.i(get_user_by_token)) -&gt; HTTPResponse:\n    return json({\"user\": token})\n\n\napp = Sanic(\"demo\")\napp.add_route(demo, \"/api/demo\", methods={\"GET\"})\napp.exception(Exception)(api_exception)\n\n\nif __name__ == \"__main__\":\n    import uvicorn\n\n    uvicorn.run(app)\n</code></pre> docs_source_code/introduction/depend/tornado_with_depend_demo.py<pre><code>from tornado.ioloop import IOLoop\nfrom tornado.web import Application, RequestHandler\n\nfrom pait import field\nfrom pait.app.tornado import pait\nfrom pait.exceptions import TipException\nfrom pait.openapi.doc_route import AddDocRoute\n\n\nclass _Handler(RequestHandler):\n    def _handle_request_exception(self, exc: BaseException) -&gt; None:\n        if isinstance(exc, TipException):\n            exc = exc.exc\n\n        self.write({\"data\": str(exc)})\n        self.finish()\n\n\nfake_db_dict: dict = {\"u12345\": \"so1n\"}\n\n\nasync def get_user_by_token(token: str = field.Header.i()) -&gt; str:\n    if token not in fake_db_dict:\n        raise RuntimeError(f\"Can not found by token:{token}\")\n    return fake_db_dict[token]\n\n\nclass DemoHandler(_Handler):\n    @pait()\n    async def get(self, token: str = field.Depends.i(get_user_by_token)) -&gt; None:\n        self.write({\"user\": token})\n\n\napp: Application = Application([(r\"/api/demo\", DemoHandler)])\nAddDocRoute(app)\n\n\nif __name__ == \"__main__\":\n    app.listen(8000)\n    IOLoop.instance().start()\n</code></pre> <p>The sample code in the first highlighting code is to mimic the database call method, the current assumption that the database only user <code>so1n</code> has a token and the token value is \"u12345\". The second highlighted code is a function called <code>get_user_by_token</code>, which is responsible for getting the token from the Header and checking if it exists, if it exists, it returns the user, if it doesn't, it throws an error. This is a special function that takes the same arguments as the <code>Pait</code> decorated route function, so any of the previously mentioned methods can be used in this function. The third highlighted code is the Token parameter of the route function and what's special here is wrapping the <code>get_user_by_token</code> function through <code>field.Depend</code>. so that <code>Pait</code> knows that the current Token parameter of the route function must be obtained through the <code>get_user_by_token</code> function.</p> <p>After running the code and calling the <code>curl</code> command, can find that this code works normally. When the token exists, the user name will be returned. If token does not exist, an error message will be returned:</p> curl \"http://127.0.0.1:8000/api/demo\" --header \"token:u12345\"{\"user\":\"so1n\"}curl \"http://127.0.0.1:8000/api/demo\" --header \"token:u123456\"{\"data\":\"Can not found by token:u123456\"} <p>In addition, <code>Pait</code> can also support multiple levels of Depend nesting. The above code as an example, it is now assumed that it is necessary to verify that the Token is legal before going to the database to obtain the corresponding user. The code can be rewritten as follows:</p> FlaskStarletteSanicTornado docs_source_code/introduction/depend/flask_with_nested_depend_demo.py<pre><code>from flask import Flask, Response, jsonify\n\nfrom pait import field\nfrom pait.app.flask import pait\nfrom pait.exceptions import TipException\n\n\ndef api_exception(exc: Exception) -&gt; Response:\n    if isinstance(exc, TipException):\n        exc = exc.exc\n    return jsonify({\"data\": str(exc)})\n\n\nfake_db_dict: dict = {\"u12345\": \"so1n\"}\n\n\ndef check_token(token: str = field.Header.i()) -&gt; str:\n    if len(token) != 6 and token[0] != \"u\":\n        raise RuntimeError(\"Illegal Token\")\n    return token\n\n\ndef get_user_by_token(token: str = field.Depends.i(check_token)) -&gt; str:\n    if token not in fake_db_dict:\n        raise RuntimeError(f\"Can not found by token:{token}\")\n    return fake_db_dict[token]\n\n\n@pait()\ndef demo(token: str = field.Depends.i(get_user_by_token)) -&gt; dict:\n    return {\"user\": token}\n\n\napp = Flask(\"demo\")\napp.add_url_rule(\"/api/demo\", view_func=demo, methods=[\"GET\"])\napp.errorhandler(Exception)(api_exception)\n\n\nif __name__ == \"__main__\":\n    app.run(port=8000)\n</code></pre> docs_source_code/introduction/depend/starlette_with_nested_depend_demo.py<pre><code>from starlette.applications import Starlette\nfrom starlette.requests import Request\nfrom starlette.responses import JSONResponse\nfrom starlette.routing import Route\n\nfrom pait import field\nfrom pait.app.starlette import pait\nfrom pait.exceptions import TipException\n\n\nasync def api_exception(request: Request, exc: Exception) -&gt; JSONResponse:\n    if isinstance(exc, TipException):\n        exc = exc.exc\n    return JSONResponse({\"data\": str(exc)})\n\n\nfake_db_dict: dict = {\"u12345\": \"so1n\"}\n\n\ndef check_token(token: str = field.Header.i()) -&gt; str:\n    if len(token) != 6 and token[0] != \"u\":\n        raise RuntimeError(\"Illegal Token\")\n    return token\n\n\nasync def get_user_by_token(token: str = field.Depends.i(check_token)) -&gt; str:\n    if token not in fake_db_dict:\n        raise RuntimeError(f\"Can not found by token:{token}\")\n    return fake_db_dict[token]\n\n\n@pait()\nasync def demo(token: str = field.Depends.i(get_user_by_token)) -&gt; JSONResponse:\n    return JSONResponse({\"user\": token})\n\n\napp = Starlette(routes=[Route(\"/api/demo\", demo, methods=[\"GET\"])])\napp.add_exception_handler(Exception, api_exception)\n\n\nif __name__ == \"__main__\":\n    import uvicorn\n\n    uvicorn.run(app)\n</code></pre> docs_source_code/introduction/depend/sanic_with_nested_depend_demo.py<pre><code>from sanic import HTTPResponse, Request, Sanic, json\n\nfrom pait import field\nfrom pait.app.sanic import pait\nfrom pait.exceptions import TipException\n\n\nasync def api_exception(request: Request, exc: Exception) -&gt; HTTPResponse:\n    if isinstance(exc, TipException):\n        exc = exc.exc\n    return json({\"data\": str(exc)})\n\n\nfake_db_dict: dict = {\"u12345\": \"so1n\"}\n\n\ndef check_token(token: str = field.Header.i()) -&gt; str:\n    if len(token) != 6 and token[0] != \"u\":\n        raise RuntimeError(\"Illegal Token\")\n    return token\n\n\nasync def get_user_by_token(token: str = field.Depends.i(check_token)) -&gt; str:\n    if token not in fake_db_dict:\n        raise RuntimeError(f\"Can not found by token:{token}\")\n    return fake_db_dict[token]\n\n\n@pait()\nasync def demo(token: str = field.Depends.i(get_user_by_token)) -&gt; HTTPResponse:\n    return json({\"user\": token})\n\n\napp = Sanic(\"demo\")\napp.add_route(demo, \"/api/demo\", methods={\"GET\"})\napp.exception(Exception)(api_exception)\n\n\nif __name__ == \"__main__\":\n    import uvicorn\n\n    uvicorn.run(app)\n</code></pre> docs_source_code/introduction/depend/tornado_with_nested_depend_demo.py<pre><code>from tornado.ioloop import IOLoop\nfrom tornado.web import Application, RequestHandler\n\nfrom pait import field\nfrom pait.app.tornado import pait\nfrom pait.exceptions import TipException\nfrom pait.openapi.doc_route import AddDocRoute\n\n\nclass _Handler(RequestHandler):\n    def _handle_request_exception(self, exc: BaseException) -&gt; None:\n        if isinstance(exc, TipException):\n            exc = exc.exc\n\n        self.write({\"data\": str(exc)})\n        self.finish()\n\n\nfake_db_dict: dict = {\"u12345\": \"so1n\"}\n\n\ndef check_token(token: str = field.Header.i()) -&gt; str:\n    if len(token) != 6 and token[0] != \"u\":\n        raise RuntimeError(\"Illegal Token\")\n    return token\n\n\nasync def get_user_by_token(token: str = field.Depends.i(check_token)) -&gt; str:\n    if token not in fake_db_dict:\n        raise RuntimeError(f\"Can not found by token:{token}\")\n    return fake_db_dict[token]\n\n\nclass DemoHandler(_Handler):\n    @pait()\n    async def get(self, token: str = field.Depends.i(get_user_by_token)) -&gt; None:\n        self.write({\"user\": token})\n\n\napp: Application = Application([(r\"/api/demo\", DemoHandler)])\nAddDocRoute(app)\n\n\nif __name__ == \"__main__\":\n    app.listen(8000)\n    IOLoop.instance().start()\n</code></pre> <p>Sample code in the highlighted code for the modified code, this part of the code is mainly a new <code>check_token</code> function used to get and verify the Token. At the same time <code>get_user_by_token</code> to get the source of Token from <code>Header</code> to <code>check_token</code>.</p> <p>After running the code and calling the <code>curl</code> command to test it, we can see from the output that it will return an error message if it doesn't conform to the checking logic:</p> curl \"http://127.0.0.1:8000/api/demo\" --header \"token:u12345\"{\"user\":\"so1n\"}curl \"http://127.0.0.1:8000/api/demo\" --header \"token:u123456\"{\"data\":\"Can not found by token:u123456\"}curl \"http://127.0.0.1:8000/api/demo\" --header \"token:fu12345\"{\"data\":\"Illegal Token\"}"},{"location":"1_4_depend/#2depend-based-on-contextmanager","title":"2.Depend based on ContextManager","text":"<p>The <code>Depends</code> usages shown in the previous section all work fine, but they don't have any way to know what's going on with the function like a <code>Python</code> decorator does, including whether the function is running correctly, what exceptions are thrown, when it's done, etc. At this time, need to solve this problem based on <code>Depend</code> of <code>ContextManager</code>.</p> <p>Using <code>Depend</code> based on <code>Context Manager</code> is very simple, just add the corresponding <code>Context Manager</code> decorator to the function, and then use the <code>try</code>, <code>except</code>, <code>finally</code> syntax as described in Context Manager official documentation, as shown in the following sample code: <pre><code>from contextlib import contextmanager\nfrom typing import Any, Generator\n\n@contextmanager\ndef demo() -&gt; Generator[Any, Any, Any]:\n    try:\n        # 1\n        yield None\n    except Exception:\n        # 2\n        pass\n    finally:\n        # 3\n        pass\n</code></pre> The position of sequence number 1 in this sample code is used to normal function logic and return data through yield. Position number 2 is used to write the code logic when the function runs abnormally. The last serial number 3 is used to finally processing.</p> <p>Below is a sample code using <code>ContextManager</code> and <code>Depend</code>\uff1a</p> FlaskStarletteSanicTornado docs_source_code/introduction/depend/flask_with_context_manager_depend_demo.py<pre><code>from contextlib import contextmanager\nfrom typing import Any, Generator\n\nfrom flask import Flask, Response, jsonify\n\nfrom pait import field\nfrom pait.app.flask import pait\nfrom pait.exceptions import TipException\n\n\ndef api_exception(exc: Exception) -&gt; Response:\n    if isinstance(exc, TipException):\n        exc = exc.exc\n    return jsonify({\"data\": str(exc)})\n\n\nclass _DemoSession(object):\n    def __init__(self, uid: int) -&gt; None:\n        self._uid: int = uid\n        self._status: bool = False\n\n    @property\n    def uid(self) -&gt; int:\n        if self._status:\n            return self._uid\n        else:\n            raise RuntimeError(\"Session is close\")\n\n    def create(self) -&gt; None:\n        self._status = True\n\n    def close(self) -&gt; None:\n        self._status = False\n\n\n@contextmanager\ndef context_depend(uid: int = field.Query.i(description=\"user id\", gt=10, lt=1000)) -&gt; Generator[int, Any, Any]:\n    session: _DemoSession = _DemoSession(uid)\n    try:\n        print(\"context_depend init\")\n        session.create()\n        yield session.uid\n    except Exception:\n        print(\"context_depend error\")\n    finally:\n        print(\"context_depend exit\")\n        session.close()\n\n\n@pait()\ndef demo(uid: int = field.Depends.i(context_depend), is_raise: bool = field.Query.i(default=False)) -&gt; Response:\n    if is_raise:\n        raise RuntimeError()\n    return jsonify({\"code\": 0, \"msg\": uid})\n\n\napp = Flask(\"demo\")\napp.add_url_rule(\"/api/demo\", view_func=demo, methods=[\"GET\"])\napp.errorhandler(Exception)(api_exception)\n\n\nif __name__ == \"__main__\":\n    app.run(port=8000)\n</code></pre> docs_source_code/introduction/depend/starlette_with_context_manager_depend_demo.py<pre><code>from contextlib import asynccontextmanager\nfrom typing import Any, AsyncGenerator\n\nfrom starlette.applications import Starlette\nfrom starlette.requests import Request\nfrom starlette.responses import JSONResponse\nfrom starlette.routing import Route\n\nfrom pait import field\nfrom pait.app.starlette import pait\nfrom pait.exceptions import TipException\n\n\nasync def api_exception(request: Request, exc: Exception) -&gt; JSONResponse:\n    if isinstance(exc, TipException):\n        exc = exc.exc\n    return JSONResponse({\"data\": str(exc)})\n\n\nclass _DemoSession(object):\n    def __init__(self, uid: int) -&gt; None:\n        self._uid: int = uid\n        self._status: bool = False\n\n    @property\n    def uid(self) -&gt; int:\n        if self._status:\n            return self._uid\n        else:\n            raise RuntimeError(\"Session is close\")\n\n    def create(self) -&gt; None:\n        self._status = True\n\n    def close(self) -&gt; None:\n        self._status = False\n\n\n@asynccontextmanager\nasync def context_depend(uid: int = field.Query.i(description=\"user id\", gt=10, lt=1000)) -&gt; AsyncGenerator[int, Any]:\n    session: _DemoSession = _DemoSession(uid)\n    try:\n        print(\"context_depend init\")\n        session.create()\n        yield session.uid\n    except Exception:\n        print(\"context_depend error\")\n    finally:\n        print(\"context_depend exit\")\n        session.close()\n\n\n@pait()\nasync def demo(\n    uid: int = field.Depends.i(context_depend), is_raise: bool = field.Query.i(default=False)\n) -&gt; JSONResponse:\n    if is_raise:\n        raise RuntimeError()\n    return JSONResponse({\"code\": 0, \"msg\": uid})\n\n\napp = Starlette(routes=[Route(\"/api/demo\", demo, methods=[\"GET\"])])\napp.add_exception_handler(Exception, api_exception)\n\n\nif __name__ == \"__main__\":\n    import uvicorn\n\n    uvicorn.run(app)\n</code></pre> docs_source_code/introduction/depend/sanic_with_context_manager_depend_demo.py<pre><code>from contextlib import asynccontextmanager\nfrom typing import Any, AsyncGenerator\n\nfrom sanic import HTTPResponse, Request, Sanic, json\n\nfrom pait import field\nfrom pait.app.sanic import pait\nfrom pait.exceptions import TipException\n\n\nasync def api_exception(request: Request, exc: Exception) -&gt; HTTPResponse:\n    if isinstance(exc, TipException):\n        exc = exc.exc\n    return json({\"data\": str(exc)})\n\n\nclass _DemoSession(object):\n    def __init__(self, uid: int) -&gt; None:\n        self._uid: int = uid\n        self._status: bool = False\n\n    @property\n    def uid(self) -&gt; int:\n        if self._status:\n            return self._uid\n        else:\n            raise RuntimeError(\"Session is close\")\n\n    def create(self) -&gt; None:\n        self._status = True\n\n    def close(self) -&gt; None:\n        self._status = False\n\n\n@asynccontextmanager\nasync def context_depend(uid: int = field.Query.i(description=\"user id\", gt=10, lt=1000)) -&gt; AsyncGenerator[int, Any]:\n    session: _DemoSession = _DemoSession(uid)\n    try:\n        print(\"context_depend init\")\n        session.create()\n        yield session.uid\n    except Exception:\n        print(\"context_depend error\")\n    finally:\n        print(\"context_depend exit\")\n        session.close()\n\n\n@pait()\nasync def demo(\n    uid: int = field.Depends.i(context_depend), is_raise: bool = field.Query.i(default=False)\n) -&gt; HTTPResponse:\n    if is_raise:\n        raise RuntimeError()\n    return json({\"code\": 0, \"msg\": uid})\n\n\napp = Sanic(\"demo\")\napp.add_route(demo, \"/api/demo\", methods={\"GET\"})\napp.exception(Exception)(api_exception)\n\n\nif __name__ == \"__main__\":\n    import uvicorn\n\n    uvicorn.run(app)\n</code></pre> docs_source_code/introduction/depend/tornado_with_context_manager_depend_demo.py<pre><code>from contextlib import asynccontextmanager\nfrom typing import Any, AsyncGenerator\n\nfrom tornado.ioloop import IOLoop\nfrom tornado.web import Application, RequestHandler\n\nfrom pait import field\nfrom pait.app.tornado import pait\nfrom pait.exceptions import TipException\nfrom pait.openapi.doc_route import AddDocRoute\n\n\nclass _DemoSession(object):\n    def __init__(self, uid: int) -&gt; None:\n        self._uid: int = uid\n        self._status: bool = False\n\n    @property\n    def uid(self) -&gt; int:\n        if self._status:\n            return self._uid\n        else:\n            raise RuntimeError(\"Session is close\")\n\n    def create(self) -&gt; None:\n        self._status = True\n\n    def close(self) -&gt; None:\n        self._status = False\n\n\n@asynccontextmanager\nasync def context_depend(uid: int = field.Query.i(description=\"user id\", gt=10, lt=1000)) -&gt; AsyncGenerator[int, Any]:\n    session: _DemoSession = _DemoSession(uid)\n    try:\n        print(\"context_depend init\")\n        session.create()\n        yield session.uid\n    except Exception:\n        print(\"context_depend error\")\n    finally:\n        print(\"context_depend exit\")\n        session.close()\n\n\nclass _Handler(RequestHandler):\n    def _handle_request_exception(self, exc: BaseException) -&gt; None:\n        if isinstance(exc, TipException):\n            exc = exc.exc\n\n        self.write({\"data\": str(exc)})\n        self.finish()\n\n\nclass DemoHandler(_Handler):\n    @pait()\n    async def get(\n        self, uid: int = field.Depends.i(context_depend), is_raise: bool = field.Query.i(default=False)\n    ) -&gt; None:\n        if is_raise:\n            raise RuntimeError()\n        self.write({\"code\": 0, \"msg\": uid})\n\n\napp: Application = Application([(r\"/api/demo\", DemoHandler)])\nAddDocRoute(app)\n\n\nif __name__ == \"__main__\":\n    app.listen(8000)\n    IOLoop.instance().start()\n</code></pre> <p>This example assumes that a session is created based on the corresponding uid for each request and that the session is automatically closed at the end of the request. The first highlighted code simulates a session based on the uid. The second highlighted code is a <code>Depends</code> function decorated with <code>ContextManger</code>, which prints different things in <code>try</code>, <code>except</code> and <code>finally</code>. The third highlighted code is a route function, which will return an error or normal response according to the value of <code>is_raise</code>.</p> <p>Now run the code and use the <code>curl</code> command to test. Through the result output, can find that the response result of the first request is normal, while the second request is abnormal (returns an empty string):</p> curl \"http://127.0.0.1:8000/api/demo?uid=999\"{\"code\":0,\"msg\":999}curl \"http://127.0.0.1:8000/api/demo?uid=999&amp;is_raise=True\"{\"data\":\"\"} <p>At this time, switch back to the terminal where the sample code has been run, and you can find that the terminal prints data similar to the following: <pre><code>context_depend init\ncontext_depend exit\nINFO:     127.0.0.1:44162 - \"GET /api/demo?uid=999 HTTP/1.1\" 200 OK\ncontext_depend init\ncontext_depend error\ncontext_depend exit\nINFO:     127.0.0.1:44164 - \"GET /api/demo?uid=999&amp;is_raise=True HTTP/1.1\" 200 OK\n</code></pre> It can be seen from the data output by the terminal that in the first request, the terminal only printed <code>init</code> and <code>exit</code>, but in the second request, the terminal printed more between <code>init</code> and <code>exit</code> One line of <code>error</code>.</p>"},{"location":"1_4_depend/#3depend","title":"3.\u57fa\u4e8e\u7c7b\u7684Depend","text":"<p>Class-based <code>Depend</code> is similar to function-based <code>Depend</code>, the difference between them is that <code>Pait</code> not only resolves the function signature of the class's <code>__call__</code> method, but also resolves the class's attributes, as shown in the following example:</p> FlaskStarletteSanicTornado docs_source_code/introduction/depend/flask_with_class_depend_demo.py<pre><code>from flask import Flask, Response, jsonify\n\nfrom pait import field\nfrom pait.app.flask import pait\nfrom pait.exceptions import TipException\n\n\ndef api_exception(exc: Exception) -&gt; Response:\n    if isinstance(exc, TipException):\n        exc = exc.exc\n    return jsonify({\"data\": str(exc)})\n\n\nfake_db_dict: dict = {\"u12345\": \"so1n\"}\n\n\nclass GetUserDepend(object):\n    user_name: str = field.Query.i()\n\n    def __call__(self, token: str = field.Header.i()) -&gt; str:\n        if token not in fake_db_dict:\n            raise RuntimeError(f\"Can not found by token:{token}\")\n        user_name = fake_db_dict[token]\n        if user_name != self.user_name:\n            raise RuntimeError(\"The specified user could not be found through the token\")\n        return user_name\n\n\n@pait()\ndef demo(token: str = field.Depends.i(GetUserDepend)) -&gt; dict:\n    return {\"user\": token}\n\n\napp = Flask(\"demo\")\napp.add_url_rule(\"/api/demo\", view_func=demo, methods=[\"GET\"])\napp.errorhandler(Exception)(api_exception)\n\n\nif __name__ == \"__main__\":\n    app.run(port=8000)\n</code></pre> docs_source_code/introduction/depend/starlette_with_class_depend_demo.py<pre><code>from starlette.applications import Starlette\nfrom starlette.requests import Request\nfrom starlette.responses import JSONResponse\nfrom starlette.routing import Route\n\nfrom pait import field\nfrom pait.app.starlette import pait\nfrom pait.exceptions import TipException\n\n\nasync def api_exception(request: Request, exc: Exception) -&gt; JSONResponse:\n    if isinstance(exc, TipException):\n        exc = exc.exc\n    return JSONResponse({\"data\": str(exc)})\n\n\nfake_db_dict: dict = {\"u12345\": \"so1n\"}\n\n\nclass GetUserDepend(object):\n    user_name: str = field.Query.i()\n\n    async def __call__(self, token: str = field.Header.i()) -&gt; str:\n        if token not in fake_db_dict:\n            raise RuntimeError(f\"Can not found by token:{token}\")\n        user_name = fake_db_dict[token]\n        if user_name != self.user_name:\n            raise RuntimeError(\"The specified user could not be found through the token\")\n        return user_name\n\n\n@pait()\nasync def demo(token: str = field.Depends.i(GetUserDepend)) -&gt; JSONResponse:\n    return JSONResponse({\"user\": token})\n\n\napp = Starlette(routes=[Route(\"/api/demo\", demo, methods=[\"GET\"])])\napp.add_exception_handler(Exception, api_exception)\n\n\nif __name__ == \"__main__\":\n    import uvicorn\n\n    uvicorn.run(app)\n</code></pre> docs_source_code/introduction/depend/sanic_with_class_depend_demo.py<pre><code>from sanic import HTTPResponse, Request, Sanic, json\n\nfrom pait import field\nfrom pait.app.sanic import pait\nfrom pait.exceptions import TipException\n\n\nasync def api_exception(request: Request, exc: Exception) -&gt; HTTPResponse:\n    if isinstance(exc, TipException):\n        exc = exc.exc\n    return json({\"data\": str(exc)})\n\n\nfake_db_dict: dict = {\"u12345\": \"so1n\"}\n\n\nclass GetUserDepend(object):\n    user_name: str = field.Query.i()\n\n    async def __call__(self, token: str = field.Header.i()) -&gt; str:\n        if token not in fake_db_dict:\n            raise RuntimeError(f\"Can not found by token:{token}\")\n        user_name = fake_db_dict[token]\n        if user_name != self.user_name:\n            raise RuntimeError(\"The specified user could not be found through the token\")\n        return user_name\n\n\n@pait()\nasync def demo(token: str = field.Depends.i(GetUserDepend)) -&gt; HTTPResponse:\n    return json({\"user\": token})\n\n\napp = Sanic(\"demo\")\napp.add_route(demo, \"/api/demo\", methods={\"GET\"})\napp.exception(Exception)(api_exception)\n\n\nif __name__ == \"__main__\":\n    import uvicorn\n\n    uvicorn.run(app)\n</code></pre> docs_source_code/introduction/depend/tornado_with_class_depend_demo.py<pre><code>from tornado.ioloop import IOLoop\nfrom tornado.web import Application, RequestHandler\n\nfrom pait import field\nfrom pait.app.tornado import pait\nfrom pait.exceptions import TipException\nfrom pait.openapi.doc_route import AddDocRoute\n\n\nclass _Handler(RequestHandler):\n    def _handle_request_exception(self, exc: BaseException) -&gt; None:\n        if isinstance(exc, TipException):\n            exc = exc.exc\n\n        self.write({\"data\": str(exc)})\n        self.finish()\n\n\nfake_db_dict: dict = {\"u12345\": \"so1n\"}\n\n\nclass GetUserDepend(object):\n    user_name: str = field.Query.i()\n\n    async def __call__(self, token: str = field.Header.i()) -&gt; str:\n        if token not in fake_db_dict:\n            raise RuntimeError(f\"Can not found by token:{token}\")\n        user_name = fake_db_dict[token]\n        if user_name != self.user_name:\n            raise RuntimeError(\"The specified user could not be found through the token\")\n        return user_name\n\n\nclass DemoHandler(_Handler):\n    @pait()\n    async def get(self, token: str = field.Depends.i(GetUserDepend)) -&gt; None:\n        self.write({\"user\": token})\n\n\napp: Application = Application([(r\"/api/demo\", DemoHandler)])\nAddDocRoute(app)\n\n\nif __name__ == \"__main__\":\n    app.listen(8000)\n    IOLoop.instance().start()\n</code></pre> <p>The sample code in the first highlighting code is based on the class <code>Depend</code> implementation, this code is divided into two main parts. The first part is the attributes of the class, which also uses the format of <code>&lt;name&gt;: &lt;type&gt; = &lt;default&gt;</code>, whenever a request hits the route, <code>Pait</code> will be injected into the class with the corresponding value. The second part of the code is rewritten from the example in <code>Usage of Depend</code>, it will check the Token and the corresponding username (normal logic basically doesn't do this, it's just a functional demonstration here), and the <code>__call__</code> method is used in a similar way to the function-based <code>Depend</code>.</p> <code>__call__</code> method usage restrictions <p>Everything in <code>Python</code> is an object, so a class with a <code>__call__</code> method is similar to a function, as shown in the following example code: <pre><code>from typing import Any\n\nclass DemoDepend(object):\n    def __call__(self, *args: Any, **kwargs: Any) -&gt; Any:\n        pass\n</code></pre> The <code>__call__</code> method in the code is an intuitive way to use, but due to the limitations of <code>Python</code>, the <code>__call__</code> method does not support rewriting function signature, such as the following example: <pre><code>from typing import Any\nfrom pait import field\n\nclass DemoDepend(object):\n    def __init__(self) -&gt; Any:\n        def new_call(uid: str = field.Query.i(), user_name: str = field.Query.i()) -&gt; Any:\n            pass\n        setattr(self, \"__call__\", new_call)\n\n    def __call__(self, uid: str = field.Query.i()) -&gt; Any:\n        pass\n</code></pre> After the class is instantiated, the function signature of the <code>__call__</code> method parsed by <code>inspect</code> is still <code>__call__(self, uid: str = field.Query.i()) -&gt; Any</code> instead of <code>__call__(uid: str = field.Query.i(), user_name: str = field.Query.i()) -&gt; Any</code>. This causes <code>Pait</code> to fail to extract the correct parameter rules. In order to solve this problem, <code>Pait</code> prioritizes parsing <code>pait_handler</code> methods that are allowed to be overridden, as follows.: <pre><code>from typing import Any\nfrom pait import field\n\nclass DemoDepend(object):\n    def __init__(self) -&gt; Any:\n        def new_call(uid: str = field.Query.i(), user_name: str = field.Query.i()) -&gt; Any:\n            pass\n        setattr(self, \"pait_handler\", new_call)\n\n    def pait_handler(self, uid: str = field.Query.i()) -&gt; Any:\n        pass\n</code></pre> After the class is instantiated, <code>Pait</code> parses out that the function signature of <code>pait_handler</code> is <code>pait_handler(uid: str = field.Query.i(), user_name: str = field.Query.i()) -&gt; Any</code></p> <p>In the second highlighted code, the function-based <code>Depend</code> in the <code>Depend</code> parameter is replaced with the class-based <code>Depend</code>.</p> <p>After running the code and executing the following <code>curl</code> command, can see the following output:</p> \u279c  ~ curl \"http://127.0.0.1:8000/api/demo\" --header \"token:u12345\"{\"data\":\"Can not found user_name value\"}\u279c  ~ curl \"http://127.0.0.1:8000/api/demo?user_name=so1n\" --header \"token:u12345\"{\"user\":\"so1n\"}\u279c  ~ curl \"http://127.0.0.1:8000/api/demo?user_name=faker\" --header \"token:u12345\"{\"data\":\"The specified user could not be found through the token\"} Initialization for class-based <code>Depend</code> <p>Since a new instance is created for each request, this means that cannot customize the initialization parameters as usual. At this time, can use <code>pait.util.partial wrapper</code> to bind initialization parameters, as shown in the following example:</p> <p><pre><code>from pait import field\nfrom pait.util import partial_wrapper\n\nclass GetUserDepend(object):\n    user_name: str = field.Query.i()\n    age: int = field.Query.i()\n\n    def __init__(self, age_limit: int = 18) -&gt; None:\n        self.age_limit: int = age_limit\n\n    def __call__(self, token: str = field.Header.i()) -&gt; str:\n        if token not in fake_db_dict:\n            raise RuntimeError(f\"Can not found by token:{token}\")\n        user_name = fake_db_dict[token]\n        if user_name != self.user_name:\n            raise RuntimeError(\"The specified user could not be found through the token\")\n        if self.age &lt; self.age_limit:\n            raise ValueError(\"Minors cannot access\")\n        return user_name\n\n\n@pait()\ndef demo(user_name: str = field.Depends.i(partial_wrapper(GetUserDepend, age_limit=16))):\n    pass\n\n@pait()\ndef demo1(user_name: str = field.Depends.i(GetUserDepend)):\n    pass\n</code></pre> In this example, each route function has different age restrictions for users. Among them, <code>demo</code> restricts access to users younger than 16 years old, while <code>demo1</code> restricts access to users younger than 18 years old. So their initialization parameters of <code>GetUserDepend</code> are different.</p> <p>To that end, the <code>demo</code> function uses <code>pait.util.partial_wrapper</code> to bind the initialization parameters to <code>GetUserDepend</code>. The function of <code>pait.util.partial_wrapper</code> is similar to the official <code>functools.partial</code>. The only difference is that it supports PEP 612, can get code tips and use inspection tools for code inspection.</p>"},{"location":"1_4_depend/#4pre-depend","title":"4.Pre-Depend","text":"<p>In some scenarios, the route function only needs the <code>Depends</code> function to perform verification logic and does not need the return value of the <code>Depends</code> function. At this time, may consider using the variable name <code>_</code> instead, as follows: <pre><code>@pait()\ndef demo(_: str = field.Depends.i(get_user_by_token)) -&gt; None:\n    pass\n</code></pre> However, <code>Python</code> does not support multiple variables with the same name in a function, which means that when there are multiple similar parameters, their variable names cannot be changed to <code>_</code>.</p> <p>For this reason, <code>Pait</code> solves this problem through the optional parameter <code>pre_depend_list</code>. Its use is very simple, only need to migrate the <code>Depend</code> function from the parameters to the <code>pre_depend_list</code> optional parameters of <code>Pait</code>. Neither the logic nor the functionality of the <code>Depend</code> code will be affected, and the modified code will look like the following (the highlighted code is the modified part):</p> FlaskStarletteSanicTornado docs_source_code/introduction/depend/flask_with_pre_depend_demo.py<pre><code>from flask import Flask, Response, jsonify\n\nfrom pait import field\nfrom pait.app.flask import pait\nfrom pait.exceptions import TipException\n\n\ndef api_exception(exc: Exception) -&gt; Response:\n    if isinstance(exc, TipException):\n        exc = exc.exc\n    return jsonify({\"data\": str(exc)})\n\n\nfake_db_dict: dict = {\"u12345\": \"so1n\"}\n\n\ndef get_user_by_token(token: str = field.Header.i()) -&gt; str:\n    if token not in fake_db_dict:\n        raise RuntimeError(f\"Can not found by token:{token}\")\n    return fake_db_dict[token]\n\n\n@pait(pre_depend_list=[get_user_by_token])\ndef demo() -&gt; dict:\n    return {\"msg\": \"success\"}\n\n\napp = Flask(\"demo\")\napp.add_url_rule(\"/api/demo\", view_func=demo, methods=[\"GET\"])\napp.errorhandler(Exception)(api_exception)\n\n\nif __name__ == \"__main__\":\n    app.run(port=8000)\n</code></pre> docs_source_code/introduction/depend/starlette_with_pre_depend_demo.py<pre><code>from starlette.applications import Starlette\nfrom starlette.requests import Request\nfrom starlette.responses import JSONResponse\nfrom starlette.routing import Route\n\nfrom pait import field\nfrom pait.app.starlette import pait\nfrom pait.exceptions import TipException\n\n\nasync def api_exception(request: Request, exc: Exception) -&gt; JSONResponse:\n    if isinstance(exc, TipException):\n        exc = exc.exc\n    return JSONResponse({\"data\": str(exc)})\n\n\nfake_db_dict: dict = {\"u12345\": \"so1n\"}\n\n\nasync def get_user_by_token(token: str = field.Header.i()) -&gt; str:\n    if token not in fake_db_dict:\n        raise RuntimeError(f\"Can not found by token:{token}\")\n    return fake_db_dict[token]\n\n\n@pait(pre_depend_list=[get_user_by_token])\nasync def demo() -&gt; JSONResponse:\n    return JSONResponse({\"msg\": \"success\"})\n\n\napp = Starlette(routes=[Route(\"/api/demo\", demo, methods=[\"GET\"])])\napp.add_exception_handler(Exception, api_exception)\n\n\nif __name__ == \"__main__\":\n    import uvicorn\n\n    uvicorn.run(app)\n</code></pre> docs_source_code/introduction/depend/sanic_with_pre_depend_demo.py<pre><code>from sanic import HTTPResponse, Request, Sanic, json\n\nfrom pait import field\nfrom pait.app.sanic import pait\nfrom pait.exceptions import TipException\n\n\nasync def api_exception(request: Request, exc: Exception) -&gt; HTTPResponse:\n    if isinstance(exc, TipException):\n        exc = exc.exc\n    return json({\"data\": str(exc)})\n\n\nfake_db_dict: dict = {\"u12345\": \"so1n\"}\n\n\nasync def get_user_by_token(token: str = field.Header.i()) -&gt; str:\n    if token not in fake_db_dict:\n        raise RuntimeError(f\"Can not found by token:{token}\")\n    return fake_db_dict[token]\n\n\n@pait(pre_depend_list=[get_user_by_token])\nasync def demo(request: Request) -&gt; HTTPResponse:\n    return json({\"msg\": \"success\"})\n\n\napp = Sanic(\"demo\")\napp.add_route(demo, \"/api/demo\", methods={\"GET\"})\napp.exception(Exception)(api_exception)\n\n\nif __name__ == \"__main__\":\n    import uvicorn\n\n    uvicorn.run(app)\n</code></pre> docs_source_code/introduction/depend/tornado_with_pre_depend_demo.py<pre><code>from tornado.ioloop import IOLoop\nfrom tornado.web import Application, RequestHandler\n\nfrom pait import field\nfrom pait.app.tornado import pait\nfrom pait.exceptions import TipException\nfrom pait.openapi.doc_route import AddDocRoute\n\n\nclass _Handler(RequestHandler):\n    def _handle_request_exception(self, exc: BaseException) -&gt; None:\n        if isinstance(exc, TipException):\n            exc = exc.exc\n\n        self.write({\"data\": str(exc)})\n        self.finish()\n\n\nfake_db_dict: dict = {\"u12345\": \"so1n\"}\n\n\nasync def get_user_by_token(token: str = field.Header.i()) -&gt; str:\n    if token not in fake_db_dict:\n        raise RuntimeError(f\"Can not found by token:{token}\")\n    return fake_db_dict[token]\n\n\nclass DemoHandler(_Handler):\n    @pait(pre_depend_list=[get_user_by_token])\n    async def get(self) -&gt; None:\n        self.write({\"msg\": \"success\"})\n\n\napp: Application = Application([(r\"/api/demo\", DemoHandler)])\nAddDocRoute(app)\n\n\nif __name__ == \"__main__\":\n    app.listen(8000)\n    IOLoop.instance().start()\n</code></pre> <p>After running the code and executing the <code>curl</code> command, can see that <code>Pre-Depend</code> can work normally through the following output.:</p> curl \"http://127.0.0.1:8000/api/demo\" --header \"token:u12345\"{\"msg\":\"success\"}curl \"http://127.0.0.1:8000/api/demo\" --header \"token:u123456\"{\"data\":\"Can not found by token:u123456\"} <p>Note</p> <ul> <li>1.When using <code>Pre-Depend</code>, <code>Pait</code> will first execute <code>Pre-Depend</code> in sequence and then execute the route function. If there is an error in the execution of <code>Pre-Depend</code>, an error will be thrown directly.</li> <li>2.<code>Pre-Depend</code> is bound to <code>Pait</code> instead of a route function, which means that <code>Pre-Depend</code> can be reused together with <code>Pait</code>, see for details Reuse of Pait\u3002</li> </ul>"},{"location":"1_4_depend/#5dont-share-limited-resources","title":"5.Don't share limited resources","text":"<p><code>Depend</code> is the best implementation for sharing the same logic, it is important to be careful not to share limited resources, Because the shared resources are for the entire route function, which means that it may affect the concurrency count of the system, or even bring down the entire system.</p> <p>Note</p> <p>There are many types of finite resources, common finite resources are: thread pools, <code>MySQL</code> connection pools, <code>Redis</code> connection pools, etc.</p> <p>Since the content of this section has nothing to do with the use of <code>Pait</code>, the dangers of sharing limited resources will be illustrated by using the <code>Redis</code> connection as an example.</p> <p>Note</p> <ul> <li>1.The best demonstration use case is the connection pool of <code>MySQL</code>, but in order to save the amount of code, the <code>Redis</code> connection is used here to briefly explain the dangers of sharing limited resources.</li> <li>2.Normally, you don't get a connection to <code>Redis</code> directly, and <code>Redis</code> doesn't expose a similar interface. It's just that the execution logic of the <code>execute_command</code> method is similar to getting a connection, so we'll use it as an example.</li> </ul> <p>A <code>Redis</code> connection can only do one thing, but <code>Redis</code> itself is so well designed that clients can still achieve high concurrency with connection pooling. However, if the logic of the route function is complex and takes a long time to execute, then the concurrency of the entire service is limited by the number of connection pools, as in the following code. <pre><code>import time\nfrom typing import Callable\nfrom flask import Flask, Response, jsonify\nfrom redis import Redis\nfrom pait.app.flask import pait\nfrom pait import field\n\nredis = Redis(max_connections=100)\n\n\ndef get_redis() -&gt; Callable:\n    return redis.execute_command\n\n\n@pait()\ndef demo(my_redis_conn: Callable = field.Depends.i(get_redis)) -&gt; Response:\n    # mock redis cli\n    my_redis_conn(\"info\")\n    # mock io\n    time.sleep(5)\n    return jsonify()\n\n\napp = Flask(\"demo\")\napp.add_url_rule(\"/api/demo\", view_func=demo, methods=[\"GET\"])\napp.run(port=8000)\n</code></pre> Each route function in the sample code will first obtain the <code>Redis</code> connection, then execute the route function logic and finally release the <code>Redis</code> connection. Therefore, the usage time of <code>Redis</code> connection is the running time of the entire route function, which means that if the logic of the route function is relatively complex, the number of concurrency of the entire service will be limited by the number of <code>Redis</code> connection pool. Just like the <code>demo</code> route function in the example code, the <code>demo</code> route function will first call <code>Redis</code>'s <code>info</code> command and then simulate an <code>IO</code> operation sleeping for 5 seconds. This means that after getting the <code>Redis</code> connection, most of the time of the <code>Redis</code> connection is wasted waiting for the <code>IO</code> operation, which is very bad.</p> <p>To solve this problem is very simple, just change the shared resources into a shared method of obtaining resources, as shown in the following code: <pre><code>import time\nfrom typing import Callable\nfrom flask import Flask, Response, jsonify\nfrom redis import Redis\nfrom pait.app.flask import pait\nfrom pait import field\n\nredis = Redis(max_connections=100)\n\n\ndef get_redis() -&gt; Callable:\n    return lambda :redis.execute_command\n\n\n@pait()\ndef demo(my_redis_conn: Callable = field.Depends.i(get_redis)) -&gt; Response:\n    # mock redis cli\n    conn = my_redis_conn()\n    conn(\"info\")\n    del conn\n    # mock io\n    time.sleep(5)\n    return jsonify()\n\n\napp = Flask(\"demo\")\napp.add_url_rule(\"/api/demo\", view_func=demo, methods=[\"GET\"])\napp.run(port=8000)\n</code></pre> There are two parts of this code that have changed. The first part is the first highlighted code, which changes the <code>get_redis</code> function from returning a <code>Redis</code> connection to returning a method to get a <code>Redis</code> connection. The second part is the second highlighted code, which changes from calling the <code>Redis</code> connection directly to first getting the <code>Redis</code> connection and then calling it and finally releasing the <code>Redis</code> connection.</p> <p>In this way, the connection to <code>Redis</code> will only be obtained when <code>Redis</code> is used, and the concurrency of the system will not be easily affected by the <code>Redis</code> connection pool.</p>"},{"location":"1_5_exception/","title":"Exception","text":"<p>There is a lot of parameter verification logic inside <code>Pait</code>, so a variety of error conditions will occur. In order to easily catch and understand exceptions during use, <code>Pait</code> has a simple exception mechanism.</p> <p>Note</p> <p>Exceptions of <code>Pait</code> are inherited from <code>PaitBaseException</code>, and in the event of an exception can use <code>isinstance(exc, PaitBaseException)</code> to determine if the exception is a <code>Pait</code> exception. In addition, since <code>Pait</code> passes the data to <code>Pydantic</code> for validation, <code>Pydantic</code> related exceptions will be thrown at runtime because the validation fails, you can learn how to use <code>Pydantic</code> exceptions through Error Handling.</p>"},{"location":"1_5_exception/#1pait-exception-introduction","title":"1.<code>Pait</code> exception introduction","text":""},{"location":"1_5_exception/#11tipexception","title":"1.1.TipException","text":"<p>When the program is running, <code>Pait</code> checks and verifies the parameters, and throws an exception if the verification fails. However, the exception will only flow in <code>Pait</code> and will not be exposed so that the developer will not be able to know which route function threw the exception, which makes troubleshooting very difficult.</p> <p>So <code>Pait</code> wraps the exception in a <code>TipException</code> that indicates which route function threw the exception and where it threw it. If you use an IDE tool such as <code>Pycharm</code>, you can also click on the route to jump to the corresponding place, an example of an exception is as follows: <pre><code>Traceback (most recent call last):\n  File \"/home/so1n/github/pait/.venv/lib/python3.7/site-packages/starlette/exceptions.py\", line 71, in __call__\n    await self.app(scope, receive, sender)\n  File \"/home/so1n/github/pait/.venv/lib/python3.7/site-packages/starlette/routing.py\", line 583, in __call__\n    await route.handle(scope, receive, send)\n  File \"/home/so1n/github/pait/.venv/lib/python3.7/site-packages/starlette/routing.py\", line 243, in handle\n    await self.app(scope, receive, send)\n  File \"/home/so1n/github/pait/.venv/lib/python3.7/site-packages/starlette/routing.py\", line 54, in app\n    response = await func(request)\n  File \"/home/so1n/github/pait/pait/core.py\", line 232, in dispatch\n    return await first_plugin(*args, **kwargs)\n  File \"/home/so1n/github/pait/pait/param_handle.py\", line 448, in __call__\n    async with self:\n  File \"/home/so1n/github/pait/pait/param_handle.py\", line 456, in __aenter__\n    raise e from gen_tip_exc(self.call_next, e)\n  File \"/home/so1n/github/pait/pait/param_handle.py\", line 453, in __aenter__\n    await self._gen_param()\n  File \"/home/so1n/github/pait/pait/param_handle.py\", line 439, in _gen_param\n    self.args, self.kwargs = await self.param_handle(func_sig, func_sig.param_list)\n  File \"/home/so1n/github/pait/pait/param_handle.py\", line 396, in param_handle\n    await asyncio.gather(*[_param_handle(parameter) for parameter in param_list])\n  File \"/home/so1n/github/pait/pait/param_handle.py\", line 393, in _param_handle\n    raise gen_tip_exc(_object, closer_e, parameter)\npait.exceptions.TipException: Can not found content__type value for &lt;function raise_tip_route at 0x7f512ccdebf8&gt;   Customer Traceback:\n    File \"/home/so1n/github/pait/example/param_verify/starlette_example.py\", line 88, in raise_tip_route.\n</code></pre> Through the exception example, can see that the exception is thrown through the <code>gen_tip_exc</code> function, and the thrown exception information includes the location of the route function. However, there is a downside to using <code>TipException</code> though, it causes all exceptions to be <code>TipException</code> needing to get the original exception via <code>TipException.exc</code>.</p>"},{"location":"1_5_exception/#12parameter-exception","title":"1.2.Parameter exception","text":"<p>Currently, <code>Pait</code> has 3 types of parameter exceptions, as follows:</p> Exception Location Description NotFoundFieldException Plugin Pre Check Indicates that the corresponding <code>Field</code> cannot be matched, and this exception will not be encountered during normal use. NotFoundValueException Execute route function This exception indicates that the corresponding value cannot be found from the request data. This is a common exception. FieldValueTypeException Plugin Pre Check Indicates that <code>Pait</code> found that the values filled in <code>default</code>, <code>example</code> in <code>Field</code> are illegal, and the user needs to make corrections according to the prompts. <p>These three exceptions are inherited from <code>PaitBaseParamException</code>, and its source code is as follows: <pre><code>class PaitBaseParamException(PaitBaseException):\n    def __init__(self, param: str, msg: str):\n        super().__init__(msg)\n        self.param: str = param\n        self.msg: str = msg\n</code></pre> It can be seen from the code that <code>PaitBaseParamException</code> not only includes error information, but also includes the name of the parameter that caused the current error.</p>"},{"location":"1_5_exception/#2how-to-use-exceptions","title":"2.How to use exceptions","text":""},{"location":"1_5_exception/#21usage-exception","title":"2.1.Usage Exception","text":"<p>In CRUD business, exceptions thrown by route functions must be caught, and then an agreed error message is returned for front-end use. The following is an example code for exception capture:</p> FlaskStarletteSanicTornado docs_source_code/introduction/exception/flask_with_exception_demo.py<pre><code>from typing import List\n\nfrom flask import Flask, Response, jsonify\nfrom pydantic import ValidationError\n\nfrom pait import exceptions, field\nfrom pait.app.flask import pait\n\n\ndef api_exception(exc: Exception) -&gt; Response:\n    if isinstance(exc, exceptions.TipException):\n        exc = exc.exc\n\n    if isinstance(exc, exceptions.PaitBaseParamException):\n        return jsonify({\"code\": -1, \"msg\": f\"error param:{exc.param}, {exc.msg}\"})\n    elif isinstance(exc, ValidationError):\n        error_param_list: List = []\n        for i in exc.errors():\n            error_param_list.extend(i[\"loc\"])\n        return jsonify({\"code\": -1, \"msg\": f\"check error param: {error_param_list}\"})\n    elif isinstance(exc, exceptions.PaitBaseException):\n        return jsonify({\"code\": -1, \"msg\": str(exc)})\n\n    return jsonify({\"code\": -1, \"msg\": str(exc)})\n\n\n@pait()\ndef demo(demo_value: int = field.Query.i()) -&gt; Response:\n    return jsonify({\"code\": 0, \"msg\": \"\", \"data\": demo_value})\n\n\napp = Flask(\"demo\")\napp.add_url_rule(\"/api/demo\", view_func=demo, methods=[\"GET\"])\napp.errorhandler(Exception)(api_exception)\n\n\nif __name__ == \"__main__\":\n    app.run(port=8000)\n</code></pre> docs_source_code/introduction/exception/starlette_with_exception_demo.py<pre><code>from typing import List\n\nfrom pydantic import ValidationError\nfrom starlette.applications import Starlette\nfrom starlette.requests import Request\nfrom starlette.responses import JSONResponse\nfrom starlette.routing import Route\n\nfrom pait import exceptions, field\nfrom pait.app.starlette import pait\n\n\nasync def api_exception(request: Request, exc: Exception) -&gt; JSONResponse:\n    if isinstance(exc, exceptions.TipException):\n        exc = exc.exc\n\n    if isinstance(exc, exceptions.PaitBaseParamException):\n        return JSONResponse({\"code\": -1, \"msg\": f\"error param:{exc.param}, {exc.msg}\"})\n    elif isinstance(exc, ValidationError):\n        error_param_list: List = []\n        for i in exc.errors():\n            error_param_list.extend(i[\"loc\"])\n        return JSONResponse({\"code\": -1, \"msg\": f\"check error param: {error_param_list}\"})\n    elif isinstance(exc, exceptions.PaitBaseException):\n        return JSONResponse({\"code\": -1, \"msg\": str(exc)})\n\n    return JSONResponse({\"code\": -1, \"msg\": str(exc)})\n\n\n@pait()\nasync def demo(demo_value: int = field.Query.i()) -&gt; JSONResponse:\n    return JSONResponse({\"code\": 0, \"msg\": \"\", \"data\": demo_value})\n\n\napp = Starlette(routes=[Route(\"/api/demo\", demo, methods=[\"GET\"])])\napp.add_exception_handler(Exception, api_exception)\n\n\nif __name__ == \"__main__\":\n    import uvicorn\n\n    uvicorn.run(app)\n</code></pre> docs_source_code/introduction/exception/sanic_with_exception_demo.py<pre><code>from typing import List\n\nfrom pydantic import ValidationError\nfrom sanic import HTTPResponse, Request, Sanic, json\n\nfrom pait import exceptions, field\nfrom pait.app.sanic import pait\n\n\nasync def api_exception(request: Request, exc: Exception) -&gt; HTTPResponse:\n    if isinstance(exc, exceptions.TipException):\n        exc = exc.exc\n\n    if isinstance(exc, exceptions.PaitBaseParamException):\n        return json({\"code\": -1, \"msg\": f\"error param:{exc.param}, {exc.msg}\"})\n    elif isinstance(exc, ValidationError):\n        error_param_list: List = []\n        for i in exc.errors():\n            error_param_list.extend(i[\"loc\"])\n        return json({\"code\": -1, \"msg\": f\"check error param: {error_param_list}\"})\n    elif isinstance(exc, exceptions.PaitBaseException):\n        return json({\"code\": -1, \"msg\": str(exc)})\n\n    return json({\"code\": -1, \"msg\": str(exc)})\n\n\n@pait()\nasync def demo(demo_value: int = field.Query.i()) -&gt; HTTPResponse:\n    return json({\"code\": 0, \"msg\": \"\", \"data\": demo_value})\n\n\napp = Sanic(\"demo\")\napp.add_route(demo, \"/api/demo\", methods={\"GET\"})\napp.exception(Exception)(api_exception)\n\n\nif __name__ == \"__main__\":\n    import uvicorn\n\n    uvicorn.run(app)\n</code></pre> docs_source_code/introduction/exception/tornado_with_exception_demo.py<pre><code>from typing import List\n\nfrom pydantic import ValidationError\nfrom tornado.ioloop import IOLoop\nfrom tornado.web import Application, RequestHandler\n\nfrom pait import exceptions, field\nfrom pait.app.tornado import pait\nfrom pait.openapi.doc_route import AddDocRoute\n\n\nclass _Handler(RequestHandler):\n    def _handle_request_exception(self, exc: BaseException) -&gt; None:\n        if isinstance(exc, exceptions.TipException):\n            exc = exc.exc\n\n        if isinstance(exc, exceptions.PaitBaseParamException):\n            self.write({\"code\": -1, \"msg\": f\"error param:{exc.param}, {exc.msg}\"})\n        elif isinstance(exc, ValidationError):\n            error_param_list: List = []\n            for i in exc.errors():\n                error_param_list.extend(i[\"loc\"])\n            self.write({\"code\": -1, \"msg\": f\"check error param: {error_param_list}\"})\n        elif isinstance(exc, exceptions.PaitBaseException):\n            self.write({\"code\": -1, \"msg\": str(exc)})\n\n        self.finish()\n\n\nclass DemoHandler(_Handler):\n    @pait()\n    async def get(self, demo_value: int = field.Query.i()) -&gt; None:\n        self.write({\"code\": 0, \"msg\": \"\", \"data\": demo_value})\n\n\napp: Application = Application([(r\"/api/demo\", DemoHandler)])\nAddDocRoute(app)\n\n\nif __name__ == \"__main__\":\n    app.listen(8000)\n    IOLoop.instance().start()\n</code></pre> <p>The exception handling of the <code>api_exception</code> function in the sample code is arranged in a strict order. It is generally recommended to handle exceptions in this order.</p> <p>The first highlighted code of the <code>api_exception</code> function is to extract the original exception of <code>TipException</code>. All subsequent exception handling is for the original exception, so it has the highest priority. The second highlighted code is to handle all <code>Pait</code> parameter exceptions. It will extract parameter information and error information and inform the user which parameter has an error. The third highlighted code handles the verification exception of <code>Pydantic</code>. It will parse the exception and return the parameter information that failed the verification. The fourth piece of code handles all exceptions of <code>Pait</code>, which usually occur rarely. The last step is to handle exceptions in other situations, which may be exceptions defined by the business system.</p> <p>The last highlighted code is to mount the custom <code>api_exception</code> function into the framework's exception handling callback through the exception mechanism of the Web framework.</p> <p>Note</p> <p><code>Tornado</code>'s exception handling is implemented in <code>RequestHandler</code>.</p> <p>After running the code and calling the <code>curl</code> command can know:</p> <ul> <li>When parameters are missing, an error message indicating that the parameter cannot be found will be returned.     <pre><code>\u279c  ~ curl \"http://127.0.0.1:8000/api/demo\"\n{\"code\":-1,\"msg\":\"error param:demo_value, Can not found demo_value value\"}\n</code></pre></li> <li>When parameter verification fails, the parameter name with verification error will be returned.     <pre><code>\u279c  ~ curl \"http://127.0.0.1:8000/api/demo?demo_value=a\"\n{\"code\":-1,\"msg\":\"check error param: ['demo_value']\"}\n</code></pre></li> <li>Normal data is returned when the parameters are normal.     <pre><code>\u279c  ~ curl \"http://127.0.0.1:8000/api/demo?demo_value=3\"\n{\"code\":0,\"msg\":\"\",\"data\":3}\n</code></pre></li> </ul> <p>Protocol description</p> <p>The response of the sample code uses common front-end and back-end interaction protocols: <pre><code>{\n  \"code\": 0,  # When it is 0, it means the response is normal, if it is not 0, it means it is abnormal.\n  \"msg\": \"\",  # It is an error message when there is an exception, and it is empty when it is normal.\n  \"data\": {}  # Response Data\n}\n</code></pre></p>"},{"location":"1_5_exception/#22custom-tipexception","title":"2.2.Custom TipException","text":"<p>The TipExceptions are enabled by default. If you think that error prompts will consume performance or want to turn off it, can define the <code>tip_exception_class</code> attribute of <code>ParamHandler</code> as <code>None</code> to turn off exception prompts. code show as below:</p> FlaskStarletteSanicTornado docs_source_code/introduction/exception/flask_with_not_tip_exception_demo.py<pre><code>from typing import List\n\nfrom flask import Flask, Response, jsonify\nfrom pydantic import ValidationError\n\nfrom pait import exceptions, field\nfrom pait.app.flask import pait\nfrom pait.param_handle import ParamHandler\n\n\nclass NotTipParamHandler(ParamHandler):\n    tip_exception_class = None\n\n\ndef api_exception(exc: Exception) -&gt; Response:\n    if isinstance(exc, exceptions.PaitBaseParamException):\n        return jsonify({\"code\": -1, \"msg\": f\"error param:{exc.param}, {exc.msg}\"})\n    elif isinstance(exc, ValidationError):\n        error_param_list: List = []\n        for i in exc.errors():\n            error_param_list.extend(i[\"loc\"])\n        return jsonify({\"code\": -1, \"msg\": f\"check error param: {error_param_list}\"})\n    elif isinstance(exc, exceptions.PaitBaseException):\n        return jsonify({\"code\": -1, \"msg\": str(exc)})\n\n    return jsonify({\"code\": -1, \"msg\": str(exc)})\n\n\n@pait(param_handler_plugin=NotTipParamHandler)\ndef demo(demo_value: int = field.Query.i()) -&gt; Response:\n    return jsonify({\"code\": 0, \"msg\": \"\", \"data\": demo_value})\n\n\napp = Flask(\"demo\")\napp.add_url_rule(\"/api/demo\", view_func=demo, methods=[\"GET\"])\napp.errorhandler(Exception)(api_exception)\n\n\nif __name__ == \"__main__\":\n    app.run(port=8000)\n</code></pre> docs_source_code/introduction/exception/starlette_with_not_tip_exception_demo.py<pre><code>from typing import List\n\nfrom pydantic import ValidationError\nfrom starlette.applications import Starlette\nfrom starlette.requests import Request\nfrom starlette.responses import JSONResponse\nfrom starlette.routing import Route\n\nfrom pait import exceptions, field\nfrom pait.app.starlette import pait\nfrom pait.param_handle import AsyncParamHandler\n\n\nclass NotTipAsyncParamHandler(AsyncParamHandler):\n    tip_exception_class = None\n\n\nasync def api_exception(request: Request, exc: Exception) -&gt; JSONResponse:\n    if isinstance(exc, exceptions.PaitBaseParamException):\n        return JSONResponse({\"code\": -1, \"msg\": f\"error param:{exc.param}, {exc.msg}\"})\n    elif isinstance(exc, ValidationError):\n        error_param_list: List = []\n        for i in exc.errors():\n            error_param_list.extend(i[\"loc\"])\n        return JSONResponse({\"code\": -1, \"msg\": f\"check error param: {error_param_list}\"})\n    elif isinstance(exc, exceptions.PaitBaseException):\n        return JSONResponse({\"code\": -1, \"msg\": str(exc)})\n\n    return JSONResponse({\"code\": -1, \"msg\": str(exc)})\n\n\n@pait(param_handler_plugin=NotTipAsyncParamHandler)\nasync def demo(demo_value: int = field.Query.i()) -&gt; JSONResponse:\n    return JSONResponse({\"code\": 0, \"msg\": \"\", \"data\": demo_value})\n\n\napp = Starlette(routes=[Route(\"/api/demo\", demo, methods=[\"GET\"])])\napp.add_exception_handler(Exception, api_exception)\n\n\nif __name__ == \"__main__\":\n    import uvicorn\n\n    uvicorn.run(app)\n</code></pre> docs_source_code/introduction/exception/sanic_with_not_tip_exception_demo.py<pre><code>from typing import List\n\nfrom pydantic import ValidationError\nfrom sanic import HTTPResponse, Request, Sanic, json\n\nfrom pait import exceptions, field\nfrom pait.app.sanic import pait\nfrom pait.param_handle import AsyncParamHandler\n\n\nclass NotTipAsyncParamHandler(AsyncParamHandler):\n    tip_exception_class = None\n\n\nasync def api_exception(request: Request, exc: Exception) -&gt; HTTPResponse:\n    if isinstance(exc, exceptions.PaitBaseParamException):\n        return json({\"code\": -1, \"msg\": f\"error param:{exc.param}, {exc.msg}\"})\n    elif isinstance(exc, ValidationError):\n        error_param_list: List = []\n        for i in exc.errors():\n            error_param_list.extend(i[\"loc\"])\n        return json({\"code\": -1, \"msg\": f\"check error param: {error_param_list}\"})\n    elif isinstance(exc, exceptions.PaitBaseException):\n        return json({\"code\": -1, \"msg\": str(exc)})\n\n    return json({\"code\": -1, \"msg\": str(exc)})\n\n\n@pait(param_handler_plugin=NotTipAsyncParamHandler)\nasync def demo(demo_value: int = field.Query.i()) -&gt; HTTPResponse:\n    return json({\"code\": 0, \"msg\": \"\", \"data\": demo_value})\n\n\napp = Sanic(\"demo\")\napp.add_route(demo, \"/api/demo\", methods={\"GET\"})\napp.exception(Exception)(api_exception)\n\n\nif __name__ == \"__main__\":\n    import uvicorn\n\n    uvicorn.run(app)\n</code></pre> docs_source_code/introduction/exception/tornado_with_not_tip_exception_demo.py<pre><code>from typing import List\n\nfrom pydantic import ValidationError\nfrom tornado.ioloop import IOLoop\nfrom tornado.web import Application, RequestHandler\n\nfrom pait import exceptions, field\nfrom pait.app.tornado import pait\nfrom pait.openapi.doc_route import AddDocRoute\nfrom pait.param_handle import AsyncParamHandler\n\n\nclass NotTipAsyncParamHandler(AsyncParamHandler):\n    tip_exception_class = None\n\n\nclass _Handler(RequestHandler):\n    def _handle_request_exception(self, exc: BaseException) -&gt; None:\n        if isinstance(exc, exceptions.PaitBaseParamException):\n            self.write({\"code\": -1, \"msg\": f\"error param:{exc.param}, {exc.msg}\"})\n        elif isinstance(exc, ValidationError):\n            error_param_list: List = []\n            for i in exc.errors():\n                error_param_list.extend(i[\"loc\"])\n            self.write({\"code\": -1, \"msg\": f\"check error param: {error_param_list}\"})\n        elif isinstance(exc, exceptions.PaitBaseException):\n            self.write({\"code\": -1, \"msg\": str(exc)})\n\n        self.finish()\n\n\nclass DemoHandler(_Handler):\n    @pait(param_handler_plugin=NotTipAsyncParamHandler)\n    async def get(self, demo_value: int = field.Query.i()) -&gt; None:\n        self.write({\"code\": 0, \"msg\": \"\", \"data\": demo_value})\n\n\napp: Application = Application([(r\"/api/demo\", DemoHandler)])\nAddDocRoute(app)\n\n\nif __name__ == \"__main__\":\n    app.listen(8000)\n    IOLoop.instance().start()\n</code></pre> <p>The sample code has a total of three modifications:     - The <code>NotTipParamHandler</code> in the first highlighted code is inherited from <code>ParamHandler</code> (or <code>AsyncParamHandler</code>),         which turns off exception tip by setting the <code>tip_exception_class</code> attribute to empty.     - The second piece of highlighting code removes the <code>TipException</code> extraction logic from the <code>api_exception</code> function, as it is not needed now.     - The third piece of highlighted code defines the <code>ParamHandler</code> used by the current route function to be a <code>NotTipParamHandler</code> via the <code>param_handler_plugin</code> property of <code>Pait</code>.</p> <p>After running the code and calling the <code>curl</code> command can know:</p> <ul> <li>When parameters are missing, an error message that the parameter cannot be found will be returned.     <pre><code>\u279c  ~ curl \"http://127.0.0.1:8000/api/demo\"\n{\"code\":-1,\"msg\":\"error param:demo_value, Can not found demo_value value\"}\n</code></pre></li> <li>When parameter verification fails, the parameter name with verification error will be returned.     <pre><code>\u279c  ~ curl \"http://127.0.0.1:8000/api/demo?demo_value=a\"\n{\"code\":-1,\"msg\":\"check error param: ['demo_value']\"}\n</code></pre></li> <li>Normal data is returned when the parameters are normal.     <pre><code>\u279c  ~ curl \"http://127.0.0.1:8000/api/demo?demo_value=3\"\n{\"code\":0,\"msg\":\"\",\"data\":3}\n</code></pre></li> </ul>"},{"location":"2_how_to_use_pait/","title":"How to use Pait decorator","text":"<p>In the process of using <code>Pait</code>, may find that multiple route functions use the same parameter configuration, as shown in the following code: <pre><code>from pait.app.any import pait\nfrom pait.model.status import PaitStatus\n\n@pait(status=PaitStatus.test)\ndef demo1() -&gt; None:\n    pass\n\n\n@pait(status=PaitStatus.test)\ndef demo2() -&gt; None:\n    pass\n\n@pait(status=PaitStatus.test)\ndef demo3() -&gt; None:\n    pass\n</code></pre> There are 3 route functions in the sample code, and since they are still in the testing phase, the value of their <code>status</code> is <code>PaitStatus.test</code>. After a period of testing, the code has become complete and ready to be released, the status of the route functions needs to be changed to <code>Relese</code>, so each route function has to be manually changed to <code>PaitStatus.test</code>. When there are a lot of route functions, manually switching the <code>status</code> of each of them can be very cumbersome. For this reason, it is possible to define a common <code>Pait</code> and use it for all route functions, so that these route functions can share the same <code>Pait</code> and thus the same configuration functionality.</p> <p>Note</p> <ul> <li>1.The examples provided in this section are based on the <code>Starlette</code> framework, while other frameworks differ only in the <code>import</code> statement for importing the <code>Pait</code> class.</li> <li>2.This section focuses on the usage of the <code>Pait</code> class. The role of different properties is described in the corresponding documentation.</li> <li>3.<code>Pait</code> can be thought of as a container for hosted data; as long as their properties are consistent, then their functionality is the same, even if there is no relationship between them.</li> </ul>"},{"location":"2_how_to_use_pait/#1custom-pait","title":"1.Custom Pait","text":"<p>In the previous introduction to <code>Pait</code>, <code>Pait</code> is imported through the following syntax: <pre><code>from pait.app.flask import pait\nfrom pait.app.sanic import pait\nfrom pait.app.starlette import pait\nfrom pait.app.tornado import pait\n</code></pre></p> <p>Imported <code>pait</code> is a single instance of each Web framework corresponding to the <code>Pait</code> class, in the customization of <code>Pait</code>, it is recommended to start through the Web framework corresponding to the <code>Pait</code> class, such as the following sample code: <pre><code>from pait.app.starlette import Pait\nfrom pait.model.status import PaitStatus\nfrom starlette.responses import Response\n\n\nglobal_pait: Pait = Pait(status=PaitStatus.test)\n\n@global_pait()\nasync def demo() -&gt; Response:\n    pass\n\n\n@global_pait()\nasync def demo1() -&gt; Response:\n    pass\n\n\n@global_pait()\nasync def demo2() -&gt; Response:\n    pass\n</code></pre> The sample code of the first highlighting code is based on <code>Pait</code> class to create a <code>Pait</code> instance called <code>global_pait</code>, it is similar to the framework corresponding <code>pait</code> instance, the only difference is that its <code>status</code> attribute is specified as <code>PaitStatus.test</code>. The other highlighted code applies <code>global_pait</code> to all route functions, and the <code>status</code> of the route function is the same as the <code>status</code> of the code below: <pre><code>@pait(status=PaitStatus.test)\nasync def demo() -&gt; Response:\n    pass\n</code></pre></p>"},{"location":"2_how_to_use_pait/#2create-child-pait","title":"2.Create child Pait","text":"<p>A <code>Pait</code> can create its own child <code>Pait</code> through the <code>create_sub_pait</code> method, and each child <code>Pait</code>'s attributes are cloned from the parent <code>Pait</code>, as in the following code: <pre><code>from pait.app.starlette import Pait\nfrom pait.model.status import PaitStatus\n\nglobal_pait: Pait = Pait(status=PaitStatus.test)\nother_pait: Pait = global_pait.create_sub_pait()\n</code></pre> In the sample code, <code>other_pait</code> is created by <code>global_pait</code>, so its <code>status</code> attribute is the same as <code>global_pait</code>.</p> <p>If you don't want to clone the attributes of the parent <code>Pait</code>, then you can override the attributes of the parent <code>Pait</code> by specifying the attributes of the child <code>Pait</code> when creating the child <code>Pait</code>, as in the following code: <pre><code>from pait.app.starlette import Pait\n\nglobal_pait: Pait = Pait(author=(\"so1n\",), group=\"global\")\nuser_pait: Pait = global_pait.create_sub_pait(group=\"user\")\n</code></pre></p> <p>The <code>author</code> attribute of both <code>global_pait</code> and <code>user_pait</code> is <code>(\"so1n\", )</code>. However, since the value of <code>group</code> was specified as <code>user</code> when <code>user_pait</code> was created, the <code>group</code> attributes of <code>global_pait</code> and <code>user_pait</code> are different, they are <code>global</code> and <code>user</code>.</p>"},{"location":"2_how_to_use_pait/#3use-of-pait","title":"3.Use of Pait","text":"<p>The usage of the sub <code>Pait</code> is identical to that of the standard <code>pait</code> decorator, the only difference being that it already carries some of the configuration data on its own, and after decorating the route function, it will cause the route function to have the corresponding configuration functionality. The following code: <pre><code>from pait.app.starlette import Pait\nfrom starlette.responses import JSONResponse\n\nglobal_pait: Pait = Pait(author=(\"so1n\",), group=\"global\")\nuser_pait: Pait = global_pait.create_sub_pait(group=\"user\")\n\n\n@user_pait()  # group=\"user\"\nasync def user_login() -&gt; JSONResponse:\n    pass\n\n@user_pait()  # group=\"user\"\nasync def user_logout() -&gt; JSONResponse:\n    pass\n\n@global_pait()  # group=\"global\"\nasync def get_server_timestamp() -&gt; JSONResponse:\n    pass\n</code></pre> The route functions <code>user_login</code> and <code>user_logout</code> are both decorated by <code>user_pait</code>, so the value of their <code>group</code> is <code>user</code>; And the route function <code>get_server_timestamp</code> is decorated by <code>global_pait</code>, so the value of <code>group</code> is <code>global</code>.</p> <p>In addition, it is possible to overwrite the original attribute values of the child <code>pait</code> when the child <code>pait</code> decorates the route function. As in the following code, the <code>group</code> attribute of <code>user_logout</code> of the route function in the highlighted code changes to <code>user-logout</code> and no longer to <code>user</code>: <pre><code>from pait.app.starlette import Pait\nfrom starlette.responses import JSONResponse\n\nglobal_pait: Pait = Pait(author=(\"so1n\",), group=\"global\")\nuser_pait: Pait = global_pait.create_sub_pait(group=\"user\")\n\n\n@user_pait()\nasync def user_login() -&gt; JSONResponse:\n    pass\n\n@user_pait(group=\"user-logout\")\nasync def user_logout() -&gt; JSONResponse:\n    pass\n\n@global_pait()\nasync def get_server_timestamp() -&gt; JSONResponse:\n    pass\n</code></pre></p> <p>In addition to overwriting the original value, some attributes also support appending values, as shown in the following code: <pre><code>from pait.app.starlette import Pait\nfrom starlette.responses import JSONResponse\n\nglobal_pait: Pait = Pait(author=(\"so1n\",), group=\"global\")\nuser_pait: Pait = global_pait.create_sub_pait(group=\"user\")\n\n\n@user_pait()  # group=\"user\"\nasync def user_login() -&gt; JSONResponse:\n    pass\n\n\n@user_pait(append_author=(\"Other Author\",))  # group=\"user\"; author=(\"so1n\", \"Other Author\",)\nasync def user_logout() -&gt; JSONResponse:\n    pass\n\n\n@global_pait()  # group=\"global\"\nasync def get_server_timestamp() -&gt; JSONResponse:\n    pass\n</code></pre> The highlighted portion of the code uses the <code>append_xxx</code> family of <code>Pait</code> parameters to append the value so that the <code>author</code> value of <code>user_logout</code> becomes <code>(\"so1n\", \"Other Author\")</code>.</p> <p>Note</p> <p>The appended value will only be added to the end of the sequence, while some functions such as <code>Pre-Depend</code> need to consider the order in which the values are placed, so please pay attention to whether the appending order is appropriate or not when use it.</p>"},{"location":"3_1_openapi/","title":"OpenAPI","text":""},{"location":"3_1_openapi/#1introduction","title":"1.Introduction","text":"<p><code>Pait</code> in addition to parameter type conversion and checking, but also supports the automatic generation of route function OpenAPI data. You only need to write the code of the route function, <code>Pait</code> can generate the corresponding OpenAPI documentation of the route function, such as Documentation Home of the sample code:</p> FlaskStarletteSanicTornado docs_source_code/introduction/flask_demo.py<pre><code>from typing import Type\n\nfrom flask import Flask, Response, jsonify\nfrom pydantic import BaseModel, Field\n\nfrom pait.app.flask import pait\nfrom pait.field import Json\nfrom pait.model.response import JsonResponseModel\nfrom pait.openapi.doc_route import AddDocRoute\n\n\nclass DemoResponseModel(JsonResponseModel):\n    class ResponseModel(BaseModel):\n        uid: int = Field()\n        user_name: str = Field()\n\n    description: str = \"demo response\"\n    response_data: Type[BaseModel] = ResponseModel\n\n\n@pait(response_model_list=[DemoResponseModel])\ndef demo_post(\n    uid: int = Json.t(description=\"user id\", gt=10, lt=1000),\n    username: str = Json.t(description=\"user name\", min_length=2, max_length=4),\n) -&gt; Response:\n    return jsonify({\"uid\": uid, \"user_name\": username})\n\n\napp = Flask(\"demo\")\napp.add_url_rule(\"/api\", \"demo\", demo_post, methods=[\"POST\"])\nAddDocRoute(app)\n\n\nif __name__ == \"__main__\":\n    app.run(port=8000)\n</code></pre> docs_source_code/introduction/starlette_demo.py<pre><code>from typing import Type\n\nfrom pydantic import BaseModel, Field\nfrom starlette.applications import Starlette\nfrom starlette.responses import JSONResponse\nfrom starlette.routing import Route\n\nfrom pait.app.starlette import pait\nfrom pait.field import Json\nfrom pait.model.response import JsonResponseModel\nfrom pait.openapi.doc_route import AddDocRoute\n\n\nclass DemoResponseModel(JsonResponseModel):\n    class ResponseModel(BaseModel):\n        uid: int = Field()\n        user_name: str = Field()\n\n    description: str = \"demo response\"\n    response_data: Type[BaseModel] = ResponseModel\n\n\n@pait(response_model_list=[DemoResponseModel])\nasync def demo_post(\n    uid: int = Json.t(description=\"user id\", gt=10, lt=1000),\n    username: str = Json.t(description=\"user name\", min_length=2, max_length=4),\n) -&gt; JSONResponse:\n    return JSONResponse({\"uid\": uid, \"user_name\": username})\n\n\napp = Starlette(routes=[Route(\"/api\", demo_post, methods=[\"POST\"])])\nAddDocRoute(app)\n\n\nif __name__ == \"__main__\":\n    import uvicorn\n\n    uvicorn.run(app)\n</code></pre> docs_source_code/introduction/sanic_demo.py<pre><code>from typing import Type\n\nfrom pydantic import BaseModel, Field\nfrom sanic.app import Sanic\nfrom sanic.response import HTTPResponse, json\n\nfrom pait.app.sanic import pait\nfrom pait.field import Json\nfrom pait.model.response import JsonResponseModel\nfrom pait.openapi.doc_route import AddDocRoute\n\n\nclass DemoResponseModel(JsonResponseModel):\n    class ResponseModel(BaseModel):\n        uid: int = Field()\n        user_name: str = Field()\n\n    description: str = \"demo response\"\n    response_data: Type[BaseModel] = ResponseModel\n\n\n@pait(response_model_list=[DemoResponseModel])\nasync def demo_post(\n    uid: int = Json.t(description=\"user id\", gt=10, lt=1000),\n    username: str = Json.t(description=\"user name\", min_length=2, max_length=4),\n) -&gt; HTTPResponse:\n    return json({\"uid\": uid, \"user_name\": username})\n\n\napp = Sanic(name=\"demo\")\napp.add_route(demo_post, \"/api\", methods=[\"POST\"])\nAddDocRoute(app)\n\n\nif __name__ == \"__main__\":\n    import uvicorn\n\n    uvicorn.run(app)\n</code></pre> docs_source_code/introduction/tornado_demo.py<pre><code>from typing import Type\n\nfrom pydantic import BaseModel, Field\nfrom tornado.ioloop import IOLoop\nfrom tornado.web import Application, RequestHandler\n\nfrom pait.app.tornado import pait\nfrom pait.field import Json\nfrom pait.model.response import JsonResponseModel\nfrom pait.openapi.doc_route import AddDocRoute\n\n\nclass DemoResponseModel(JsonResponseModel):\n    class ResponseModel(BaseModel):\n        uid: int = Field()\n        user_name: str = Field()\n\n    description: str = \"demo response\"\n    response_data: Type[BaseModel] = ResponseModel\n\n\nclass DemoHandler(RequestHandler):\n    @pait(response_model_list=[DemoResponseModel])\n    def post(\n        self,\n        uid: int = Json.t(description=\"user id\", gt=10, lt=1000),\n        username: str = Json.t(description=\"user name\", min_length=2, max_length=4),\n    ) -&gt; None:\n        self.write({\"uid\": uid, \"user_name\": username})\n\n\napp: Application = Application([(r\"/api\", DemoHandler)])\nAddDocRoute(app)\n\n\nif __name__ == \"__main__\":\n    app.listen(8000)\n    IOLoop.instance().start()\n</code></pre> <p>After running the code and visiting: http://127.0.0.1:8000/swagger in your browser you can see the SwaggerUI page: </p> <p>As you can see through the page, the data displayed on the Swagger page includes the data of the response object, the data labeled by the <code>Pait</code> decorator, and the parameters of the route function.</p>"},{"location":"3_1_openapi/#2openapi-properties-of-route-functions","title":"2.OpenAPI properties of route functions","text":"<p>Binding OpenAPI attributes to a route function is very simple, just need to fill in the <code>Pait</code> decorator with the corresponding attributes. Common route function attribute bindings are in the following code: <pre><code>from pait.app.any import pait\nfrom pait.model.tag import Tag\n\ndemo_tag = Tag(\"demo tag\", desc=\"demo tag desc\")\n\n\n@pait(\n    desc=\"demo func desc\",\n    name=\"demo\",\n    summary=\"demo func summary\",\n    tag=(demo_tag,)\n)\ndef demo() -&gt; None:\n    pass\n</code></pre> The OpenAPI information for the route function is specified through the <code>Pait</code> attributes, which do the following:</p> Attributes OpenAPI Attributes Description desc description Documentation of the interface in detail name operation_id The name of the interface summary summary Brief description of the interface tag tag The OpenAPI tag of the interface <p>Note</p> <ul> <li>1.In most cases, the <code>name</code> attribute is just part of the <code>operation_id</code> attribute and <code>Pait</code> does not guarantee that <code>name</code> is exactly equal to <code>operation_id</code>.</li> <li>2.Tag should be guaranteed to be globally unique</li> </ul> <p>However, the <code>name</code> and <code>desc</code> attributes can also be obtained from the route function name and the <code>__doc__</code> of the route function For example, the <code>name</code> and <code>desc</code> attributes of the route function in the following code are consistent with the code above: <pre><code>from pait.app.any import pait\nfrom pait.model.tag import Tag\n\ndemo_tag = Tag(\"demo tag\", desc=\"demo tag desc\")\n\n\n@pait(\n    summary=\"demo func summary\",\n    tag=(demo_tag,)\n)\ndef demo() -&gt; None:\n    \"\"\"demo func desc\"\"\"\n    pass\n</code></pre></p> <p>In addition to the above attributes, OpenAPI has an attribute called <code>deprecated</code>, which is primarily used to mark whether an interface has been deprecated. <code>Pait</code> does not directly support the marking of the <code>deprecated</code> attribute, but instead determines whether the <code>deprecated</code> of a route function is <code>True</code> by using <code>PaitStatus</code>, which is very simple to use, as in the following code: <pre><code>from pait.app.any import pait\nfrom pait.model.status import PaitStatus\n\n\n@pait(status=PaitStatus.test)\ndef demo() -&gt; None:\n    pass\n</code></pre> This code indicates that the route function is under test and <code>deprecated</code> is <code>False</code>, for more statuses and whether it is <code>deprecated</code> or not see the following table.</p> status value stage deprecated description undefined default <code>False</code> undefined, default status design development <code>False</code> design dev development <code>False</code> development and testing integration_testing development <code>False</code> integration testing complete development complete <code>False</code> development complete test development complete <code>False</code> testing pre_release release <code>False</code> pre release release release <code>False</code> release abnormal offline <code>True</code> Temporary offline maintenance offline <code>False</code> Maintenance archive offline <code>True</code> archive abandoned offline <code>True</code> abandoned, will not be used again"},{"location":"3_1_openapi/#3the-response-object-of-the-route-function","title":"3.The response object of the route function","text":"<p>In the previous introduction, a list of response objects for a route function is defined via <code>response_model_list</code>, which contains one or more response objects.</p> <p>Note</p> <p>It is recommended to use only one response object, if there is more than one, most non-OpenAPI feature(e.g. plugins) will default to using only the first response object.</p> <p><code>Pait</code> provides a variety of response objects, as listed below:</p> Response Object Name Description JsonResponseModel Object whose response is Json XmlResponseModel Object whose response is Xml TextResponseModel Objects whose response is text HtmlResponseModel Objects whose response is Html FileResponseModel Objects whose response is  File <p><code>Pait</code> only provides response objects for common response types, if there is no applicable response object, can define a response object that meets the requirements through <code>pait.model.response.BaseResponseModel</code>. which is a container for the different properties of the OpenAPI response object, as follows.</p> Attribute Name Description response_data Define the response data, if it is response data with a structure then it should be a <code>pydantic.BaseModel</code> describing the structure media_type The <code>Media Type</code> of the response object name The name of the response object. description The description of the response object header The header of the response object, the value should be <code>pydantic.BaseModel</code> not <code>Dict</code> status_code The Http status code of the response object, defaults to <code>(200, )</code> openapi_schema The openapi.schema of the response object <p>Most response objects can be defined through these properties. The sample code is as follows:</p> FlaskStarletteSanicTornado docs_source_code/openapi/how_to_use_openapi/flask_demo.py<pre><code>from typing import List\n\nfrom flask import Flask, Response, jsonify\nfrom pydantic import BaseModel, Field\n\nfrom pait.app.flask import pait\nfrom pait.field import Query\nfrom pait.model.response import BaseResponseModel\nfrom pait.openapi.doc_route import AddDocRoute\n\n\nclass MyJsonResponseModel(BaseResponseModel):\n    class ResponseModel(BaseModel):\n        class UserModel(BaseModel):\n            name: str = Field(..., example=\"so1n\")\n            uid: int = Query.t(description=\"user id\", gt=10, lt=1000)\n            age: int = Field(..., gt=0)\n\n        code: int = Field(..., ge=0)\n        msg: str = Field(...)\n        data: List[UserModel]\n\n    class HeaderModel(BaseModel):\n        x_token: str = Field(..., alias=\"X-Token\")\n        content_type: str = Field(..., alias=\"Content-Type\")\n\n    response_data = ResponseModel\n    description = \"demo json response\"\n    media_type = \"application/json; charset=utf-8\"\n    header = HeaderModel\n    status_code = (200, 201, 404)\n\n\n@pait(response_model_list=[MyJsonResponseModel])\ndef demo(\n    uid: int = Query.t(description=\"user id\", gt=10, lt=1000),\n    age: int = Query.t(description=\"age\", gt=0),\n    username: str = Query.t(description=\"user name\", min_length=2, max_length=4),\n) -&gt; Response:\n    resp = jsonify({\"code\": 0, \"msg\": \"\", \"data\": [{\"name\": username, \"uid\": uid, \"age\": age}]})\n    resp.headers.add(\"X-Token\", \"12345\")\n    resp.headers[\"Content-Type\"] = \"application/json; charset=utf-8\"\n    return resp\n\n\napp = Flask(\"demo\")\napp.add_url_rule(\"/api/demo\", \"demo\", demo, methods=[\"GET\"])\nAddDocRoute(app)\n\n\nif __name__ == \"__main__\":\n    app.run(port=8000)\n</code></pre> docs_source_code/openapi/how_to_use_openapi/starlette_demo.py<pre><code>from typing import List\n\nfrom pydantic import BaseModel, Field\nfrom starlette.applications import Starlette\nfrom starlette.responses import JSONResponse\nfrom starlette.routing import Route\n\nfrom pait.app.starlette import pait\nfrom pait.field import Query\nfrom pait.model.response import BaseResponseModel\nfrom pait.openapi.doc_route import AddDocRoute\n\n\nclass MyJsonResponseModel(BaseResponseModel):\n    class ResponseModel(BaseModel):\n        class UserModel(BaseModel):\n            name: str = Field(..., example=\"so1n\")\n            uid: int = Query.t(description=\"user id\", gt=10, lt=1000)\n            age: int = Field(..., gt=0)\n\n        code: int = Field(..., ge=0)\n        msg: str = Field(...)\n        data: List[UserModel]\n\n    class HeaderModel(BaseModel):\n        x_token: str = Field(..., alias=\"X-Token\")\n        content_type: str = Field(..., alias=\"Content-Type\")\n\n    response_data = ResponseModel\n    description = \"demo json response\"\n    media_type = \"application/json; charset=utf-8\"\n    header = HeaderModel\n    status_code = (200, 201, 404)\n\n\n@pait(response_model_list=[MyJsonResponseModel])\nasync def demo(\n    uid: int = Query.t(description=\"user id\", gt=10, lt=1000),\n    age: int = Query.t(description=\"age\", gt=0),\n    username: str = Query.t(description=\"user name\", min_length=2, max_length=4),\n) -&gt; JSONResponse:\n    resp = JSONResponse({\"code\": 0, \"msg\": \"\", \"data\": [{\"name\": username, \"uid\": uid, \"age\": age}]})\n    resp.headers.append(\"X-Token\", \"12345\")\n    resp.headers[\"Content-Type\"] = \"application/json; charset=utf-8\"\n    return resp\n\n\napp = Starlette(routes=[Route(\"/api/demo\", demo, methods=[\"GET\"])])\nAddDocRoute(app)\n\n\nif __name__ == \"__main__\":\n    import uvicorn\n\n    uvicorn.run(app)\n</code></pre> docs_source_code/openapi/how_to_use_openapi/sanic_demo.py<pre><code>from typing import List\n\nfrom pydantic import BaseModel, Field\nfrom sanic.app import Sanic\nfrom sanic.response import HTTPResponse, json\n\nfrom pait.app.sanic import pait\nfrom pait.field import Query\nfrom pait.model.response import BaseResponseModel\nfrom pait.openapi.doc_route import AddDocRoute\n\n\nclass MyJsonResponseModel(BaseResponseModel):\n    class ResponseModel(BaseModel):\n        class UserModel(BaseModel):\n            name: str = Field(..., example=\"so1n\")\n            uid: int = Query.t(description=\"user id\", gt=10, lt=1000)\n            age: int = Field(..., gt=0)\n\n        code: int = Field(..., ge=0)\n        msg: str = Field(...)\n        data: List[UserModel]\n\n    class HeaderModel(BaseModel):\n        x_token: str = Field(..., alias=\"X-Token\")\n        content_type: str = Field(..., alias=\"Content-Type\")\n\n    response_data = ResponseModel\n    description = \"demo json response\"\n    media_type = \"application/json; charset=utf-8\"\n    header = HeaderModel\n    status_code = (200, 201, 404)\n\n\n@pait(response_model_list=[MyJsonResponseModel])\nasync def demo(\n    uid: int = Query.t(description=\"user id\", gt=10, lt=1000),\n    age: int = Query.t(description=\"age\", gt=0),\n    username: str = Query.t(description=\"user name\", min_length=2, max_length=4),\n) -&gt; HTTPResponse:\n    resp = json({\"code\": 0, \"msg\": \"\", \"data\": [{\"name\": username, \"uid\": uid, \"age\": age}]})\n\n    resp.headers.add(\"X-Token\", \"12345\")\n    resp.headers[\"Content-Type\"] = \"application/json; charset=utf-8\"\n    return resp\n\n\napp = Sanic(name=\"demo\")\napp.add_route(demo, \"/api/demo\", methods=[\"GET\"])\nAddDocRoute(app)\n\n\nif __name__ == \"__main__\":\n    import uvicorn\n\n    uvicorn.run(app)\n</code></pre> docs_source_code/openapi/how_to_use_openapi/tornado_demo.py<pre><code>from typing import List\n\nfrom pydantic import BaseModel, Field\nfrom tornado.ioloop import IOLoop\nfrom tornado.web import Application, RequestHandler\n\nfrom pait.app.tornado import pait\nfrom pait.field import Query\nfrom pait.model.response import BaseResponseModel\nfrom pait.openapi.doc_route import AddDocRoute\n\n\nclass MyJsonResponseModel(BaseResponseModel):\n    class ResponseModel(BaseModel):\n        class UserModel(BaseModel):\n            name: str = Field(..., example=\"so1n\")\n            uid: int = Query.t(description=\"user id\", gt=10, lt=1000)\n            age: int = Field(..., gt=0)\n\n        code: int = Field(..., ge=0)\n        msg: str = Field(...)\n        data: List[UserModel]\n\n    class HeaderModel(BaseModel):\n        x_token: str = Field(..., alias=\"X-Token\")\n        content_type: str = Field(..., alias=\"Content-Type\")\n\n    response_data = ResponseModel\n    description = \"demo json response\"\n    media_type = \"application/json; charset=utf-8\"\n    header = HeaderModel\n    status_code = (200, 201, 404)\n\n\nclass DemoHandler(RequestHandler):\n    @pait(response_model_list=[MyJsonResponseModel])\n    def get(\n        self,\n        uid: int = Query.t(description=\"user id\", gt=10, lt=1000),\n        age: int = Query.t(description=\"age\", gt=0),\n        username: str = Query.t(description=\"user name\", min_length=2, max_length=4),\n    ) -&gt; None:\n        self.write({\"code\": 0, \"msg\": \"\", \"data\": [{\"name\": username, \"uid\": uid, \"age\": age}]})\n        self.add_header(\"X-Token\", \"12345\")\n        self.set_header(\"Content-Type\", \"application/json; charset=utf-8\")\n\n\napp: Application = Application([(r\"/api/demo\", DemoHandler)])\nAddDocRoute(app)\n\n\nif __name__ == \"__main__\":\n    app.listen(8000)\n    IOLoop.instance().start()\n</code></pre> <p>The first highlighted code is a response object which indicates that the Http status codes may be 200, 201 and 404. The <code>Media Type</code> is <code>application/json</code>. The Header has properties <code>X-Token</code> and <code>Content-Type</code>. And most importantly, the data structure of the response body is defined as follows: <pre><code>{\n  \"code\": 0,\n  \"msg\": \"\",\n  \"data\": [\n    {\n      \"name\": \"so1n\",\n      \"sex\": \"man\",\n      \"age\": 18\n    }\n  ]\n}\n</code></pre> The second highlighted code binds the response object to the route function. Now run the code and visit 127.0.0.1:8000/redoc in your browser, you can see that the current page displays the OpenAPI data of the route function in full, as follows </p> <p>Note</p> <p>Since <code>Redoc</code> presents data in a much more parsimonious way than <code>Swagger</code>, this case uses <code>Redoc</code> to present data. In fact <code>Pait</code> supports a variety of OpenAPI UI pages, see OpenAPI routes for details:.</p>"},{"location":"3_1_openapi/#4field","title":"4.Field","text":"<p>The page in the previous section contains not only the data of the response object, but also the data of the request parameters. such as the <code>uid</code> parameter, which is declared as <code>required</code> and is also declared to be of type <code>integer</code> with a value in the range of 10-1000.</p> <p>These request parameters are declared through <code>Field</code> objects, which not only validate the parameters but also provide data for OpenAPI. In addition to this, the <code>Field</code> object has some properties that are specialized for <code>OpenAPI</code>, they include:</p> Attributes description links OpenAPI link function, used to specify parameters associated with a response object media_type Defines the <code>Media Type</code> of a parameter, currently only <code>Body</code>, <code>Json</code>, <code>File</code>, <code>Form</code>, <code>MultiForm</code> are used, it is recommended to use only one <code>Media Type</code> for an route function. openapi_serialization Define the <code>serialization</code> of the parameters, please refer to serialization example Define an example value for the parameter; <code>Pait</code> supports factory functions, but converting to OpenAPI will result in a fixed value generated in the moment openapi_include If the value is <code>False</code>, <code>Pait</code> will not consider this parameter when generating the Open API"},{"location":"3_1_openapi/#41links","title":"4.1.Links","text":"<p>Links is a feature of OpenAPI that is used to specify that a request parameter from interface A is associated with a piece of data in the response object from interface B. For example:</p> FlaskStarletteSanicTornado docs_source_code/openapi/how_to_use_openapi/flask_link_demo.py<pre><code>import hashlib\nfrom typing import Type\n\nfrom flask import Flask\nfrom pydantic import BaseModel, Field\n\nfrom pait import field\nfrom pait.app.flask import pait\nfrom pait.model.response import JsonResponseModel\nfrom pait.openapi.doc_route import AddDocRoute\nfrom pait.openapi.openapi import LinksModel\n\n\nclass LoginRespModel(JsonResponseModel):\n    class ResponseModel(BaseModel):  # type: ignore\n        class DataModel(BaseModel):\n            token: str\n\n        code: int = Field(0, description=\"api code\")\n        msg: str = Field(\"success\", description=\"api status msg\")\n        data: DataModel\n\n    description: str = \"login response\"\n    response_data: Type[BaseModel] = ResponseModel\n\n\nlink_login_token_model: LinksModel = LinksModel(LoginRespModel, \"$response.body#/data/token\", desc=\"test links model\")\n\n\n@pait(response_model_list=[LoginRespModel])\ndef login_route(\n    uid: str = field.Json.i(description=\"user id\"), password: str = field.Json.i(description=\"password\")\n) -&gt; dict:\n    return {\"code\": 0, \"msg\": \"\", \"data\": {\"token\": hashlib.sha256((uid + password).encode(\"utf-8\")).hexdigest()}}\n\n\n@pait()\ndef get_user_route(token: str = field.Header.i(\"\", description=\"token\", links=link_login_token_model)) -&gt; dict:\n    if token:\n        return {\"code\": 0, \"msg\": \"\"}\n    else:\n        return {\"code\": 1, \"msg\": \"\"}\n\n\napp = Flask(\"demo\")\napp.add_url_rule(\"/api/login\", \"login\", login_route, methods=[\"POST\"])\napp.add_url_rule(\"/api/get-user-info\", \"get_user_info\", get_user_route, methods=[\"GET\"])\nAddDocRoute(app)\n\n\nif __name__ == \"__main__\":\n    app.run(port=8000)\n</code></pre> docs_source_code/openapi/how_to_use_openapi/starlette_link_demo.py<pre><code>import hashlib\nfrom typing import Type\n\nfrom pydantic import BaseModel, Field\nfrom starlette.applications import Starlette\nfrom starlette.responses import JSONResponse\nfrom starlette.routing import Route\n\nfrom pait import field\nfrom pait.app.starlette import pait\nfrom pait.model.response import JsonResponseModel\nfrom pait.openapi.doc_route import AddDocRoute\nfrom pait.openapi.openapi import LinksModel\n\n\nclass LoginRespModel(JsonResponseModel):\n    class ResponseModel(BaseModel):  # type: ignore\n        class DataModel(BaseModel):\n            token: str\n\n        code: int = Field(0, description=\"api code\")\n        msg: str = Field(\"success\", description=\"api status msg\")\n        data: DataModel\n\n    description: str = \"login response\"\n    response_data: Type[BaseModel] = ResponseModel\n\n\nlink_login_token_model: LinksModel = LinksModel(LoginRespModel, \"$response.body#/data/token\", desc=\"test links model\")\n\n\n@pait(response_model_list=[LoginRespModel])\nasync def login_route(\n    uid: str = field.Json.i(description=\"user id\"), password: str = field.Json.i(description=\"password\")\n) -&gt; JSONResponse:\n    return JSONResponse(\n        {\"code\": 0, \"msg\": \"\", \"data\": {\"token\": hashlib.sha256((uid + password).encode(\"utf-8\")).hexdigest()}}\n    )\n\n\n@pait()\nasync def get_user_route(\n    token: str = field.Header.i(\n        \"\",\n        description=\"token\",\n        links=link_login_token_model,\n    )\n) -&gt; JSONResponse:\n    if token:\n        return JSONResponse({\"code\": 0, \"msg\": \"\"})\n    else:\n        return JSONResponse({\"code\": 1, \"msg\": \"\"})\n\n\napp = Starlette(\n    routes=[\n        Route(\"/api/login\", login_route, methods=[\"POST\"]),\n        Route(\"/api/get-user-info\", get_user_route, methods=[\"GET\"]),\n    ]\n)\nAddDocRoute(app)\n\n\nif __name__ == \"__main__\":\n    import uvicorn\n\n    uvicorn.run(app)\n</code></pre> docs_source_code/openapi/how_to_use_openapi/sanic_link_demo.py<pre><code>import hashlib\nfrom typing import Type\n\nfrom pydantic import BaseModel, Field\nfrom sanic.app import Sanic\nfrom sanic.response import HTTPResponse, json\n\nfrom pait import field\nfrom pait.app.sanic import pait\nfrom pait.model.response import JsonResponseModel\nfrom pait.openapi.doc_route import AddDocRoute\nfrom pait.openapi.openapi import LinksModel\n\n\nclass LoginRespModel(JsonResponseModel):\n    class ResponseModel(BaseModel):  # type: ignore\n        class DataModel(BaseModel):\n            token: str\n\n        code: int = Field(0, description=\"api code\")\n        msg: str = Field(\"success\", description=\"api status msg\")\n        data: DataModel\n\n    description: str = \"login response\"\n    response_data: Type[BaseModel] = ResponseModel\n\n\nlink_login_token_model: LinksModel = LinksModel(LoginRespModel, \"$response.body#/data/token\", desc=\"test links model\")\n\n\n@pait(response_model_list=[LoginRespModel])\nasync def login_route(\n    uid: str = field.Json.i(description=\"user id\"), password: str = field.Json.i(description=\"password\")\n) -&gt; HTTPResponse:\n    return json({\"code\": 0, \"msg\": \"\", \"data\": {\"token\": hashlib.sha256((uid + password).encode(\"utf-8\")).hexdigest()}})\n\n\n@pait()\ndef get_user_route(\n    token: str = field.Header.i(\n        \"\",\n        description=\"token\",\n        links=link_login_token_model,\n    )\n) -&gt; HTTPResponse:\n    if token:\n        return json({\"code\": 0, \"msg\": \"\"})\n    else:\n        return json({\"code\": 1, \"msg\": \"\"})\n\n\napp = Sanic(name=\"demo\")\napp.add_route(login_route, \"/api/login\", methods=[\"POST\"])\napp.add_route(get_user_route, \"/api/get-user-info\", methods=[\"GET\"])\nAddDocRoute(app)\n\n\nif __name__ == \"__main__\":\n    import uvicorn\n\n    uvicorn.run(app)\n</code></pre> docs_source_code/openapi/how_to_use_openapi/tornado_link_demo.py<pre><code>import hashlib\nfrom typing import Type\n\nfrom pydantic import BaseModel, Field\nfrom tornado.ioloop import IOLoop\nfrom tornado.web import Application, RequestHandler\n\nfrom pait import field\nfrom pait.app.tornado import pait\nfrom pait.model.response import JsonResponseModel\nfrom pait.openapi.doc_route import AddDocRoute\nfrom pait.openapi.openapi import LinksModel\n\n\nclass LoginRespModel(JsonResponseModel):\n    class ResponseModel(BaseModel):  # type: ignore\n        class DataModel(BaseModel):\n            token: str\n\n        code: int = Field(0, description=\"api code\")\n        msg: str = Field(\"success\", description=\"api status msg\")\n        data: DataModel\n\n    description: str = \"login response\"\n    response_data: Type[BaseModel] = ResponseModel\n\n\nlink_login_token_model: LinksModel = LinksModel(LoginRespModel, \"$response.body#/data/token\", desc=\"test links model\")\n\n\nclass LoginHandler(RequestHandler):\n    @pait(response_model_list=[LoginRespModel])\n    async def post(\n        self, uid: str = field.Json.i(description=\"user id\"), password: str = field.Json.i(description=\"password\")\n    ) -&gt; None:\n        self.write(\n            {\"code\": 0, \"msg\": \"\", \"data\": {\"token\": hashlib.sha256((uid + password).encode(\"utf-8\")).hexdigest()}}\n        )\n\n\nclass GetUserHandler(RequestHandler):\n    @pait()\n    def get(\n        self,\n        token: str = field.Header.i(\n            \"\",\n            description=\"token\",\n            links=link_login_token_model,\n        ),\n    ) -&gt; None:\n        if token:\n            self.write({\"code\": 0, \"msg\": \"\"})\n        else:\n            self.write({\"code\": 1, \"msg\": \"\"})\n\n\napp: Application = Application(\n    [(r\"/api/login\", LoginHandler), (r\"/api/get-user-info\", GetUserHandler)],\n)\nAddDocRoute(app)\n\n\nif __name__ == \"__main__\":\n    app.listen(8000)\n    IOLoop.instance().start()\n</code></pre> <p>This example defines a login route function--<code>login_route</code> and a route function to get user details -- <code>get_user_route</code>. The route function to get the user details needs a token parameter to verify the user and get the user id, which is generated by the login route function, so the token parameter of the user details route function is related to the token in the response data of the login route function.</p> <p>In order for OpenAPI to recognize that the token parameter is associated with a token in the response object. First create an instance named <code>link_login_token_model</code> that is bound to the <code>LoginRespModel</code> response object and indicates the parameter to be bound by the expression <code>$response.body#/data/token\"</code>. Then the <code>link_login_token_model</code> is assigned to the <code>links</code> attribute of the <code>Field</code> of the <code>token</code> in the <code>get_user_route</code> route function, and this completes the association once.</p> <p>After running the code and visiting http://127.0.0.1:8000/swagger in your browser you will see the following page:  can see through the page that the <code>Response</code> column of the login interface shows the <code>Links</code> data on the far right.</p> <p>Note</p> <p>Currently, many OpenAPI tools only provide simple Links support. For more information on the use and description of Links, see Swagger Links.</p>"},{"location":"3_1_openapi/#5openapi-generation","title":"5.OpenAPI generation","text":"<p>In the OpenAPI ecosystem, at its core is a piece of OpenAPI-conforming json or yaml text, which can be used in OpenAPI pages such as Swagger, or imported for use in tools such as Postman. <code>Pait</code> will delegate the collected data to AnyAPI to be processed and generate an OpenAPI object, which supports being converted into a variety of human-readable text or pages.</p> <p>Note</p> <p>AnyAPI is separated from <code>Pait</code> and is currently for <code>Pait</code> use only, more features will be added to AnyAPI in subsequent releases.</p> <p>The following is an example of generating an OpenAPI object and generating output content based on the OpenAPI object:</p> FlaskStarletteSanicTornado docs_source_code/openapi/how_to_use_openapi/flask_with_output_demo.py<pre><code>from typing import Any, Type\n\nfrom any_api.openapi.to.markdown import Markdown\nfrom flask import Flask, Response, jsonify\nfrom pydantic import BaseModel, Field\n\nfrom pait.app.flask import pait\nfrom pait.field import Json\nfrom pait.g import config\nfrom pait.model.response import JsonResponseModel\nfrom pait.openapi.openapi import OpenAPI\n\n\nclass DemoResponseModel(JsonResponseModel):\n    class ResponseModel(BaseModel):\n        uid: int = Field()\n        user_name: str = Field()\n\n    description: str = \"demo response\"\n    response_data: Type[BaseModel] = ResponseModel\n\n\n@pait(response_model_list=[DemoResponseModel])\ndef demo_post(\n    uid: int = Json.t(description=\"user id\", gt=10, lt=1000),\n    username: str = Json.t(description=\"user name\", min_length=2, max_length=4),\n) -&gt; Response:\n    return jsonify({\"uid\": uid, \"user_name\": username})\n\n\napp = Flask(\"demo\")\napp.add_url_rule(\"/api\", \"demo\", demo_post, methods=[\"POST\"])\n\n\ndef my_serialization(content: str, **kwargs: Any) -&gt; str:\n    import json\n\n    import yaml  # type: ignore\n\n    return yaml.dump(json.loads(json.dumps(content, cls=config.json_encoder), **kwargs))\n\n\nopenapi_model = OpenAPI(app)\n\nprint(\"json\", openapi_model.content())\nprint(\"yaml\", openapi_model.content(serialization_callback=my_serialization))\nfor i18n_lang in (\"zh-cn\", \"en\"):\n    print(f\"{i18n_lang} md\", Markdown(openapi_model, i18n_lang=i18n_lang).content)\n</code></pre> docs_source_code/openapi/how_to_use_openapi/starlette_with_output_demo.py<pre><code>from typing import Any, List\n\nfrom any_api.openapi.to.markdown import Markdown\nfrom pydantic import BaseModel, Field\nfrom starlette.applications import Starlette\nfrom starlette.responses import JSONResponse\nfrom starlette.routing import Route\n\nfrom pait.app.starlette import pait\nfrom pait.field import Query\nfrom pait.g import config\nfrom pait.model.response import BaseResponseModel\nfrom pait.openapi.openapi import OpenAPI\n\n\nclass MyJsonResponseModel(BaseResponseModel):\n    class ResponseModel(BaseModel):\n        class UserModel(BaseModel):\n            name: str = Field(..., example=\"so1n\")\n            uid: int = Query.t(description=\"user id\", gt=10, lt=1000)\n            age: int = Field(..., gt=0)\n\n        code: int = Field(..., ge=0)\n        msg: str = Field(...)\n        data: List[UserModel]\n\n    class HeaderModel(BaseModel):\n        x_token: str = Field(..., alias=\"X-Token\")\n        content_type: str = Field(..., alias=\"Content-Type\")\n\n    response_data = ResponseModel\n    description = \"demo json response\"\n    media_type = \"application/json; charset=utf-8\"\n    header = HeaderModel\n    status_code = (200, 201, 404)\n\n\n@pait(response_model_list=[MyJsonResponseModel])\nasync def demo(\n    uid: int = Query.t(description=\"user id\", gt=10, lt=1000),\n    age: int = Query.t(description=\"age\", gt=0),\n    username: str = Query.t(description=\"user name\", min_length=2, max_length=4),\n) -&gt; JSONResponse:\n    resp = JSONResponse({\"code\": 0, \"msg\": \"\", \"data\": [{\"name\": username, \"uid\": uid, \"age\": age}]})\n    resp.headers.append(\"X-Token\", \"12345\")\n    resp.headers[\"Content-Type\"] = \"application/json; charset=utf-8\"\n    return resp\n\n\napp = Starlette(routes=[Route(\"/api/demo\", demo, methods=[\"GET\"])])\n\n\ndef my_serialization(content: str, **kwargs: Any) -&gt; str:\n    import json\n\n    import yaml  # type: ignore\n\n    return yaml.dump(json.loads(json.dumps(content, cls=config.json_encoder), **kwargs))\n\n\nopenapi_model = OpenAPI(app)\n\nprint(\"json\", openapi_model.content())\nprint(\"yaml\", openapi_model.content(serialization_callback=my_serialization))\nfor i18n_lang in (\"zh-cn\", \"en\"):\n    print(f\"{i18n_lang} md\", Markdown(openapi_model, i18n_lang=i18n_lang).content)\n</code></pre> docs_source_code/openapi/how_to_use_openapi/sanic_with_output_demo.py<pre><code>from typing import Any, List\n\nfrom any_api.openapi.to.markdown import Markdown\nfrom pydantic import BaseModel, Field\nfrom sanic.app import Sanic\nfrom sanic.response import HTTPResponse, json\n\nfrom pait.app.sanic import pait\nfrom pait.field import Query\nfrom pait.g import config\nfrom pait.model.response import BaseResponseModel\nfrom pait.openapi.openapi import OpenAPI\n\n\nclass MyJsonResponseModel(BaseResponseModel):\n    class ResponseModel(BaseModel):\n        class UserModel(BaseModel):\n            name: str = Field(..., example=\"so1n\")\n            uid: int = Query.t(description=\"user id\", gt=10, lt=1000)\n            age: int = Field(..., gt=0)\n\n        code: int = Field(..., ge=0)\n        msg: str = Field(...)\n        data: List[UserModel]\n\n    class HeaderModel(BaseModel):\n        x_token: str = Field(..., alias=\"X-Token\")\n        content_type: str = Field(..., alias=\"Content-Type\")\n\n    response_data = ResponseModel\n    description = \"demo json response\"\n    media_type = \"application/json; charset=utf-8\"\n    header = HeaderModel\n    status_code = (200, 201, 404)\n\n\n@pait(response_model_list=[MyJsonResponseModel])\nasync def demo(\n    uid: int = Query.t(description=\"user id\", gt=10, lt=1000),\n    age: int = Query.t(description=\"age\", gt=0),\n    username: str = Query.t(description=\"user name\", min_length=2, max_length=4),\n) -&gt; HTTPResponse:\n    resp = json({\"code\": 0, \"msg\": \"\", \"data\": [{\"name\": username, \"uid\": uid, \"age\": age}]})\n\n    resp.headers.add(\"X-Token\", \"12345\")\n    resp.headers[\"Content-Type\"] = \"application/json; charset=utf-8\"\n    return resp\n\n\napp = Sanic(name=\"demo\")\napp.add_route(demo, \"/api/demo\", methods=[\"GET\"])\n\n\ndef my_serialization(content: str, **kwargs: Any) -&gt; str:\n    import json\n\n    import yaml  # type: ignore\n\n    return yaml.dump(json.loads(json.dumps(content, cls=config.json_encoder), **kwargs))\n\n\nopenapi_model = OpenAPI(app)\n\nprint(\"json\", openapi_model.content())\nprint(\"yaml\", openapi_model.content(serialization_callback=my_serialization))\nfor i18n_lang in (\"zh-cn\", \"en\"):\n    print(f\"{i18n_lang} md\", Markdown(openapi_model, i18n_lang=i18n_lang).content)\n</code></pre> docs_source_code/openapi/how_to_use_openapi/tornado_with_output_demo.py<pre><code>from typing import Any, List\n\nfrom any_api.openapi.to.markdown import Markdown\nfrom pydantic import BaseModel, Field\nfrom tornado.web import Application, RequestHandler\n\nfrom pait.app.tornado import pait\nfrom pait.field import Query\nfrom pait.g import config\nfrom pait.model.response import BaseResponseModel\nfrom pait.openapi.openapi import OpenAPI\n\n\nclass MyJsonResponseModel(BaseResponseModel):\n    class ResponseModel(BaseModel):\n        class UserModel(BaseModel):\n            name: str = Field(..., example=\"so1n\")\n            uid: int = Query.t(description=\"user id\", gt=10, lt=1000)\n            age: int = Field(..., gt=0)\n\n        code: int = Field(..., ge=0)\n        msg: str = Field(...)\n        data: List[UserModel]\n\n    class HeaderModel(BaseModel):\n        x_token: str = Field(..., alias=\"X-Token\")\n        content_type: str = Field(..., alias=\"Content-Type\")\n\n    response_data = ResponseModel\n    description = \"demo json response\"\n    media_type = \"application/json; charset=utf-8\"\n    header = HeaderModel\n    status_code = (200, 201, 404)\n\n\nclass DemoHandler(RequestHandler):\n    @pait(response_model_list=[MyJsonResponseModel])\n    def get(\n        self,\n        uid: int = Query.t(description=\"user id\", gt=10, lt=1000),\n        age: int = Query.t(description=\"age\", gt=0),\n        username: str = Query.t(description=\"user name\", min_length=2, max_length=4),\n    ) -&gt; None:\n        self.write({\"code\": 0, \"msg\": \"\", \"data\": [{\"name\": username, \"uid\": uid, \"age\": age}]})\n        self.add_header(\"X-Token\", \"12345\")\n        self.set_header(\"Content-Type\", \"application/json; charset=utf-8\")\n\n\napp: Application = Application([(r\"/api/demo\", DemoHandler)])\n\n\ndef my_serialization(content: str, **kwargs: Any) -&gt; str:\n    import json\n\n    import yaml  # type: ignore\n\n    return yaml.dump(json.loads(json.dumps(content, cls=config.json_encoder), **kwargs))\n\n\nopenapi_model = OpenAPI(app)\n\nprint(\"json\", openapi_model.content())\nprint(\"yaml\", openapi_model.content(serialization_callback=my_serialization))\nfor i18n_lang in (\"zh-cn\", \"en\"):\n    print(f\"{i18n_lang} md\", Markdown(openapi_model, i18n_lang=i18n_lang).content)\n</code></pre> <p>The first step in the sample code is to create <code>openapi_model</code>, which in the process of creation will get the <code>app</code> corresponding interface and data. The second step is to call the <code>content</code> method of <code>openapi_model</code>, which has a <code>serialization_callback</code> parameter with a default value of <code>json.dump</code>. So a direct call to <code>openapi_model.content()</code> will generate the following JSON text.</p> Json example (the example text is long, please open it as needed) <pre><code>{\n  \"openapi\": \"3.0.0\",\n  \"info\": {\n    \"title\": \"AnyApi\",\n    \"description\": \"API Documentation\",\n    \"version\": \"0.0.1\"\n  },\n  \"servers\": [],\n  \"paths\": {\n    \"/api\": {\n      \"options\": {\n        \"tags\": [\n          \"default\"\n        ],\n        \"summary\": \"\",\n        \"description\": \"\",\n        \"operationId\": \"demo_options\",\n        \"parameters\": [],\n        \"requestBody\": {\n          \"description\": \"\",\n          \"required\": false,\n          \"content\": {\n            \"application/json\": {\n              \"schema\": {\n                \"$ref\": \"#/components/schemas/Demo_Post__Main___Demo_Post\"\n              }\n            }\n          }\n        },\n        \"responses\": {\n          \"200\": {\n            \"description\": \"demo response\",\n            \"content\": {\n              \"application/json\": {\n                \"schema\": {\n                  \"$ref\": \"#/components/schemas/ResponseModel\"\n                }\n              }\n            }\n          }\n        },\n        \"deprecated\": false,\n        \"pait_info\": {\n          \"group\": \"root\",\n          \"status\": \"undefined\",\n          \"author\": [\n            \"\"\n          ],\n          \"pait_id\": \"__main___demo_post\"\n        }\n      },\n      \"post\": {\n        \"tags\": [\n          \"default\"\n        ],\n        \"summary\": \"\",\n        \"description\": \"\",\n        \"operationId\": \"demo_post\",\n        \"parameters\": [],\n        \"requestBody\": {\n          \"description\": \"\",\n          \"required\": false,\n          \"content\": {\n            \"application/json\": {\n              \"schema\": {\n                \"$ref\": \"#/components/schemas/Demo_Post__Main___Demo_Post\"\n              }\n            }\n          }\n        },\n        \"responses\": {\n          \"200\": {\n            \"description\": \"demo response\",\n            \"content\": {\n              \"application/json\": {\n                \"schema\": {\n                  \"$ref\": \"#/components/schemas/ResponseModel\"\n                }\n              }\n            }\n          }\n        },\n        \"deprecated\": false,\n        \"pait_info\": {\n          \"group\": \"root\",\n          \"status\": \"undefined\",\n          \"author\": [\n            \"\"\n          ],\n          \"pait_id\": \"__main___demo_post\"\n        }\n      }\n    }\n  },\n  \"tags\": [\n    {\n      \"name\": \"default\",\n      \"description\": \"\"\n    }\n  ],\n  \"components\": {\n    \"schemas\": {\n      \"Demo_Post__Main___Demo_Post\": {\n        \"title\": \"Demo_Post__Main___Demo_Post\",\n        \"type\": \"object\",\n        \"properties\": {\n          \"uid\": {\n            \"title\": \"Uid\",\n            \"description\": \"user id\",\n            \"exclusiveMinimum\": 10,\n            \"exclusiveMaximum\": 1000,\n            \"type\": \"integer\"\n          },\n          \"username\": {\n            \"title\": \"Username\",\n            \"description\": \"user name\",\n            \"maxLength\": 4,\n            \"minLength\": 2,\n            \"type\": \"string\"\n          }\n        },\n        \"required\": [\n          \"uid\",\n          \"username\"\n        ]\n      },\n      \"ResponseModel\": {\n        \"title\": \"ResponseModel\",\n        \"type\": \"object\",\n        \"properties\": {\n          \"uid\": {\n            \"title\": \"Uid\",\n            \"type\": \"integer\"\n          },\n          \"user_name\": {\n            \"title\": \"User Name\",\n            \"type\": \"string\"\n          }\n        },\n        \"required\": [\n          \"uid\",\n          \"user_name\"\n        ]\n      }\n    }\n  }\n}\n</code></pre> <p>In addition, the sample code also customizes a function that serializes to yaml -- <code>my_serialization</code> and generates the following yaml text via <code>openapi_model.content(serialization_callback=my_serialization)</code>:</p> Yaml example (the example text is long, please open it as needed) <pre><code>components:\n  schemas:\n    Demo_Post__Main___Demo_Post:\n      properties:\n        uid:\n          description: user id\n          exclusiveMaximum: 1000\n          exclusiveMinimum: 10\n          title: Uid\n          type: integer\n        username:\n          description: user name\n          maxLength: 4\n          minLength: 2\n          title: Username\n          type: string\n      required:\n      - uid\n      - username\n      title: Demo_Post__Main___Demo_Post\n      type: object\n    ResponseModel:\n      properties:\n        uid:\n          title: Uid\n          type: integer\n        user_name:\n          title: User Name\n          type: string\n      required:\n      - uid\n      - user_name\n      title: ResponseModel\n      type: object\ninfo:\n  description: API Documentation\n  title: AnyApi\n  version: 0.0.1\nopenapi: 3.0.0\npaths:\n  /api:\n    options:\n      deprecated: false\n      description: ''\n      operationId: demo_options\n      pait_info:\n        author:\n        - ''\n        group: root\n        pait_id: __main___demo_post\n        status: undefined\n      parameters: []\n      requestBody:\n        content:\n          application/json:\n            schema:\n              $ref: '#/components/schemas/Demo_Post__Main___Demo_Post'\n        description: ''\n        required: false\n      responses:\n        '200':\n          content:\n            application/json:\n              schema:\n                $ref: '#/components/schemas/ResponseModel'\n          description: demo response\n      summary: ''\n      tags:\n      - default\n    post:\n      deprecated: false\n      description: ''\n      operationId: demo_post\n      pait_info:\n        author:\n        - ''\n        group: root\n        pait_id: __main___demo_post\n        status: undefined\n      parameters: []\n      requestBody:\n        content:\n          application/json:\n            schema:\n              $ref: '#/components/schemas/Demo_Post__Main___Demo_Post'\n        description: ''\n        required: false\n      responses:\n        '200':\n          content:\n            application/json:\n              schema:\n                $ref: '#/components/schemas/ResponseModel'\n          description: demo response\n      summary: ''\n      tags:\n      - default\nservers: []\ntags:\n- description: ''\n  name: default\n</code></pre> <p>Finally, the <code>Markdown</code> method of AnyAPI is also used to generate Markdown documents in different languages.</p> Chinese Markdown example(The sample text is long, please open it as needed, and only show the original data) <pre><code># AnyApi\n### \u540d\u79f0: demo.demo\n**\u6807\u7b7e**: default\n- \u8def\u5f84: /api/demo\n- \u65b9\u6cd5: get\n- \u8bf7\u6c42:\n    **query**\n\n     |\u540d\u79f0|\u9ed8\u8ba4|\u7c7b\u578b|\u63cf\u8ff0|\u793a\u4f8b|\u5176\u5b83|\n     |---|---|---|---|---|---|\n     |uid|`\u5fc5\u586b`|integer|user id||exclusiveMinimum:10;&lt;br&gt;exclusiveMaximum:1000|\n     |age|`\u5fc5\u586b`|integer|age||exclusiveMinimum:0|\n     |username|`\u5fc5\u586b`|string|user name||maxLength:4;&lt;br&gt;minLength:2|\n\n\n- \u54cd\u5e94\n**\u63cf\u8ff0**: demo json response\n*Header*\n\n    - 200:application/json; charset=utf-8\n    **\u54cd\u5e94\u4fe1\u606f**\n\n         |\u540d\u79f0|\u9ed8\u8ba4|\u7c7b\u578b|\u63cf\u8ff0|\u793a\u4f8b|\u5176\u5b83|\n         |---|---|---|---|---|---|\n         |code|`\u5fc5\u586b`|integer|||minimum:0|\n         |msg|`\u5fc5\u586b`|string||||\n         |data|`\u5fc5\u586b`|array|||items:{'$ref': '#/components/schemas/UserModel'}|\n\n        **\u54cd\u5e94\u793a\u4f8b**\n\n        ```json\n        {\n            \"code\": 0,\n            \"msg\": \"\",\n            \"data\": {\n                \"name\": \"so1n\",\n                \"uid\": 0,\n                \"age\": 0\n            }\n        }\n        ```\n**\u63cf\u8ff0**: demo json response\n*Header*\n\n    - 201:application/json; charset=utf-8\n    **\u54cd\u5e94\u4fe1\u606f**\n\n         |\u540d\u79f0|\u9ed8\u8ba4|\u7c7b\u578b|\u63cf\u8ff0|\u793a\u4f8b|\u5176\u5b83|\n         |---|---|---|---|---|---|\n         |code|`\u5fc5\u586b`|integer|||minimum:0|\n         |msg|`\u5fc5\u586b`|string||||\n         |data|`\u5fc5\u586b`|array|||items:{'$ref': '#/components/schemas/UserModel'}|\n\n        **\u54cd\u5e94\u793a\u4f8b**\n\n        ```json\n        {\n            \"code\": 0,\n            \"msg\": \"\",\n            \"data\": {\n                \"name\": \"so1n\",\n                \"uid\": 0,\n                \"age\": 0\n            }\n        }\n        ```\n**\u63cf\u8ff0**: demo json response\n*Header*\n\n    - 404:application/json; charset=utf-8\n    **\u54cd\u5e94\u4fe1\u606f**\n\n         |\u540d\u79f0|\u9ed8\u8ba4|\u7c7b\u578b|\u63cf\u8ff0|\u793a\u4f8b|\u5176\u5b83|\n         |---|---|---|---|---|---|\n         |code|`\u5fc5\u586b`|integer|||minimum:0|\n         |msg|`\u5fc5\u586b`|string||||\n         |data|`\u5fc5\u586b`|array|||items:{'$ref': '#/components/schemas/UserModel'}|\n\n        **\u54cd\u5e94\u793a\u4f8b**\n\n        ```json\n        {\n            \"code\": 0,\n            \"msg\": \"\",\n            \"data\": {\n                \"name\": \"so1n\",\n                \"uid\": 0,\n                \"age\": 0\n            }\n        }\n        ```\n</code></pre> English Markdown example (the sample text is long, please open it as needed, and only display the original data) <pre><code># AnyApi\n### Name: demo.demo\n**Tag**: default\n- Path: /api/demo\n- Method: get\n- Request:\n    **query**\n\n     |Name|Default|Type|Desc|Example|Other|\n     |---|---|---|---|---|---|\n     |uid|`Required`|integer|user id||exclusiveMinimum:10;&lt;br&gt;exclusiveMaximum:1000|\n     |age|`Required`|integer|age||exclusiveMinimum:0|\n     |username|`Required`|string|user name||maxLength:4;&lt;br&gt;minLength:2|\n\n\n- Response\n**Desc**: demo json response\n*Header*\n\n    - 200:application/json; charset=utf-8\n    **Response Info**\n\n         |Name|Default|Type|Desc|Example|Other|\n         |---|---|---|---|---|---|\n         |code|`Required`|integer|||minimum:0|\n         |msg|`Required`|string||||\n         |data|`Required`|array|||items:{'$ref': '#/components/schemas/UserModel'}|\n\n        **Response Example**\n\n        ```json\n        {\n            \"code\": 0,\n            \"msg\": \"\",\n            \"data\": {\n                \"name\": \"so1n\",\n                \"uid\": 0,\n                \"age\": 0\n            }\n        }\n        ```\n**Desc**: demo json response\n*Header*\n\n    - 201:application/json; charset=utf-8\n    **Response Info**\n\n         |Name|Default|Type|Desc|Example|Other|\n         |---|---|---|---|---|---|\n         |code|`Required`|integer|||minimum:0|\n         |msg|`Required`|string||||\n         |data|`Required`|array|||items:{'$ref': '#/components/schemas/UserModel'}|\n\n        **Response Example**\n\n        ```json\n        {\n            \"code\": 0,\n            \"msg\": \"\",\n            \"data\": {\n                \"name\": \"so1n\",\n                \"uid\": 0,\n                \"age\": 0\n            }\n        }\n        ```\n**Desc**: demo json response\n*Header*\n\n    - 404:application/json; charset=utf-8\n    **Response Info**\n\n         |Name|Default|Type|Desc|Example|Other|\n         |---|---|---|---|---|---|\n         |code|`Required`|integer|||minimum:0|\n         |msg|`Required`|string||||\n         |data|`Required`|array|||items:{'$ref': '#/components/schemas/UserModel'}|\n\n        **Response Example**\n\n        ```json\n        {\n            \"code\": 0,\n            \"msg\": \"\",\n            \"data\": {\n                \"name\": \"so1n\",\n                \"uid\": 0,\n                \"age\": 0\n            }\n        }\n        ```\n</code></pre>"},{"location":"3_2_openapi_route/","title":"OpenAPI Route","text":"<p><code>Pait</code> in addition to supporting the generation of OpenAPI content, but also supports OpenAPI route generation. by default, will provide <code>openapi.json</code> and some doc-ui route, such as the document home sample code.</p> FlaskStarletteSanicTornado docs_source_code/introduction/flask_demo.py<pre><code>from typing import Type\n\nfrom flask import Flask, Response, jsonify\nfrom pydantic import BaseModel, Field\n\nfrom pait.app.flask import pait\nfrom pait.field import Json\nfrom pait.model.response import JsonResponseModel\nfrom pait.openapi.doc_route import AddDocRoute\n\n\nclass DemoResponseModel(JsonResponseModel):\n    class ResponseModel(BaseModel):\n        uid: int = Field()\n        user_name: str = Field()\n\n    description: str = \"demo response\"\n    response_data: Type[BaseModel] = ResponseModel\n\n\n@pait(response_model_list=[DemoResponseModel])\ndef demo_post(\n    uid: int = Json.t(description=\"user id\", gt=10, lt=1000),\n    username: str = Json.t(description=\"user name\", min_length=2, max_length=4),\n) -&gt; Response:\n    return jsonify({\"uid\": uid, \"user_name\": username})\n\n\napp = Flask(\"demo\")\napp.add_url_rule(\"/api\", \"demo\", demo_post, methods=[\"POST\"])\nAddDocRoute(app)\n\n\nif __name__ == \"__main__\":\n    app.run(port=8000)\n</code></pre> docs_source_code/introduction/starlette_demo.py<pre><code>from typing import Type\n\nfrom pydantic import BaseModel, Field\nfrom starlette.applications import Starlette\nfrom starlette.responses import JSONResponse\nfrom starlette.routing import Route\n\nfrom pait.app.starlette import pait\nfrom pait.field import Json\nfrom pait.model.response import JsonResponseModel\nfrom pait.openapi.doc_route import AddDocRoute\n\n\nclass DemoResponseModel(JsonResponseModel):\n    class ResponseModel(BaseModel):\n        uid: int = Field()\n        user_name: str = Field()\n\n    description: str = \"demo response\"\n    response_data: Type[BaseModel] = ResponseModel\n\n\n@pait(response_model_list=[DemoResponseModel])\nasync def demo_post(\n    uid: int = Json.t(description=\"user id\", gt=10, lt=1000),\n    username: str = Json.t(description=\"user name\", min_length=2, max_length=4),\n) -&gt; JSONResponse:\n    return JSONResponse({\"uid\": uid, \"user_name\": username})\n\n\napp = Starlette(routes=[Route(\"/api\", demo_post, methods=[\"POST\"])])\nAddDocRoute(app)\n\n\nif __name__ == \"__main__\":\n    import uvicorn\n\n    uvicorn.run(app)\n</code></pre> docs_source_code/introduction/sanic_demo.py<pre><code>from typing import Type\n\nfrom pydantic import BaseModel, Field\nfrom sanic.app import Sanic\nfrom sanic.response import HTTPResponse, json\n\nfrom pait.app.sanic import pait\nfrom pait.field import Json\nfrom pait.model.response import JsonResponseModel\nfrom pait.openapi.doc_route import AddDocRoute\n\n\nclass DemoResponseModel(JsonResponseModel):\n    class ResponseModel(BaseModel):\n        uid: int = Field()\n        user_name: str = Field()\n\n    description: str = \"demo response\"\n    response_data: Type[BaseModel] = ResponseModel\n\n\n@pait(response_model_list=[DemoResponseModel])\nasync def demo_post(\n    uid: int = Json.t(description=\"user id\", gt=10, lt=1000),\n    username: str = Json.t(description=\"user name\", min_length=2, max_length=4),\n) -&gt; HTTPResponse:\n    return json({\"uid\": uid, \"user_name\": username})\n\n\napp = Sanic(name=\"demo\")\napp.add_route(demo_post, \"/api\", methods=[\"POST\"])\nAddDocRoute(app)\n\n\nif __name__ == \"__main__\":\n    import uvicorn\n\n    uvicorn.run(app)\n</code></pre> docs_source_code/introduction/tornado_demo.py<pre><code>from typing import Type\n\nfrom pydantic import BaseModel, Field\nfrom tornado.ioloop import IOLoop\nfrom tornado.web import Application, RequestHandler\n\nfrom pait.app.tornado import pait\nfrom pait.field import Json\nfrom pait.model.response import JsonResponseModel\nfrom pait.openapi.doc_route import AddDocRoute\n\n\nclass DemoResponseModel(JsonResponseModel):\n    class ResponseModel(BaseModel):\n        uid: int = Field()\n        user_name: str = Field()\n\n    description: str = \"demo response\"\n    response_data: Type[BaseModel] = ResponseModel\n\n\nclass DemoHandler(RequestHandler):\n    @pait(response_model_list=[DemoResponseModel])\n    def post(\n        self,\n        uid: int = Json.t(description=\"user id\", gt=10, lt=1000),\n        username: str = Json.t(description=\"user name\", min_length=2, max_length=4),\n    ) -&gt; None:\n        self.write({\"uid\": uid, \"user_name\": username})\n\n\napp: Application = Application([(r\"/api\", DemoHandler)])\nAddDocRoute(app)\n\n\nif __name__ == \"__main__\":\n    app.listen(8000)\n    IOLoop.instance().start()\n</code></pre> <p>Through the sample code can be seen, just simply call <code>AddDocRoute</code> can be <code>app</code> bound OpenAPI route, the specific route url and the corresponding function is shown in the table below:</p> route url description features /openapi.json Get OpenAPI's json response /elements Use elements to display document data UI is nice and simple, support request in page /redoc Use Redoc to display  document data UI is nice and simple, but does not support request in page /swagger Use Swagger to display document data Generic OpenAPI display UI, full-featured /rapidoc Use RapiDoc to display document data Fully featured; modernized UI; supports customized UI /rapipdf Provides a page where can download RapiDoc pdf documents Poor support for non-English"},{"location":"3_2_openapi_route/#1use-of-openapi-routing","title":"1.Use of OpenAPI routing","text":"<p><code>AddDocRoute</code> can easily bind OpenAPI routes to <code>app</code> instances, and <code>AddDocRoute</code> provides some parameters for developers to customize route extensions and to solve the complexity of production environments. Currently <code>AddDocRoute</code> provides the following parameters:</p> Parameters Description scheme HTTP Schema, such as http or https openapi_json_url_only_path Generated openapi.json url that owns the path portion (scheme fails when this parameter is in effect) prefix A prefix for routing URLs pin_code A simple security checksum title Defines the title of the OpenAPI route. Note that when calling <code>AddDocRoute</code> multiple times to bind different OpenAPI routes, their titles should different doc_fn_dict Implementation of UI pages in OpenAPI routes openapi <code>Pait</code>'s OpenAPI class pait <code>Pait</code> instances, OpenAPI will create child <code>pait</code> based on the this <code>pait</code> and use them. See how to use Pait add_multi_simple_route Methods for binding routes to app instances, see SimpleRoute section for details not_found_exc pin_code error exception"},{"location":"3_2_openapi_route/#11scheme","title":"1.1.scheme","text":"<p>The HTTP Schema of OpenAPI routing can be explicitly specified through the scheme parameter, such as HTTP and HTTPS.</p> <p>It is important to note that the HTTP Schema does not refer to the HTTP Schema used by the current service, but rather the HTTP Schema used by the visitor. For example, the current service specifies HTTP Schema, but in order to enhance the security of the service, Add a layer of proxy in front of the service to support HTTPS, such as using Nginx. In this case, the user can only access the service via <code>https://127.0.0.1/openapi.json</code>. In order for the OpenAPI route to respond properly, should use <code>scheme=\"https\"</code> when binding the OpenAPI route.</p> <p>The example code is as follows:</p> FlaskStarletteSanicTornado <pre><code>from typing import Type\n\nfrom flask import Flask, Response, jsonify\nfrom pydantic import BaseModel, Field\n\nfrom pait.app.flask import pait\nfrom pait.field import Json\nfrom pait.model.response import JsonResponseModel\nfrom pait.openapi.doc_route import AddDocRoute\n\n\nclass DemoResponseModel(JsonResponseModel):\n    class ResponseModel(BaseModel):\n        uid: int = Field()\n        user_name: str = Field()\n\n    description: str = \"demo response\"\n    response_data: Type[BaseModel] = ResponseModel\n\n\n@pait(response_model_list=[DemoResponseModel])\ndef demo_post(\n    uid: int = Json.t(description=\"user id\", gt=10, lt=1000),\n    username: str = Json.t(description=\"user name\", min_length=2, max_length=4),\n) -&gt; Response:\n    return jsonify({\"uid\": uid, \"user_name\": username})\n\n\napp = Flask(\"demo\")\nAddDocRoute(app, scheme=\"http\")\napp.run(port=8000)\n</code></pre> <pre><code>from typing import Type\n\nfrom pydantic import BaseModel, Field\nfrom starlette.applications import Starlette\nfrom starlette.responses import JSONResponse\nfrom starlette.routing import Route\n\nfrom pait.app.starlette import pait\nfrom pait.field import Json\nfrom pait.model.response import JsonResponseModel\nfrom pait.openapi.doc_route import AddDocRoute\n\n\nclass DemoResponseModel(JsonResponseModel):\n    class ResponseModel(BaseModel):\n        uid: int = Field()\n        user_name: str = Field()\n\n    description: str = \"demo response\"\n    response_data: Type[BaseModel] = ResponseModel\n\n\n@pait(response_model_list=[DemoResponseModel])\nasync def demo_post(\n    uid: int = Json.t(description=\"user id\", gt=10, lt=1000),\n    username: str = Json.t(description=\"user name\", min_length=2, max_length=4),\n) -&gt; JSONResponse:\n    return JSONResponse({\"uid\": uid, \"user_name\": username})\n\n\napp = Starlette(routes=[Route(\"/api\", demo_post, methods=[\"POST\"])])\nAddDocRoute(app, scheme=\"http\")\nuvicorn.run(app)\n</code></pre> <pre><code>from typing import Type\n\nfrom pydantic import BaseModel, Field\nfrom sanic.app import Sanic\nfrom sanic.response import HTTPResponse, json\n\nfrom pait.app.sanic import pait\nfrom pait.field import Json\nfrom pait.model.response import JsonResponseModel\nfrom pait.openapi.doc_route import AddDocRoute\n\n\nclass DemoResponseModel(JsonResponseModel):\n    class ResponseModel(BaseModel):\n        uid: int = Field()\n        user_name: str = Field()\n\n    description: str = \"demo response\"\n    response_data: Type[BaseModel] = ResponseModel\n\n\n@pait(response_model_list=[DemoResponseModel])\nasync def demo_post(\n    uid: int = Json.t(description=\"user id\", gt=10, lt=1000),\n    username: str = Json.t(description=\"user name\", min_length=2, max_length=4),\n) -&gt; HTTPResponse:\n    return json({\"uid\": uid, \"user_name\": username})\n\n\napp = Sanic(name=\"demo\")\napp.add_route(demo_post, \"/api\", methods=[\"POST\"])\nAddDocRoute(app, scheme=\"http\")\nuvicorn.run(app)\n</code></pre> <pre><code>from typing import Type\n\nfrom pydantic import BaseModel, Field\nfrom tornado.ioloop import IOLoop\nfrom tornado.web import Application, RequestHandler\n\nfrom pait.app.tornado import pait\nfrom pait.field import Json\nfrom pait.model.response import JsonResponseModel\nfrom pait.openapi.doc_route import AddDocRoute\n\n\nclass DemoResponseModel(JsonResponseModel):\n    class ResponseModel(BaseModel):\n        uid: int = Field()\n        user_name: str = Field()\n\n    description: str = \"demo response\"\n    response_data: Type[BaseModel] = ResponseModel\n\n\nclass DemoHandler(RequestHandler):\n    @pait(response_model_list=[DemoResponseModel])\n    def post(\n        self,\n        uid: int = Json.t(description=\"user id\", gt=10, lt=1000),\n        username: str = Json.t(description=\"user name\", min_length=2, max_length=4),\n    ) -&gt; None:\n        self.write({\"uid\": uid, \"user_name\": username})\n\n\nAddDocRoute(app, scheme=\"http\")\napp.listen(8000)\nIOLoop.instance().start()\n</code></pre>"},{"location":"3_2_openapi_route/#12openapi_json_url_only_path","title":"1.2.openapi_json_url_only_path","text":"<p>When openapi_json_url_only_path is <code>False</code> by default, the generated OpenAPI Json url is complete (<code>http://example.com/openapi.json</code>). When openapi_json_url_only_path is <code>True</code>, the generated OpenAPI Json url is <code>/openapi.json</code>.</p> <p>Note</p> <ul> <li>1.The current OpenAPI UIs all support <code>/openapi.json</code>, but there is no guarantee that subsequent OpenAPI UIs will support them.</li> <li>2.When using <code>openapi_json_url_only_path</code>, the <code>schema</code> parameter will be invalidated.</li> </ul> <p>The example code is as follows:</p> FlaskStarletteSanicTornado <pre><code>from typing import Type\n\nfrom flask import Flask, Response, jsonify\nfrom pydantic import BaseModel, Field\n\nfrom pait.app.flask import pait\nfrom pait.field import Json\nfrom pait.model.response import JsonResponseModel\nfrom pait.openapi.doc_route import AddDocRoute\n\n\nclass DemoResponseModel(JsonResponseModel):\n    class ResponseModel(BaseModel):\n        uid: int = Field()\n        user_name: str = Field()\n\n    description: str = \"demo response\"\n    response_data: Type[BaseModel] = ResponseModel\n\n\n@pait(response_model_list=[DemoResponseModel])\ndef demo_post(\n    uid: int = Json.t(description=\"user id\", gt=10, lt=1000),\n    username: str = Json.t(description=\"user name\", min_length=2, max_length=4),\n) -&gt; Response:\n    return jsonify({\"uid\": uid, \"user_name\": username})\n\n\napp = Flask(\"demo\")\nAddDocRoute(app, openapi_json_url_only_path=True)\napp.run(port=8000)\n</code></pre> <pre><code>from typing import Type\n\nfrom pydantic import BaseModel, Field\nfrom starlette.applications import Starlette\nfrom starlette.responses import JSONResponse\nfrom starlette.routing import Route\n\nfrom pait.app.starlette import pait\nfrom pait.field import Json\nfrom pait.model.response import JsonResponseModel\nfrom pait.openapi.doc_route import AddDocRoute\n\n\nclass DemoResponseModel(JsonResponseModel):\n    class ResponseModel(BaseModel):\n        uid: int = Field()\n        user_name: str = Field()\n\n    description: str = \"demo response\"\n    response_data: Type[BaseModel] = ResponseModel\n\n\n@pait(response_model_list=[DemoResponseModel])\nasync def demo_post(\n    uid: int = Json.t(description=\"user id\", gt=10, lt=1000),\n    username: str = Json.t(description=\"user name\", min_length=2, max_length=4),\n) -&gt; JSONResponse:\n    return JSONResponse({\"uid\": uid, \"user_name\": username})\n\n\napp = Starlette(routes=[Route(\"/api\", demo_post, methods=[\"POST\"])])\nAddDocRoute(app, openapi_json_url_only_path=True)\nuvicorn.run(app)\n</code></pre> <pre><code>from typing import Type\n\nfrom pydantic import BaseModel, Field\nfrom sanic.app import Sanic\nfrom sanic.response import HTTPResponse, json\n\nfrom pait.app.sanic import pait\nfrom pait.field import Json\nfrom pait.model.response import JsonResponseModel\nfrom pait.openapi.doc_route import AddDocRoute\n\n\nclass DemoResponseModel(JsonResponseModel):\n    class ResponseModel(BaseModel):\n        uid: int = Field()\n        user_name: str = Field()\n\n    description: str = \"demo response\"\n    response_data: Type[BaseModel] = ResponseModel\n\n\n@pait(response_model_list=[DemoResponseModel])\nasync def demo_post(\n    uid: int = Json.t(description=\"user id\", gt=10, lt=1000),\n    username: str = Json.t(description=\"user name\", min_length=2, max_length=4),\n) -&gt; HTTPResponse:\n    return json({\"uid\": uid, \"user_name\": username})\n\n\napp = Sanic(name=\"demo\")\napp.add_route(demo_post, \"/api\", methods=[\"POST\"])\nAddDocRoute(app, openapi_json_url_only_path=True)\nuvicorn.run(app)\n</code></pre> <pre><code>from typing import Type\n\nfrom pydantic import BaseModel, Field\nfrom tornado.ioloop import IOLoop\nfrom tornado.web import Application, RequestHandler\n\nfrom pait.app.tornado import pait\nfrom pait.field import Json\nfrom pait.model.response import JsonResponseModel\nfrom pait.openapi.doc_route import AddDocRoute\n\n\nclass DemoResponseModel(JsonResponseModel):\n    class ResponseModel(BaseModel):\n        uid: int = Field()\n        user_name: str = Field()\n\n    description: str = \"demo response\"\n    response_data: Type[BaseModel] = ResponseModel\n\n\nclass DemoHandler(RequestHandler):\n    @pait(response_model_list=[DemoResponseModel])\n    def post(\n        self,\n        uid: int = Json.t(description=\"user id\", gt=10, lt=1000),\n        username: str = Json.t(description=\"user name\", min_length=2, max_length=4),\n    ) -&gt; None:\n        self.write({\"uid\": uid, \"user_name\": username})\n\n\nAddDocRoute(app, openapi_json_url_only_path=True)\napp.listen(8000)\nIOLoop.instance().start()\n</code></pre>"},{"location":"3_2_openapi_route/#13prefix","title":"1.3.prefix","text":"<p>By default, <code>AddDocRoute</code> will bind the route to the app instance according to the following URL:</p> <ul> <li>/openapi.json</li> <li>/redoc</li> <li>/swagger</li> <li>/rapidoc</li> <li>/rapipdf</li> <li>/elements</li> </ul> <p>However, using the default <code>/</code> prefix is not a good behavior, and it is recommended to specify a URL prefix that matches your own habits via <code>prefix</code> when using it. For example <code>/api-doc</code>, then <code>AddDocRoute</code> will bind to the route with the following URL:</p> <ul> <li>/api-doc/openapi.json</li> <li>/api-doc/redoc</li> <li>/api-doc/swagger</li> <li>/api-doc/rapidoc</li> <li>/api-doc/rapipdf</li> <li>/api-doc/elements</li> </ul> <p>The example code is as follows:</p> FlaskStarletteSanicTornado <pre><code>from typing import Type\n\nfrom flask import Flask, Response, jsonify\nfrom pydantic import BaseModel, Field\n\nfrom pait.app.flask import pait\nfrom pait.field import Json\nfrom pait.model.response import JsonResponseModel\nfrom pait.openapi.doc_route import AddDocRoute\n\n\nclass DemoResponseModel(JsonResponseModel):\n    class ResponseModel(BaseModel):\n        uid: int = Field()\n        user_name: str = Field()\n\n    description: str = \"demo response\"\n    response_data: Type[BaseModel] = ResponseModel\n\n\n@pait(response_model_list=[DemoResponseModel])\ndef demo_post(\n    uid: int = Json.t(description=\"user id\", gt=10, lt=1000),\n    username: str = Json.t(description=\"user name\", min_length=2, max_length=4),\n) -&gt; Response:\n    return jsonify({\"uid\": uid, \"user_name\": username})\n\n\napp = Flask(\"demo\")\nAddDocRoute(app, prefix=\"/api-doc\")\napp.run(port=8000)\n</code></pre> <pre><code>from typing import Type\n\nfrom pydantic import BaseModel, Field\nfrom starlette.applications import Starlette\nfrom starlette.responses import JSONResponse\nfrom starlette.routing import Route\n\nfrom pait.app.starlette import pait\nfrom pait.field import Json\nfrom pait.model.response import JsonResponseModel\nfrom pait.openapi.doc_route import AddDocRoute\n\n\nclass DemoResponseModel(JsonResponseModel):\n    class ResponseModel(BaseModel):\n        uid: int = Field()\n        user_name: str = Field()\n\n    description: str = \"demo response\"\n    response_data: Type[BaseModel] = ResponseModel\n\n\n@pait(response_model_list=[DemoResponseModel])\nasync def demo_post(\n    uid: int = Json.t(description=\"user id\", gt=10, lt=1000),\n    username: str = Json.t(description=\"user name\", min_length=2, max_length=4),\n) -&gt; JSONResponse:\n    return JSONResponse({\"uid\": uid, \"user_name\": username})\n\n\napp = Starlette(routes=[Route(\"/api\", demo_post, methods=[\"POST\"])])\nAddDocRoute(app, prefix=\"/api-doc\")\nuvicorn.run(app)\n</code></pre> <pre><code>from typing import Type\n\nfrom pydantic import BaseModel, Field\nfrom sanic.app import Sanic\nfrom sanic.response import HTTPResponse, json\n\nfrom pait.app.sanic import pait\nfrom pait.field import Json\nfrom pait.model.response import JsonResponseModel\nfrom pait.openapi.doc_route import AddDocRoute\n\n\nclass DemoResponseModel(JsonResponseModel):\n    class ResponseModel(BaseModel):\n        uid: int = Field()\n        user_name: str = Field()\n\n    description: str = \"demo response\"\n    response_data: Type[BaseModel] = ResponseModel\n\n\n@pait(response_model_list=[DemoResponseModel])\nasync def demo_post(\n    uid: int = Json.t(description=\"user id\", gt=10, lt=1000),\n    username: str = Json.t(description=\"user name\", min_length=2, max_length=4),\n) -&gt; HTTPResponse:\n    return json({\"uid\": uid, \"user_name\": username})\n\n\napp = Sanic(name=\"demo\")\napp.add_route(demo_post, \"/api\", methods=[\"POST\"])\nAddDocRoute(app, prefix=\"/api-doc\")\nuvicorn.run(app)\n</code></pre> <pre><code>from typing import Type\n\nfrom pydantic import BaseModel, Field\nfrom tornado.ioloop import IOLoop\nfrom tornado.web import Application, RequestHandler\n\nfrom pait.app.tornado import pait\nfrom pait.field import Json\nfrom pait.model.response import JsonResponseModel\nfrom pait.openapi.doc_route import AddDocRoute\n\n\nclass DemoResponseModel(JsonResponseModel):\n    class ResponseModel(BaseModel):\n        uid: int = Field()\n        user_name: str = Field()\n\n    description: str = \"demo response\"\n    response_data: Type[BaseModel] = ResponseModel\n\n\nclass DemoHandler(RequestHandler):\n    @pait(response_model_list=[DemoResponseModel])\n    def post(\n        self,\n        uid: int = Json.t(description=\"user id\", gt=10, lt=1000),\n        username: str = Json.t(description=\"user name\", min_length=2, max_length=4),\n    ) -&gt; None:\n        self.write({\"uid\": uid, \"user_name\": username})\n\n\nAddDocRoute(app, prefix=\"/api-doc\")\napp.listen(8000)\nIOLoop.instance().start()\n</code></pre>"},{"location":"3_2_openapi_route/#14pin_code","title":"1.4.pin_code","text":"<p><code>pin_code</code> provides a simple security mechanism to prevent outsiders from accessing OpenAPI routes, which is used as follows:</p> FlaskStarletteSanicTornado <pre><code>from typing import Type\n\nfrom flask import Flask, Response, jsonify\nfrom pydantic import BaseModel, Field\n\nfrom pait.app.flask import pait\nfrom pait.field import Json\nfrom pait.model.response import JsonResponseModel\nfrom pait.openapi.doc_route import AddDocRoute\n\n\nclass DemoResponseModel(JsonResponseModel):\n    class ResponseModel(BaseModel):\n        uid: int = Field()\n        user_name: str = Field()\n\n    description: str = \"demo response\"\n    response_data: Type[BaseModel] = ResponseModel\n\n\n@pait(response_model_list=[DemoResponseModel])\ndef demo_post(\n    uid: int = Json.t(description=\"user id\", gt=10, lt=1000),\n    username: str = Json.t(description=\"user name\", min_length=2, max_length=4),\n) -&gt; Response:\n    return jsonify({\"uid\": uid, \"user_name\": username})\n\n\napp = Flask(\"demo\")\nAddDocRoute(app, pin_code=\"6666\")\napp.run(port=8000)\n</code></pre> <pre><code>from typing import Type\n\nfrom pydantic import BaseModel, Field\nfrom starlette.applications import Starlette\nfrom starlette.responses import JSONResponse\nfrom starlette.routing import Route\n\nfrom pait.app.starlette import pait\nfrom pait.field import Json\nfrom pait.model.response import JsonResponseModel\nfrom pait.openapi.doc_route import AddDocRoute\n\n\nclass DemoResponseModel(JsonResponseModel):\n    class ResponseModel(BaseModel):\n        uid: int = Field()\n        user_name: str = Field()\n\n    description: str = \"demo response\"\n    response_data: Type[BaseModel] = ResponseModel\n\n\n@pait(response_model_list=[DemoResponseModel])\nasync def demo_post(\n    uid: int = Json.t(description=\"user id\", gt=10, lt=1000),\n    username: str = Json.t(description=\"user name\", min_length=2, max_length=4),\n) -&gt; JSONResponse:\n    return JSONResponse({\"uid\": uid, \"user_name\": username})\n\n\napp = Starlette(routes=[Route(\"/api\", demo_post, methods=[\"POST\"])])\nAddDocRoute(app, pin_code=\"6666\")\nuvicorn.run(app)\n</code></pre> <pre><code>from typing import Type\n\nfrom pydantic import BaseModel, Field\nfrom sanic.app import Sanic\nfrom sanic.response import HTTPResponse, json\n\nfrom pait.app.sanic import pait\nfrom pait.field import Json\nfrom pait.model.response import JsonResponseModel\nfrom pait.openapi.doc_route import AddDocRoute\n\n\nclass DemoResponseModel(JsonResponseModel):\n    class ResponseModel(BaseModel):\n        uid: int = Field()\n        user_name: str = Field()\n\n    description: str = \"demo response\"\n    response_data: Type[BaseModel] = ResponseModel\n\n\n@pait(response_model_list=[DemoResponseModel])\nasync def demo_post(\n    uid: int = Json.t(description=\"user id\", gt=10, lt=1000),\n    username: str = Json.t(description=\"user name\", min_length=2, max_length=4),\n) -&gt; HTTPResponse:\n    return json({\"uid\": uid, \"user_name\": username})\n\n\napp = Sanic(name=\"demo\")\napp.add_route(demo_post, \"/api\", methods=[\"POST\"])\nAddDocRoute(app, pin_code=\"6666\")\nuvicorn.run(app)\n</code></pre> <pre><code>from typing import Type\n\nfrom pydantic import BaseModel, Field\nfrom tornado.ioloop import IOLoop\nfrom tornado.web import Application, RequestHandler\n\nfrom pait.app.tornado import pait\nfrom pait.field import Json\nfrom pait.model.response import JsonResponseModel\nfrom pait.openapi.doc_route import AddDocRoute\n\n\nclass DemoResponseModel(JsonResponseModel):\n    class ResponseModel(BaseModel):\n        uid: int = Field()\n        user_name: str = Field()\n\n    description: str = \"demo response\"\n    response_data: Type[BaseModel] = ResponseModel\n\n\nclass DemoHandler(RequestHandler):\n    @pait(response_model_list=[DemoResponseModel])\n    def post(\n        self,\n        uid: int = Json.t(description=\"user id\", gt=10, lt=1000),\n        username: str = Json.t(description=\"user name\", min_length=2, max_length=4),\n    ) -&gt; None:\n        self.write({\"uid\": uid, \"user_name\": username})\n\n\nAddDocRoute(app, pin_code=\"6666\")\napp.listen(8000)\nIOLoop.instance().start()\n</code></pre> <p>After run the code, If you visit <code>http://127.0.0.1:8000/swagger</code> in your browser, you will not find the corresponding page, but if you visit <code>http://127.0.0.1:8000/swagger/pin_code=6666</code> instead, the page will be displayed normally.</p> <p>Note</p> <ul> <li>1.Normally OpenAPI routes should not be exposed for external use.     Security needs to be enhanced by tools such as Nginx (e.g., IP whitelisting restrictions),     and the security of this mechanism is much higher than that of <code>pin_code</code>.</li> <li>2.Customized security checks can be added to OpenAPI via <code>Pait</code>'s Pre-depend.</li> <li>3.If the pin code checksum carried by the access fails, a 404 exception will be returned by default,     which can be customized via <code>not_found_exc</code>.</li> </ul>"},{"location":"3_2_openapi_route/#15title","title":"1.5.Title","text":"<p>Title has two feature, one is used to define the Title attribute of the OpenAPI object, and the other is to specify the group name of the currently bound OpenAPI route, so you need to make sure that the Title parameter is not the same if you call <code>AddDocRoute</code> multiple times for the same app instance.</p> <p>The example code is as follows:</p> FlaskStarletteSanicTornado <pre><code>from typing import Type\n\nfrom flask import Flask, Response, jsonify\nfrom pydantic import BaseModel, Field\n\nfrom pait.app.flask import pait\nfrom pait.field import Json\nfrom pait.model.response import JsonResponseModel\nfrom pait.openapi.doc_route import AddDocRoute\n\n\nclass DemoResponseModel(JsonResponseModel):\n    class ResponseModel(BaseModel):\n        uid: int = Field()\n        user_name: str = Field()\n\n    description: str = \"demo response\"\n    response_data: Type[BaseModel] = ResponseModel\n\n\n@pait(response_model_list=[DemoResponseModel])\ndef demo_post(\n    uid: int = Json.t(description=\"user id\", gt=10, lt=1000),\n    username: str = Json.t(description=\"user name\", min_length=2, max_length=4),\n) -&gt; Response:\n    return jsonify({\"uid\": uid, \"user_name\": username})\n\n\napp = Flask(\"demo\")\nAddDocRoute(app, title=\"Api Doc\")\napp.run(port=8000)\n</code></pre> <pre><code>from typing import Type\n\nfrom pydantic import BaseModel, Field\nfrom starlette.applications import Starlette\nfrom starlette.responses import JSONResponse\nfrom starlette.routing import Route\n\nfrom pait.app.starlette import pait\nfrom pait.field import Json\nfrom pait.model.response import JsonResponseModel\nfrom pait.openapi.doc_route import AddDocRoute\n\n\nclass DemoResponseModel(JsonResponseModel):\n    class ResponseModel(BaseModel):\n        uid: int = Field()\n        user_name: str = Field()\n\n    description: str = \"demo response\"\n    response_data: Type[BaseModel] = ResponseModel\n\n\n@pait(response_model_list=[DemoResponseModel])\nasync def demo_post(\n    uid: int = Json.t(description=\"user id\", gt=10, lt=1000),\n    username: str = Json.t(description=\"user name\", min_length=2, max_length=4),\n) -&gt; JSONResponse:\n    return JSONResponse({\"uid\": uid, \"user_name\": username})\n\n\napp = Starlette(routes=[Route(\"/api\", demo_post, methods=[\"POST\"])])\nAddDocRoute(app, title=\"Api Doc\")\nuvicorn.run(app)\n</code></pre> <pre><code>from typing import Type\n\nfrom pydantic import BaseModel, Field\nfrom sanic.app import Sanic\nfrom sanic.response import HTTPResponse, json\n\nfrom pait.app.sanic import pait\nfrom pait.field import Json\nfrom pait.model.response import JsonResponseModel\nfrom pait.openapi.doc_route import AddDocRoute\n\n\nclass DemoResponseModel(JsonResponseModel):\n    class ResponseModel(BaseModel):\n        uid: int = Field()\n        user_name: str = Field()\n\n    description: str = \"demo response\"\n    response_data: Type[BaseModel] = ResponseModel\n\n\n@pait(response_model_list=[DemoResponseModel])\nasync def demo_post(\n    uid: int = Json.t(description=\"user id\", gt=10, lt=1000),\n    username: str = Json.t(description=\"user name\", min_length=2, max_length=4),\n) -&gt; HTTPResponse:\n    return json({\"uid\": uid, \"user_name\": username})\n\n\napp = Sanic(name=\"demo\")\napp.add_route(demo_post, \"/api\", methods=[\"POST\"])\nAddDocRoute(app, title=\"Api Doc\")\nuvicorn.run(app)\n</code></pre> <pre><code>from typing import Type\n\nfrom pydantic import BaseModel, Field\nfrom tornado.ioloop import IOLoop\nfrom tornado.web import Application, RequestHandler\n\nfrom pait.app.tornado import pait\nfrom pait.field import Json\nfrom pait.model.response import JsonResponseModel\nfrom pait.openapi.doc_route import AddDocRoute\n\n\nclass DemoResponseModel(JsonResponseModel):\n    class ResponseModel(BaseModel):\n        uid: int = Field()\n        user_name: str = Field()\n\n    description: str = \"demo response\"\n    response_data: Type[BaseModel] = ResponseModel\n\n\nclass DemoHandler(RequestHandler):\n    @pait(response_model_list=[DemoResponseModel])\n    def post(\n        self,\n        uid: int = Json.t(description=\"user id\", gt=10, lt=1000),\n        username: str = Json.t(description=\"user name\", min_length=2, max_length=4),\n    ) -&gt; None:\n        self.write({\"uid\": uid, \"user_name\": username})\n\n\nAddDocRoute(app, title=\"Api Doc\")\napp.listen(8000)\nIOLoop.instance().start()\n</code></pre>"},{"location":"3_2_openapi_route/#16doc_fn_dict","title":"1.6.doc_fn_dict","text":"<p><code>doc_fn_dict</code> is a dictionary with the OpenAPI UI name as Key and the OpenAPI Html content generation function as Value. If this parameter is not passed, then by default <code>AddDocRoute</code> will use the following dictionary. <pre><code>from any_api.openapi.web_ui.elements import get_elements_html\nfrom any_api.openapi.web_ui.rapidoc import get_rapidoc_html, get_rapipdf_html\nfrom any_api.openapi.web_ui.redoc import get_redoc_html\nfrom any_api.openapi.web_ui.swagger import get_swagger_ui_html\n\ndefault_doc_fn_dict = {\n    \"elements\": get_elements_html,\n    \"rapidoc\": get_rapidoc_html,\n    \"rapipdf\": get_rapipdf_html,\n    \"redoc\": get_redoc_html,\n    \"swagger\": get_swagger_ui_html,\n}\n</code></pre></p> <p>Among them, the Key specified in <code>doc_fn_dict</code> is a string and the Value is the following function: <pre><code>def demo(url: str, title: str = \"\") -&gt; str:\n    pass\n</code></pre> The first parameter of the function is the OpenAPI Json URL, while the second parameter is the Title, and <code>AddDocRoute</code> will be registered to the app instance via <code>doc_fn_dict</code> with Key as url and Value as route function when generating the route.</p> <p>The following is an example of adding a custom OpenAPI UI Route:</p> FlaskStarletteSanicTornado <pre><code>from typing import Type\n\nfrom flask import Flask, Response, jsonify\nfrom pydantic import BaseModel, Field\n\nfrom pait.app.flask import pait\nfrom pait.field import Json\nfrom pait.model.response import JsonResponseModel\nfrom pait.openapi.doc_route import AddDocRoute\n\n\nclass DemoResponseModel(JsonResponseModel):\n    class ResponseModel(BaseModel):\n        uid: int = Field()\n        user_name: str = Field()\n\n    description: str = \"demo response\"\n    response_data: Type[BaseModel] = ResponseModel\n\n\n@pait(response_model_list=[DemoResponseModel])\ndef demo_post(\n    uid: int = Json.t(description=\"user id\", gt=10, lt=1000),\n    username: str = Json.t(description=\"user name\", min_length=2, max_length=4),\n) -&gt; Response:\n    return jsonify({\"uid\": uid, \"user_name\": username})\n\n\napp = Flask(\"demo\")\n\ndef demo(url: str, title: str = \"\") -&gt; str:\n    pass\n\nfrom pait.openapi.doc_route import default_doc_fn_dict\nfrom copy import deepcopy\ndefault_doc_fn_dict = deepcopy(default_doc_fn_dict)\ndefault_doc_fn_dict[\"demo\"] = demo\n\nAddDocRoute(app, doc_fn_dict=default_doc_fn_dict)\napp.run(port=8000)\n</code></pre> <pre><code>from typing import Type\n\nfrom pydantic import BaseModel, Field\nfrom starlette.applications import Starlette\nfrom starlette.responses import JSONResponse\nfrom starlette.routing import Route\n\nfrom pait.app.starlette import pait\nfrom pait.field import Json\nfrom pait.model.response import JsonResponseModel\nfrom pait.openapi.doc_route import AddDocRoute\n\n\nclass DemoResponseModel(JsonResponseModel):\n    class ResponseModel(BaseModel):\n        uid: int = Field()\n        user_name: str = Field()\n\n    description: str = \"demo response\"\n    response_data: Type[BaseModel] = ResponseModel\n\n\n@pait(response_model_list=[DemoResponseModel])\nasync def demo_post(\n    uid: int = Json.t(description=\"user id\", gt=10, lt=1000),\n    username: str = Json.t(description=\"user name\", min_length=2, max_length=4),\n) -&gt; JSONResponse:\n    return JSONResponse({\"uid\": uid, \"user_name\": username})\n\n\napp = Starlette(routes=[Route(\"/api\", demo_post, methods=[\"POST\"])])\n\ndef demo(url: str, title: str = \"\") -&gt; str:\n    pass\n\nfrom pait.openapi.doc_route import default_doc_fn_dict\nfrom copy import deepcopy\ndefault_doc_fn_dict = deepcopy(default_doc_fn_dict)\ndefault_doc_fn_dict[\"demo\"] = demo\n\nAddDocRoute(app, doc_fn_dict=default_doc_fn_dict)\nuvicorn.run(app)\n</code></pre> <pre><code>from typing import Type\n\nfrom pydantic import BaseModel, Field\nfrom sanic.app import Sanic\nfrom sanic.response import HTTPResponse, json\n\nfrom pait.app.sanic import pait\nfrom pait.field import Json\nfrom pait.model.response import JsonResponseModel\nfrom pait.openapi.doc_route import AddDocRoute\n\n\nclass DemoResponseModel(JsonResponseModel):\n    class ResponseModel(BaseModel):\n        uid: int = Field()\n        user_name: str = Field()\n\n    description: str = \"demo response\"\n    response_data: Type[BaseModel] = ResponseModel\n\n\n@pait(response_model_list=[DemoResponseModel])\nasync def demo_post(\n    uid: int = Json.t(description=\"user id\", gt=10, lt=1000),\n    username: str = Json.t(description=\"user name\", min_length=2, max_length=4),\n) -&gt; HTTPResponse:\n    return json({\"uid\": uid, \"user_name\": username})\n\n\napp = Sanic(name=\"demo\")\napp.add_route(demo_post, \"/api\", methods=[\"POST\"])\n\ndef demo(url: str, title: str = \"\") -&gt; str:\n    pass\n\nfrom pait.openapi.doc_route import default_doc_fn_dict\nfrom copy import deepcopy\ndefault_doc_fn_dict = deepcopy(default_doc_fn_dict)\ndefault_doc_fn_dict[\"demo\"] = demo\n\nAddDocRoute(app, doc_fn_dict=default_doc_fn_dict)\nuvicorn.run(app)\n</code></pre> <pre><code>from typing import Type\n\nfrom pydantic import BaseModel, Field\nfrom tornado.ioloop import IOLoop\nfrom tornado.web import Application, RequestHandler\n\nfrom pait.app.tornado import pait\nfrom pait.field import Json\nfrom pait.model.response import JsonResponseModel\nfrom pait.openapi.doc_route import AddDocRoute\n\n\nclass DemoResponseModel(JsonResponseModel):\n    class ResponseModel(BaseModel):\n        uid: int = Field()\n        user_name: str = Field()\n\n    description: str = \"demo response\"\n    response_data: Type[BaseModel] = ResponseModel\n\n\nclass DemoHandler(RequestHandler):\n    @pait(response_model_list=[DemoResponseModel])\n    def post(\n        self,\n        uid: int = Json.t(description=\"user id\", gt=10, lt=1000),\n        username: str = Json.t(description=\"user name\", min_length=2, max_length=4),\n    ) -&gt; None:\n        self.write({\"uid\": uid, \"user_name\": username})\n\n\n\ndef demo(url: str, title: str = \"\") -&gt; str:\n    pass\n\nfrom pait.openapi.doc_route import default_doc_fn_dict\nfrom copy import deepcopy\ndefault_doc_fn_dict = deepcopy(default_doc_fn_dict)\ndefault_doc_fn_dict[\"demo\"] = demo\n\nAddDocRoute(app, doc_fn_dict=default_doc_fn_dict)\napp.listen(8000)\nIOLoop.instance().start()\n</code></pre> <p>It first creates a <code>demo</code> function that conforms to the specification, then adds to the default <code>default_doc_fn_dict</code>, and finally binds to the app instance via <code>AddDocRoute</code>.</p> <p>The customized OpenAPI UI page can now be accessed via <code>http://127.0.0.1:8000/demo</code>.</p>"},{"location":"3_2_openapi_route/#17openapi","title":"1.7.OpenAPI","text":"<p>By default, <code>AddDocRoute</code> creates an OpenAPI object and generates json content from the OpenAPI object.</p> <p>Note</p> <p>The Title of the created OpenAPI object is overwritten by the <code>title</code> parameter specified by <code>AddDocRoute</code> and the Host bound to the current APP instance is appended to the <code>Server List</code>.</p> <p>However, <code>AddDocRoute</code> also supports passing defined OpenAPI objects via the <code>openapi</code> parameter, which is used as follows:</p> FlaskStarletteSanicTornado <pre><code>from typing import Type\n\nfrom flask import Flask, Response, jsonify\nfrom pydantic import BaseModel, Field\n\nfrom pait.app.flask import pait\nfrom pait.field import Json\nfrom pait.model.response import JsonResponseModel\nfrom pait.openapi.doc_route import AddDocRoute\n\n\nclass DemoResponseModel(JsonResponseModel):\n    class ResponseModel(BaseModel):\n        uid: int = Field()\n        user_name: str = Field()\n\n    description: str = \"demo response\"\n    response_data: Type[BaseModel] = ResponseModel\n\n\n@pait(response_model_list=[DemoResponseModel])\ndef demo_post(\n    uid: int = Json.t(description=\"user id\", gt=10, lt=1000),\n    username: str = Json.t(description=\"user name\", min_length=2, max_length=4),\n) -&gt; Response:\n    return jsonify({\"uid\": uid, \"user_name\": username})\n\n\napp = Flask(\"demo\")\n\nfrom pait.util import partial_wrapper\nfrom pait.openapi.openapi import OpenAPI, InfoModel\n\nopenapi = partial_wrapper(OpenAPI, openapi_info_model=InfoModel(version=\"1.0.0\", description=\"Demo Doc\"))\nAddDocRoute(flask_app, openapi=openapi)  # type: ignore\napp.run(port=8000)\n</code></pre> <pre><code>from typing import Type\n\nfrom pydantic import BaseModel, Field\nfrom starlette.applications import Starlette\nfrom starlette.responses import JSONResponse\nfrom starlette.routing import Route\n\nfrom pait.app.starlette import pait\nfrom pait.field import Json\nfrom pait.model.response import JsonResponseModel\nfrom pait.openapi.doc_route import AddDocRoute\n\n\nclass DemoResponseModel(JsonResponseModel):\n    class ResponseModel(BaseModel):\n        uid: int = Field()\n        user_name: str = Field()\n\n    description: str = \"demo response\"\n    response_data: Type[BaseModel] = ResponseModel\n\n\n@pait(response_model_list=[DemoResponseModel])\nasync def demo_post(\n    uid: int = Json.t(description=\"user id\", gt=10, lt=1000),\n    username: str = Json.t(description=\"user name\", min_length=2, max_length=4),\n) -&gt; JSONResponse:\n    return JSONResponse({\"uid\": uid, \"user_name\": username})\n\n\napp = Starlette(routes=[Route(\"/api\", demo_post, methods=[\"POST\"])])\n\nfrom pait.util import partial_wrapper\nfrom pait.openapi.openapi import OpenAPI, InfoModel\n\nopenapi = partial_wrapper(OpenAPI, openapi_info_model=InfoModel(version=\"1.0.0\", description=\"Demo Doc\"))\nAddDocRoute(flask_app, openapi=openapi)  # type: ignore\nuvicorn.run(app)\n</code></pre> <pre><code>from typing import Type\n\nfrom pydantic import BaseModel, Field\nfrom sanic.app import Sanic\nfrom sanic.response import HTTPResponse, json\n\nfrom pait.app.sanic import pait\nfrom pait.field import Json\nfrom pait.model.response import JsonResponseModel\nfrom pait.openapi.doc_route import AddDocRoute\n\n\nclass DemoResponseModel(JsonResponseModel):\n    class ResponseModel(BaseModel):\n        uid: int = Field()\n        user_name: str = Field()\n\n    description: str = \"demo response\"\n    response_data: Type[BaseModel] = ResponseModel\n\n\n@pait(response_model_list=[DemoResponseModel])\nasync def demo_post(\n    uid: int = Json.t(description=\"user id\", gt=10, lt=1000),\n    username: str = Json.t(description=\"user name\", min_length=2, max_length=4),\n) -&gt; HTTPResponse:\n    return json({\"uid\": uid, \"user_name\": username})\n\n\napp = Sanic(name=\"demo\")\napp.add_route(demo_post, \"/api\", methods=[\"POST\"])\n\nfrom pait.util import partial_wrapper\nfrom pait.openapi.openapi import OpenAPI, InfoModel\n\nopenapi = partial_wrapper(OpenAPI, openapi_info_model=InfoModel(version=\"1.0.0\", description=\"Demo Doc\"))\nAddDocRoute(flask_app, openapi=openapi)  # type: ignore\nuvicorn.run(app)\n</code></pre> <pre><code>from typing import Type\n\nfrom pydantic import BaseModel, Field\nfrom tornado.ioloop import IOLoop\nfrom tornado.web import Application, RequestHandler\n\nfrom pait.app.tornado import pait\nfrom pait.field import Json\nfrom pait.model.response import JsonResponseModel\nfrom pait.openapi.doc_route import AddDocRoute\n\n\nclass DemoResponseModel(JsonResponseModel):\n    class ResponseModel(BaseModel):\n        uid: int = Field()\n        user_name: str = Field()\n\n    description: str = \"demo response\"\n    response_data: Type[BaseModel] = ResponseModel\n\n\nclass DemoHandler(RequestHandler):\n    @pait(response_model_list=[DemoResponseModel])\n    def post(\n        self,\n        uid: int = Json.t(description=\"user id\", gt=10, lt=1000),\n        username: str = Json.t(description=\"user name\", min_length=2, max_length=4),\n    ) -&gt; None:\n        self.write({\"uid\": uid, \"user_name\": username})\n\n\n\nfrom pait.util import partial_wrapper\nfrom pait.openapi.openapi import OpenAPI, InfoModel\n\nopenapi = partial_wrapper(OpenAPI, openapi_info_model=InfoModel(version=\"1.0.0\", description=\"Demo Doc\"))\nAddDocRoute(flask_app, openapi=openapi)  # type: ignore\napp.listen(8000)\nIOLoop.instance().start()\n</code></pre> <p>Run the example code and visit http://127.0.0.1:8000/swagger, can see the document description and version number in the upper left corner of the page have changed.</p>"},{"location":"3_2_openapi_route/#2template-variables-for-openapi-routing","title":"2.Template variables for OpenAPI routing","text":"<p>Most interfaces have an authentication mechanism, for example, need to bring the correct Token parameter to get the data properly. If request data on the OpenAPI page, need to paste the Token parameter every time, which is very inconvenient. This is where you can use template variables to allow the OpenAPI page to automatically fill in the values of the variables, as shown in the following code:</p> FlaskStarletteSanicTornado docs_source_code/openapi/openapi_route/flask_demo.py<pre><code>from flask import Flask, Response, jsonify\nfrom pydantic import BaseModel, Field\n\nfrom pait import _pydanitc_adapter\nfrom pait.app.flask import pait\nfrom pait.field import Json\nfrom pait.model.template import TemplateVar\nfrom pait.openapi.doc_route import AddDocRoute\n\nif _pydanitc_adapter.is_v1:\n\n    class UserModel(BaseModel):\n        uid: int = Field(description=\"user id\", gt=10, lt=1000, example=TemplateVar(\"uid\"))\n        user_name: str = Field(description=\"user name\", min_length=2, max_length=4)\n\nelse:\n\n    class UserModel(BaseModel):  # type: ignore[no-redef]\n        uid: int = Field(\n            description=\"user id\", gt=10, lt=1000, json_schema_extra=lambda v: v.update(example=TemplateVar(\"uid\"))\n        )\n        user_name: str = Field(description=\"user name\", min_length=2, max_length=4)\n\n\n@pait()\ndef demo_post(model: UserModel = Json.i()) -&gt; Response:\n    return jsonify({\"result\": model.dict()})\n\n\napp = Flask(\"demo\")\napp.add_url_rule(\"/api\", \"demo\", demo_post, methods=[\"POST\"])\n\n\nif __name__ == \"__main__\":\n    AddDocRoute(app)\n    app.run(port=8000)\n</code></pre> docs_source_code/openapi/openapi_route/starlette_demo.py<pre><code>from pydantic import BaseModel, Field\nfrom starlette.applications import Starlette\nfrom starlette.responses import JSONResponse\nfrom starlette.routing import Route\n\nfrom pait import _pydanitc_adapter\nfrom pait.app.starlette import pait\nfrom pait.field import Json\nfrom pait.model.template import TemplateVar\nfrom pait.openapi.doc_route import AddDocRoute\n\nif _pydanitc_adapter.is_v1:\n\n    class UserModel(BaseModel):\n        uid: int = Field(description=\"user id\", gt=10, lt=1000, example=TemplateVar(\"uid\"))\n        user_name: str = Field(description=\"user name\", min_length=2, max_length=4)\n\nelse:\n\n    class UserModel(BaseModel):  # type: ignore[no-redef]\n        uid: int = Field(\n            description=\"user id\", gt=10, lt=1000, json_schema_extra=lambda v: v.update(example=TemplateVar(\"uid\"))\n        )\n        user_name: str = Field(description=\"user name\", min_length=2, max_length=4)\n\n\n@pait()\nasync def demo_post(model: UserModel = Json.i()) -&gt; JSONResponse:\n    return JSONResponse({\"result\": model.dict()})\n\n\napp = Starlette(routes=[Route(\"/api\", demo_post, methods=[\"POST\"])])\n\n\nif __name__ == \"__main__\":\n    AddDocRoute(app)\n    import uvicorn\n\n    uvicorn.run(app)\n</code></pre> docs_source_code/openapi/openapi_route/sanic_demo.py<pre><code>from pydantic import BaseModel, Field\nfrom sanic import HTTPResponse, Sanic, json\n\nfrom pait import _pydanitc_adapter\nfrom pait.app.sanic import pait\nfrom pait.field import Json\nfrom pait.model.template import TemplateVar\nfrom pait.openapi.doc_route import AddDocRoute\n\nif _pydanitc_adapter.is_v1:\n\n    class UserModel(BaseModel):\n        uid: int = Field(description=\"user id\", gt=10, lt=1000, example=TemplateVar(\"uid\"))\n        user_name: str = Field(description=\"user name\", min_length=2, max_length=4)\n\nelse:\n\n    class UserModel(BaseModel):  # type: ignore[no-redef]\n        uid: int = Field(\n            description=\"user id\", gt=10, lt=1000, json_schema_extra=lambda v: v.update(example=TemplateVar(\"uid\"))\n        )\n        user_name: str = Field(description=\"user name\", min_length=2, max_length=4)\n\n\n@pait()\nasync def demo_post(model: UserModel = Json.i()) -&gt; HTTPResponse:\n    return json({\"result\": model.dict()})\n\n\napp = Sanic(name=\"demo\")\napp.add_route(demo_post, \"/api\", methods=[\"POST\"])\n\n\nif __name__ == \"__main__\":\n    AddDocRoute(app)\n    import uvicorn\n\n    uvicorn.run(app)\n</code></pre> docs_source_code/openapi/openapi_route/tornado_demo.py<pre><code>from pydantic import BaseModel, Field\nfrom tornado.ioloop import IOLoop\nfrom tornado.web import Application, RequestHandler\n\nfrom pait import _pydanitc_adapter\nfrom pait.app.tornado import pait\nfrom pait.field import Json\nfrom pait.model.template import TemplateVar\nfrom pait.openapi.doc_route import AddDocRoute\n\nif _pydanitc_adapter.is_v1:\n\n    class UserModel(BaseModel):\n        uid: int = Field(description=\"user id\", gt=10, lt=1000, example=TemplateVar(\"uid\"))\n        user_name: str = Field(description=\"user name\", min_length=2, max_length=4)\n\nelse:\n\n    class UserModel(BaseModel):  # type: ignore[no-redef]\n        uid: int = Field(\n            description=\"user id\", gt=10, lt=1000, json_schema_extra=lambda v: v.update(example=TemplateVar(\"uid\"))\n        )\n        user_name: str = Field(description=\"user name\", min_length=2, max_length=4)\n\n\nclass DemoHandler(RequestHandler):\n    @pait()\n    async def post(self, model: UserModel = Json.i()) -&gt; None:\n        self.write({\"result\": model.dict()})\n\n\napp: Application = Application([(r\"/api\", DemoHandler)])\nAddDocRoute(app)\n\n\nif __name__ == \"__main__\":\n    app.listen(8000)\n    IOLoop.instance().start()\n</code></pre> <p>First introduced <code>TemplateVar</code> class and then used <code>TemplateVar(\"uid\")</code> in the example attribute of the Field of <code>uid</code> so that <code>Pait</code> knows that the template variable for the parameter <code>uid</code> is <code>uid</code>. Now run the above code and type <code>http://127.0.0.1:8000/swagger?template-uid=123</code> in your browser and it will open up as follows:  As you can see from the diagram, the value of <code>uid</code> has been auto-populated with <code>123</code> instead of the default value of zero. The reason <code>Pait</code> is able to set the user's value to the corresponding parameter is because the url has an extra string <code>template-uid=123</code>. This way, when the OpenAPI route receives the corresponding request, it realizes that the request carries a variable starting with <code>template-</code>, and knows that this is the value that the user has assigned to the template variable <code>uid</code>, so when it generates the OpenAPI data, it can set the user's value to the corresponding parameter. When generating OpenAPI data, the OpenAPI route will automatically append the user-specified value to the parameter of the template variable uid.</p>"},{"location":"3_3_security/","title":"Security","text":"<p>OpenAPI provides support for basic HTTP authentication through <code>security</code>, but different web frameworks implement basic HTTP authentication in different ways. So <code>Pait</code> provides simple support for OpenAPI's security through <code>Depends</code> (<code>api key</code>, <code>http</code>, <code>oauth2</code>), which simplifies the use of security in different web frameworks.</p> <p>Note</p> <p>advanced authentication such as jwt will be supported through other package in the future.</p>"},{"location":"3_3_security/#1apikey","title":"1.APIKey","text":"<p><code>API Key</code> is the simplest method in Security, and because of its simplicity, it has the most usage scenarios. <code>Pait</code> provides <code>APIKey</code> class to support the use of <code>API Key</code>, the usage is as follows:</p> FlaskStarletteSanicTornado docs_source_code/openapi/security/flask_with_apikey_demo.py<pre><code>from flask import Flask\n\nfrom pait.app.flask import pait\nfrom pait.app.flask.security import api_key\nfrom pait.field import Cookie, Depends, Header, Query\nfrom pait.openapi.doc_route import AddDocRoute\n\ntoken_cookie_api_key: api_key.APIKey = api_key.APIKey(\n    name=\"token\",\n    field=Cookie(openapi_include=False),\n    verify_api_key_callable=lambda x: \"token\" in x,\n    security_name=\"token-cookie-api-key\",\n)\ntoken_header_api_key: api_key.APIKey = api_key.APIKey(\n    name=\"token\",\n    field=Header(openapi_include=False),\n    verify_api_key_callable=lambda x: \"token\" in x,\n    security_name=\"token-header-api-key\",\n)\ntoken_query_api_key: api_key.APIKey = api_key.APIKey(\n    name=\"token\",\n    field=Query(openapi_include=False),\n    verify_api_key_callable=lambda x: \"token\" in x,\n    security_name=\"token-query-api-key\",\n)\n\n\n@pait()\ndef api_key_cookie_route(token: str = Depends.i(token_cookie_api_key)) -&gt; dict:\n    return {\"code\": 0, \"msg\": \"\", \"data\": token}\n\n\n@pait()\ndef api_key_header_route(token: str = Depends.i(token_header_api_key)) -&gt; dict:\n    return {\"code\": 0, \"msg\": \"\", \"data\": token}\n\n\n@pait()\ndef api_key_query_route(token: str = Depends.i(token_query_api_key)) -&gt; dict:\n    return {\"code\": 0, \"msg\": \"\", \"data\": token}\n\n\napp = Flask(\"demo\")\napp.add_url_rule(\"/api/api-cookie-key\", view_func=api_key_cookie_route, methods=[\"GET\"])\napp.add_url_rule(\"/api/api-header-key\", view_func=api_key_header_route, methods=[\"GET\"])\napp.add_url_rule(\"/api/api-query-key\", view_func=api_key_query_route, methods=[\"GET\"])\nAddDocRoute(app)\n\n\nif __name__ == \"__main__\":\n    app.run(port=8000)\n</code></pre> docs_source_code/openapi/security/starlette_with_apikey_demo.py<pre><code>from starlette.applications import Starlette\nfrom starlette.responses import JSONResponse\nfrom starlette.routing import Route\n\nfrom pait.app.starlette import pait\nfrom pait.app.starlette.security import api_key\nfrom pait.field import Cookie, Depends, Header, Query\nfrom pait.openapi.doc_route import AddDocRoute\n\ntoken_cookie_api_key: api_key.APIKey = api_key.APIKey(\n    name=\"token\",\n    field=Cookie(openapi_include=False),\n    verify_api_key_callable=lambda x: \"token\" in x,\n    security_name=\"token-cookie-api-key\",\n)\ntoken_header_api_key: api_key.APIKey = api_key.APIKey(\n    name=\"token\",\n    field=Header(openapi_include=False),\n    verify_api_key_callable=lambda x: \"token\" in x,\n    security_name=\"token-header-api-key\",\n)\ntoken_query_api_key: api_key.APIKey = api_key.APIKey(\n    name=\"token\",\n    field=Query(openapi_include=False),\n    verify_api_key_callable=lambda x: \"token\" in x,\n    security_name=\"token-query-api-key\",\n)\n\n\n@pait()\nasync def api_key_cookie_route(token: str = Depends.i(token_cookie_api_key)) -&gt; JSONResponse:\n    return JSONResponse({\"code\": 0, \"msg\": \"\", \"data\": token})\n\n\n@pait()\nasync def api_key_header_route(token: str = Depends.i(token_header_api_key)) -&gt; JSONResponse:\n    return JSONResponse({\"code\": 0, \"msg\": \"\", \"data\": token})\n\n\n@pait()\nasync def api_key_query_route(token: str = Depends.i(token_query_api_key)) -&gt; JSONResponse:\n    return JSONResponse({\"code\": 0, \"msg\": \"\", \"data\": token})\n\n\napp = Starlette(\n    routes=[\n        Route(\"/api/api-cookie-key\", api_key_cookie_route, methods=[\"GET\"]),\n        Route(\"/api/api-header-key\", api_key_header_route, methods=[\"GET\"]),\n        Route(\"/api/api-query-key\", api_key_query_route, methods=[\"GET\"]),\n    ]\n)\nAddDocRoute(app)\n\n\nif __name__ == \"__main__\":\n    import uvicorn\n\n    uvicorn.run(app)\n</code></pre> docs_source_code/openapi/security/sanic_with_apikey_demo.py<pre><code>from sanic import HTTPResponse, Sanic, json\n\nfrom pait.app.sanic import pait\nfrom pait.app.sanic.security import api_key\nfrom pait.field import Cookie, Depends, Header, Query\nfrom pait.openapi.doc_route import AddDocRoute\n\ntoken_cookie_api_key: api_key.APIKey = api_key.APIKey(\n    name=\"token\",\n    field=Cookie(openapi_include=False),\n    verify_api_key_callable=lambda x: \"token\" in x,\n    security_name=\"token-cookie-api-key\",\n)\ntoken_header_api_key: api_key.APIKey = api_key.APIKey(\n    name=\"token\",\n    field=Header(openapi_include=False),\n    verify_api_key_callable=lambda x: \"token\" in x,\n    security_name=\"token-header-api-key\",\n)\ntoken_query_api_key: api_key.APIKey = api_key.APIKey(\n    name=\"token\",\n    field=Query(openapi_include=False),\n    verify_api_key_callable=lambda x: \"token\" in x,\n    security_name=\"token-query-api-key\",\n)\n\n\n@pait()\nasync def api_key_cookie_route(token: str = Depends.i(token_cookie_api_key)) -&gt; HTTPResponse:\n    return json({\"code\": 0, \"msg\": \"\", \"data\": token})\n\n\n@pait()\nasync def api_key_header_route(token: str = Depends.i(token_header_api_key)) -&gt; HTTPResponse:\n    return json({\"code\": 0, \"msg\": \"\", \"data\": token})\n\n\n@pait()\nasync def api_key_query_route(token: str = Depends.i(token_query_api_key)) -&gt; HTTPResponse:\n    return json({\"code\": 0, \"msg\": \"\", \"data\": token})\n\n\napp = Sanic(name=\"demo\")\napp.add_route(api_key_cookie_route, \"/api/api-cookie-key\", methods=[\"GET\"])\napp.add_route(api_key_header_route, \"/api/api-header-key\", methods=[\"GET\"])\napp.add_route(api_key_query_route, \"/api/api-query-key\", methods=[\"GET\"])\nAddDocRoute(app)\n\n\nif __name__ == \"__main__\":\n    import uvicorn\n\n    uvicorn.run(app)\n</code></pre> docs_source_code/openapi/security/tornado_with_apikey_demo.py<pre><code>from tornado.ioloop import IOLoop\nfrom tornado.web import Application, RequestHandler\n\nfrom pait.app.tornado import pait\nfrom pait.app.tornado.security import api_key\nfrom pait.field import Cookie, Depends, Header, Query\nfrom pait.openapi.doc_route import AddDocRoute\n\ntoken_cookie_api_key: api_key.APIKey = api_key.APIKey(\n    name=\"token\",\n    field=Cookie(openapi_include=False),\n    verify_api_key_callable=lambda x: \"token\" in x,\n    security_name=\"token-cookie-api-key\",\n)\ntoken_header_api_key: api_key.APIKey = api_key.APIKey(\n    name=\"token\",\n    field=Header(openapi_include=False),\n    verify_api_key_callable=lambda x: \"token\" in x,\n    security_name=\"token-header-api-key\",\n)\ntoken_query_api_key: api_key.APIKey = api_key.APIKey(\n    name=\"token\",\n    field=Query(openapi_include=False),\n    verify_api_key_callable=lambda x: \"token\" in x,\n    security_name=\"token-query-api-key\",\n)\n\n\nclass APIKeyCookieHandler(RequestHandler):\n    @pait()\n    async def get(self, token: str = Depends.i(token_cookie_api_key)) -&gt; None:\n        self.write({\"code\": 0, \"msg\": \"\", \"data\": token})\n\n\nclass APIKeyHeaderHandler(RequestHandler):\n    @pait()\n    async def get(self, token: str = Depends.i(token_header_api_key)) -&gt; None:\n        self.write({\"code\": 0, \"msg\": \"\", \"data\": token})\n\n\nclass APIKeyQueryHandler(RequestHandler):\n    @pait()\n    async def get(self, token: str = Depends.i(token_query_api_key)) -&gt; None:\n        self.write({\"code\": 0, \"msg\": \"\", \"data\": token})\n\n\napp: Application = Application(\n    [\n        (r\"/api/security/api-cookie-key\", APIKeyCookieHandler),\n        (r\"/api/security/api-header-key\", APIKeyHeaderHandler),\n        (r\"/api/security/api-query-key\", APIKeyQueryHandler),\n    ],\n)\nAddDocRoute(app)\n\n\nif __name__ == \"__main__\":\n    app.listen(8000)\n    IOLoop.instance().start()\n</code></pre> <p>The first highlighting code is initialized for the different <code>APIKey</code> fields, which use slightly different parameters, see the table below for parameter meanings:</p> Parameters Description name The name of the <code>APIKey</code> field field The <code>APIKey</code> field corresponds to the Field class in <code>Pait</code>, <code>API Key</code> only supports Query, Header and Cookie parameters, so only <code>field.Query</code>, <code>field.Header</code>, <code>field.Cookie</code> are allowed verify_api_key_callable A function that checks <code>APIKey</code>, <code>Pait</code> extracts the <code>APIKey</code> value from the request body and passes it to the function for processing, if the function returns <code>True</code> then the check passes, and vice versa then the check fails. security_name Specify the name of the security, the name of <code>APIKey</code> must be different for different roles, the default value is the class name of APIKey. <p>Note</p> <p>In order to use APIKey properly in the OpenAPI tool, the <code>Field</code> must be initialized with the <code>openapi_include</code> attribute False.</p> <p>The second highlighted piece of code connects APIKey to the route function via <code>Depend</code>, where the argument to <code>Depend</code> is an instance of <code>APIKey</code>. When the route function receives a request <code>Pait</code> automatically extracts the value of <code>APIKey</code> from the request body and passes it to <code>APIKey</code>'s <code>verify_api_key_callable</code> function for verification, if it passes the verification the value is injected into the route function for execution, and vice versa <code>401</code> is returned.</p> <p>After running the code, execute the following command to see the execution effect of <code>APIKey</code>: <pre><code># Success Result\n\u279c  curl -X 'GET' \\\n  'http://127.0.0.1:8000/api/api-cookie-key' \\\n  -H 'accept: */*' \\\n  -H 'Cookie: token=token'\n{\"code\":0,\"msg\":\"\",\"data\":\"token\"}\n\n\u279c  curl -X 'GET' \\\n  'http://127.0.0.1:8000/api/api-header-key' \\\n  -H 'accept: */*' \\\n  -H 'token: token'\n{\"code\":0,\"msg\":\"\",\"data\":\"token\"}\n\n\u279c  curl -X 'GET' \\\n  'http://127.0.0.1:8000/api/api-query-key?token=token' \\\n  -H 'accept: */*'\n{\"code\":0,\"msg\":\"\",\"data\":\"token\"}\n\n# Fail Result\n\u279c  curl -X 'GET' \\\n  'http://127.0.0.1:8000/api/api-cookie-key' \\\n  -H 'accept: */*' \\\n  -H 'Cookie: token='\nNot authenticated\n\n\u279c  curl -X 'GET' \\\n  'http://127.0.0.1:8000/api/api-header-key' \\\n  -H 'accept: */*' \\\n  -H 'token: '\nNot authenticated\n\n\u279c  curl -X 'GET' \\\n  'http://127.0.0.1:8000/api/api-query-key?token=' \\\n  -H 'accept: */*'\nNot authenticated\n</code></pre></p>"},{"location":"3_3_security/#11combination-of-apikey-and-links","title":"1.1.Combination of APIKey and Links","text":"<p>Most of the parameters (e.g., Token) needed by route functions that use APIKey are obtained through other route functions. In this case, you can describe the relationship between this route function and other route functions by using <code>Links</code> in <code>Field</code>, such as the following scenario, which gets its Token from the login route function:</p> FlaskStarletteSanicTornado docs_source_code/openapi/security/flask_with_apikey_and_link_demo.py<pre><code>import hashlib\nfrom typing import Type\n\nfrom flask import Flask\nfrom pydantic import BaseModel, Field\n\nfrom pait.app.flask import pait\nfrom pait.app.flask.security import api_key\nfrom pait.field import Depends, Json, Query\nfrom pait.model.response import JsonResponseModel\nfrom pait.openapi.doc_route import AddDocRoute\nfrom pait.openapi.openapi import LinksModel\n\n\nclass LoginRespModel(JsonResponseModel):\n    class ResponseModel(BaseModel):\n        class DataModel(BaseModel):\n            token: str\n\n        code: int = Field(0, description=\"api code\")\n        msg: str = Field(\"success\", description=\"api status msg\")\n        data: DataModel\n\n    description: str = \"login response\"\n    response_data: Type[BaseModel] = ResponseModel\n\n\n@pait(response_model_list=[LoginRespModel])\ndef login_route(uid: str = Json.i(description=\"user id\"), password: str = Json.i(description=\"password\")) -&gt; dict:\n    return {\"code\": 0, \"msg\": \"\", \"data\": {\"token\": hashlib.sha256((uid + password).encode(\"utf-8\")).hexdigest()}}\n\n\nlink_login_token_model: LinksModel = LinksModel(LoginRespModel, \"$response.body#/data/token\", desc=\"test links model\")\n\n\ntoken_query_api_key: api_key.APIKey = api_key.APIKey(\n    name=\"token\",\n    field=Query(links=link_login_token_model),\n    verify_api_key_callable=lambda x: \"token\" in x,\n    security_name=\"token-query-api-key\",\n)\n\n\n@pait()\ndef api_key_query_route(token: str = Depends.i(token_query_api_key)) -&gt; dict:\n    return {\"code\": 0, \"msg\": \"\", \"data\": token}\n\n\napp = Flask(\"demo\")\napp.add_url_rule(\"/api/login\", \"login\", login_route, methods=[\"POST\"])\napp.add_url_rule(\"/api/api-query-key\", view_func=api_key_query_route, methods=[\"GET\"])\nAddDocRoute(app)\n\n\nif __name__ == \"__main__\":\n    app.run(port=8000)\n</code></pre> docs_source_code/openapi/security/starlette_with_apikey_and_link_demo.py<pre><code>import hashlib\nfrom typing import Type\n\nfrom pydantic import BaseModel, Field\nfrom starlette.applications import Starlette\nfrom starlette.responses import JSONResponse\nfrom starlette.routing import Route\n\nfrom pait.app.starlette import pait\nfrom pait.app.starlette.security import api_key\nfrom pait.field import Depends, Json, Query\nfrom pait.model.response import JsonResponseModel\nfrom pait.openapi.doc_route import AddDocRoute\nfrom pait.openapi.openapi import LinksModel\n\n\nclass LoginRespModel(JsonResponseModel):\n    class ResponseModel(BaseModel):\n        class DataModel(BaseModel):\n            token: str\n\n        code: int = Field(0, description=\"api code\")\n        msg: str = Field(\"success\", description=\"api status msg\")\n        data: DataModel\n\n    description: str = \"login response\"\n    response_data: Type[BaseModel] = ResponseModel\n\n\n@pait(response_model_list=[LoginRespModel])\nasync def login_route(\n    uid: str = Json.i(description=\"user id\"), password: str = Json.i(description=\"password\")\n) -&gt; JSONResponse:\n    return JSONResponse(\n        {\"code\": 0, \"msg\": \"\", \"data\": {\"token\": hashlib.sha256((uid + password).encode(\"utf-8\")).hexdigest()}}\n    )\n\n\nlink_login_token_model: LinksModel = LinksModel(LoginRespModel, \"$response.body#/data/token\", desc=\"test links model\")\n\n\ntoken_query_api_key: api_key.APIKey = api_key.APIKey(\n    name=\"token\",\n    field=Query(links=link_login_token_model),\n    verify_api_key_callable=lambda x: \"token\" in x,\n    security_name=\"token-query-api-key\",\n)\n\n\n@pait()\nasync def api_key_query_route(token: str = Depends.i(token_query_api_key)) -&gt; JSONResponse:\n    return JSONResponse({\"code\": 0, \"msg\": \"\", \"data\": token})\n\n\napp = Starlette(\n    routes=[\n        Route(\"/api/login\", login_route, methods=[\"POST\"]),\n        Route(\"/api/api-query-key\", api_key_query_route, methods=[\"GET\"]),\n    ]\n)\nAddDocRoute(app)\n\n\nif __name__ == \"__main__\":\n    import uvicorn\n\n    uvicorn.run(app)\n</code></pre> docs_source_code/openapi/security/sanic_with_apikey_and_link_demo.py<pre><code>import hashlib\nfrom typing import Type\n\nfrom pydantic import BaseModel, Field\nfrom sanic import HTTPResponse, Sanic, json\n\nfrom pait.app.sanic import pait\nfrom pait.app.sanic.security import api_key\nfrom pait.field import Depends, Json, Query\nfrom pait.model.response import JsonResponseModel\nfrom pait.openapi.doc_route import AddDocRoute\nfrom pait.openapi.openapi import LinksModel\n\n\nclass LoginRespModel(JsonResponseModel):\n    class ResponseModel(BaseModel):\n        class DataModel(BaseModel):\n            token: str\n\n        code: int = Field(0, description=\"api code\")\n        msg: str = Field(\"success\", description=\"api status msg\")\n        data: DataModel\n\n    description: str = \"login response\"\n    response_data: Type[BaseModel] = ResponseModel\n\n\n@pait(response_model_list=[LoginRespModel])\nasync def login_route(\n    uid: str = Json.i(description=\"user id\"), password: str = Json.i(description=\"password\")\n) -&gt; HTTPResponse:\n    return json({\"code\": 0, \"msg\": \"\", \"data\": {\"token\": hashlib.sha256((uid + password).encode(\"utf-8\")).hexdigest()}})\n\n\nlink_login_token_model: LinksModel = LinksModel(LoginRespModel, \"$response.body#/data/token\", desc=\"test links model\")\n\n\ntoken_query_api_key: api_key.APIKey = api_key.APIKey(\n    name=\"token\",\n    field=Query(links=link_login_token_model),\n    verify_api_key_callable=lambda x: \"token\" in x,\n    security_name=\"token-query-api-key\",\n)\n\n\n@pait()\nasync def api_key_query_route(token: str = Depends.i(token_query_api_key)) -&gt; HTTPResponse:\n    return json({\"code\": 0, \"msg\": \"\", \"data\": token})\n\n\napp = Sanic(name=\"demo\")\napp.add_route(login_route, \"/api/login\", methods=[\"POST\"])\napp.add_route(api_key_query_route, \"/api/api-query-key\", methods=[\"GET\"])\nAddDocRoute(app)\n\n\nif __name__ == \"__main__\":\n    import uvicorn\n\n    uvicorn.run(app)\n</code></pre> docs_source_code/openapi/security/tornado_with_apikey_and_link_demo.py<pre><code>import hashlib\nfrom typing import Type\n\nfrom pydantic import BaseModel, Field\nfrom tornado.ioloop import IOLoop\nfrom tornado.web import Application, RequestHandler\n\nfrom pait.app.tornado import pait\nfrom pait.app.tornado.security import api_key\nfrom pait.field import Depends, Json, Query\nfrom pait.model.response import JsonResponseModel\nfrom pait.openapi.doc_route import AddDocRoute\nfrom pait.openapi.openapi import LinksModel\n\n\nclass LoginRespModel(JsonResponseModel):\n    class ResponseModel(BaseModel):\n        class DataModel(BaseModel):\n            token: str\n\n        code: int = Field(0, description=\"api code\")\n        msg: str = Field(\"success\", description=\"api status msg\")\n        data: DataModel\n\n    description: str = \"login response\"\n    response_data: Type[BaseModel] = ResponseModel\n\n\nclass LoginHandler(RequestHandler):\n    @pait(response_model_list=[LoginRespModel])\n    async def post(\n        self, uid: str = Json.i(description=\"user id\"), password: str = Json.i(description=\"password\")\n    ) -&gt; None:\n        self.write(\n            {\"code\": 0, \"msg\": \"\", \"data\": {\"token\": hashlib.sha256((uid + password).encode(\"utf-8\")).hexdigest()}}\n        )\n\n\nlink_login_token_model: LinksModel = LinksModel(LoginRespModel, \"$response.body#/data/token\", desc=\"test links model\")\n\n\ntoken_query_api_key: api_key.APIKey = api_key.APIKey(\n    name=\"token\",\n    field=Query(links=link_login_token_model),\n    verify_api_key_callable=lambda x: \"token\" in x,\n    security_name=\"token-query-api-key\",\n)\n\n\nclass APIKeyQueryHandler(RequestHandler):\n    @pait()\n    async def get(self, token: str = Depends.i(token_query_api_key)) -&gt; None:\n        self.write({\"code\": 0, \"msg\": \"\", \"data\": token})\n\n\napp: Application = Application(\n    [\n        (r\"/api/login\", LoginHandler),\n        (r\"/api/security/api-query-key\", APIKeyQueryHandler),\n    ],\n)\nAddDocRoute(app)\n\n\nif __name__ == \"__main__\":\n    app.listen(8000)\n    IOLoop.instance().start()\n</code></pre> <p>The first highlighted code is from Field-Links, while the <code>Query</code> in the second highlighted code sets the <code>links</code> attribute to <code>link_login_token_model</code>. This way <code>Pait</code> will bind <code>login_route</code> to <code>api_key_query_route</code> via Link when generating OpenAPI.</p> <p>Note</p> <p><code>openapi_include=False</code> causes <code>Swggaer</code> to be unable to display Link data.</p>"},{"location":"3_3_security/#2http","title":"2.HTTP","text":"<p>There are two types of HTTP basic authentication, one is <code>HTTPBasic</code> and the other is <code>HTTPBearer</code> or <code>HTTPDIgest</code>. The difference between the two is that <code>HTTPBasic</code> needs to verify the <code>username</code> and <code>password</code> parameters in the request header, and if the verification is successful, it means the authentication is successful. If the validation error will return <code>401</code> response, the browser will pop up a window to let the user enter <code>username</code> and <code>password</code>. While <code>HTTPBearer</code> or <code>HTTPDIgest</code> only need to pass <code>token</code> in the request header as required.</p> <p><code>Pait</code> encapsulates the <code>HTTPBasic</code>, <code>HTTPBearer</code> and <code>HTTPDigest</code> classes for each of the three methods of HTTP basic authentication. Like <code>APIKey</code> they need to be bound to a route function via <code>Depend</code>, which is used as follows:</p> FlaskStarletteSanicTornado docs_source_code/openapi/security/flask_with_http_demo.py<pre><code>from typing import Optional\n\nfrom flask import Flask\n\nfrom pait.app.flask import pait\nfrom pait.app.flask.security import http\nfrom pait.field import Depends\nfrom pait.openapi.doc_route import AddDocRoute\n\n##############\n# HTTP Basic #\n##############\nhttp_basic: http.HTTPBasic = http.HTTPBasic()\n\n\ndef get_user_name(credentials: Optional[http.HTTPBasicCredentials] = Depends.i(http_basic)) -&gt; str:\n    if not credentials or credentials.username != credentials.password:\n        raise http_basic.not_authorization_exc\n    return credentials.username\n\n\n@pait()\ndef get_user_name_by_http_basic_credentials(user_name: str = Depends.t(get_user_name)) -&gt; dict:\n    return {\"code\": 0, \"msg\": \"\", \"data\": user_name}\n\n\n#############\n# HTTP Bear #\n#############\nhttp_bear: http.HTTPBearer = http.HTTPBearer(verify_callable=lambda x: \"http\" in x)\n\n\n@pait()\ndef get_user_name_by_http_bearer(credentials: Optional[str] = Depends.i(http_bear)) -&gt; dict:\n    return {\"code\": 0, \"msg\": \"\", \"data\": credentials}\n\n\n###############\n# HTTP Digest #\n###############\nhttp_digest: http.HTTPDigest = http.HTTPDigest(verify_callable=lambda x: \"http\" in x)\n\n\n@pait()\ndef get_user_name_by_http_digest(credentials: Optional[str] = Depends.i(http_digest)) -&gt; dict:\n    return {\"code\": 0, \"msg\": \"\", \"data\": credentials}\n\n\napp = Flask(\"demo\")\napp.add_url_rule(\n    \"/api/user-name-by-http-basic-credentials\",\n    view_func=get_user_name_by_http_basic_credentials,\n    methods=[\"GET\"],\n)\napp.add_url_rule(\"/api/user-name-by-http-bearer\", view_func=get_user_name_by_http_bearer, methods=[\"GET\"])\napp.add_url_rule(\"/api/user-name-by-http-digest\", view_func=get_user_name_by_http_digest, methods=[\"GET\"])\nAddDocRoute(app)\n\n\nif __name__ == \"__main__\":\n    app.run(port=8000)\n</code></pre> docs_source_code/openapi/security/starlette_with_http_demo.py<pre><code>from typing import Optional\n\nfrom starlette.applications import Starlette\nfrom starlette.responses import JSONResponse\nfrom starlette.routing import Route\n\nfrom pait.app.starlette import pait\nfrom pait.app.starlette.security import http\nfrom pait.field import Depends\nfrom pait.openapi.doc_route import AddDocRoute\n\n##############\n# HTTP Basic #\n##############\nhttp_basic: http.HTTPBasic = http.HTTPBasic()\n\n\ndef get_user_name(credentials: Optional[http.HTTPBasicCredentials] = Depends.t(http_basic)) -&gt; str:\n    if not credentials or credentials.username != credentials.password:\n        raise http_basic.not_authorization_exc\n    return credentials.username\n\n\n@pait()\nasync def get_user_name_by_http_basic_credentials(user_name: str = Depends.t(get_user_name)) -&gt; JSONResponse:\n    return JSONResponse({\"code\": 0, \"msg\": \"\", \"data\": user_name})\n\n\n#############\n# HTTP Bear #\n#############\nhttp_bear: http.HTTPBearer = http.HTTPBearer(verify_callable=lambda x: \"http\" in x)\n\n\n@pait()\nasync def get_user_name_by_http_bearer(credentials: Optional[str] = Depends.t(http_bear)) -&gt; JSONResponse:\n    return JSONResponse({\"code\": 0, \"msg\": \"\", \"data\": credentials})\n\n\n###############\n# HTTP Digest #\n###############\nhttp_digest: http.HTTPDigest = http.HTTPDigest(verify_callable=lambda x: \"http\" in x)\n\n\n@pait()\nasync def get_user_name_by_http_digest(credentials: Optional[str] = Depends.t(http_digest)) -&gt; JSONResponse:\n    return JSONResponse({\"code\": 0, \"msg\": \"\", \"data\": credentials})\n\n\napp = Starlette(\n    routes=[\n        Route(\"/api/user-name-by-http-basic-credentials\", get_user_name_by_http_basic_credentials, methods=[\"GET\"]),\n        Route(\"/api/user-name-by-http-bearer\", get_user_name_by_http_bearer, methods=[\"GET\"]),\n        Route(\"/api/user-name-by-http-digest\", get_user_name_by_http_digest, methods=[\"GET\"]),\n    ]\n)\nAddDocRoute(app)\n\n\nif __name__ == \"__main__\":\n    import uvicorn\n\n    uvicorn.run(app)\n</code></pre> docs_source_code/openapi/security/sanic_with_http_demo.py<pre><code>from typing import Optional\n\nfrom sanic import Sanic, response\n\nfrom pait.app.sanic import pait\nfrom pait.app.sanic.security import http\nfrom pait.field import Depends\nfrom pait.openapi.doc_route import AddDocRoute\n\n##############\n# HTTP Basic #\n##############\nhttp_basic: http.HTTPBasic = http.HTTPBasic()\n\n\ndef get_user_name(credentials: Optional[http.HTTPBasicCredentials] = Depends.t(http_basic)) -&gt; str:\n    if not credentials or credentials.username != credentials.password:\n        raise http_basic.not_authorization_exc\n    return credentials.username\n\n\n@pait()\nasync def get_user_name_by_http_basic_credentials(user_name: str = Depends.t(get_user_name)) -&gt; response.HTTPResponse:\n    return response.json({\"code\": 0, \"msg\": \"\", \"data\": user_name})\n\n\n#############\n# HTTP Bear #\n#############\nhttp_bear: http.HTTPBearer = http.HTTPBearer(verify_callable=lambda x: \"http\" in x)\n\n\n@pait()\nasync def get_user_name_by_http_bearer(credentials: Optional[str] = Depends.t(http_bear)) -&gt; response.HTTPResponse:\n    return response.json({\"code\": 0, \"msg\": \"\", \"data\": credentials})\n\n\n###############\n# HTTP Digest #\n###############\nhttp_digest: http.HTTPDigest = http.HTTPDigest(verify_callable=lambda x: \"http\" in x)\n\n\n@pait()\nasync def get_user_name_by_http_digest(credentials: Optional[str] = Depends.t(http_digest)) -&gt; response.HTTPResponse:\n    return response.json({\"code\": 0, \"msg\": \"\", \"data\": credentials})\n\n\napp = Sanic(name=\"demo\")\napp.add_route(get_user_name_by_http_basic_credentials, \"/api/user-name-by-http-basic-credentials\", methods={\"GET\"})\napp.add_route(get_user_name_by_http_bearer, \"/api/user-name-by-http-bearer\", methods={\"GET\"})\napp.add_route(get_user_name_by_http_digest, \"/api/user-name-by-http-digest\", methods={\"GET\"})\nAddDocRoute(app)\n\n\nif __name__ == \"__main__\":\n    import uvicorn\n\n    uvicorn.run(app)\n</code></pre> docs_source_code/openapi/security/tornado_with_http_demo.py<pre><code>from typing import Optional\n\nfrom tornado.ioloop import IOLoop\nfrom tornado.web import Application, RequestHandler\n\nfrom pait.app.tornado import pait\nfrom pait.app.tornado.security import http\nfrom pait.field import Depends\nfrom pait.openapi.doc_route import AddDocRoute\n\nhttp_basic: http.HTTPBasic = http.HTTPBasic()\n\n\ndef get_user_name(credentials: Optional[http.HTTPBasicCredentials] = Depends.t(http_basic)) -&gt; str:\n    if not credentials or credentials.username != credentials.password:\n        raise http_basic.not_authorization_exc\n    return credentials.username\n\n\nclass UserNameByHttpBasicCredentialsHandler(RequestHandler):\n    @pait()\n    async def get(self, user_name: str = Depends.t(get_user_name)) -&gt; None:\n        self.write({\"code\": 0, \"msg\": \"\", \"data\": user_name})\n\n\n#############\n# HTTP Bear #\n#############\nhttp_bear: http.HTTPBearer = http.HTTPBearer(verify_callable=lambda x: \"http\" in x)\n\n\nclass UserNameByHttpBearerHandler(RequestHandler):\n    @pait()\n    async def get(self, credentials: Optional[str] = Depends.t(http_bear)) -&gt; None:\n        self.write({\"code\": 0, \"msg\": \"\", \"data\": credentials})\n\n\n###############\n# HTTP Digest #\n###############\nhttp_digest: http.HTTPDigest = http.HTTPDigest(verify_callable=lambda x: \"http\" in x)\n\n\nclass UserNameByHttpDigestHandler(RequestHandler):\n    @pait()\n    async def get(self, credentials: Optional[str] = Depends.t(http_digest)) -&gt; None:\n        self.write({\"code\": 0, \"msg\": \"\", \"data\": credentials})\n\n\napp: Application = Application(\n    [\n        (r\"/api/security/user-name-by-http-basic-credentials\", UserNameByHttpBasicCredentialsHandler),\n        (r\"/api/security/user-name-by-http-bearer\", UserNameByHttpBearerHandler),\n        (r\"/api/security/user-name-by-http-digest\", UserNameByHttpDigestHandler),\n    ],\n)\nAddDocRoute(app)\n\n\nif __name__ == \"__main__\":\n    app.listen(8000)\n    IOLoop.instance().start()\n</code></pre> <p>You can see that the whole code consists of two parts, the first part initializes the corresponding basic authentication class, and the second part uses <code>Depend</code> in the route function to get an instance of the authentication class.</p> <p>However, <code>HTTPBasic</code> is used a little differently than the other two, for example, <code>HTTPBasic</code> has different initialization parameters than the other two, which are described in the following table:</p> parameter description security_model OpenAPI Description Model about HTTPBasic, a generic HTTPBasicModel has been provided by default, for customization needs visit OpenAPI's securitySchemeObject security_name Specifies the name of the Security, the name of the basic authentication instance must be different for different roles, the default value is class name. header_field Instance of Header Field for <code>Pait</code> realm The realm parameter of HTTP basic authentication <p>While <code>HTTPBearer</code> and <code>HTTPDigest</code> are used in a similar way as <code>APIKey</code>, they need to be initialized as required and bound to the route function via <code>Depend</code>, their parameters are described as follows:</p> parameter description security_model OpenAPI Description Model about HTTPBasic, a generic HTTPBasicModel has been provided by default, for customization needs visit OpenAPI's securitySchemeObject security_name Specifies the name of the Security, the name of the basic authentication instance must be different for different roles, the default value is class name. header_field Instance of Header Field for <code>Pait</code> is_raise When set to <code>True</code>, <code>Pait</code> throws a standard error if parsing fails, and <code>False</code> returns <code>None</code> if parsing fails, default <code>True</code>. verify_callable Accepts a checksum function, <code>Pait</code> extracts the value from the request body and passes it to the checksum function, if it returns <code>True</code> it means the checksum passes, otherwise the checksum fails. <p>In addition to the difference in initialization parameters, <code>HTTPBasic</code> is not used directly in the route function, but exists in the <code>get_user_name</code> function and the <code>get_user_name</code> function is responsible for authentication. returning the username to the route function if the authentication is successful, otherwise returning a <code>401</code> response.</p> <p>After running the code, execute the <code>curl</code> command to see them executed as follows: <pre><code># Success Result\n\u279c  curl -X 'GET' \\\n  'http://127.0.0.1:8000/api/user-name-by-http-basic-credentials' \\\n  -H 'accept: */*' \\\n  -H 'Authorization: Basic c28xbjpzbzFu'\n\n{\"code\":0,\"data\":\"so1n\",\"msg\":\"\"}\n\n\u279c   curl -X 'GET' \\\n  'http://127.0.0.1:8000/api/user-name-by-http-bearer' \\\n  -H 'accept: */*' \\\n  -H 'Authorization: Bearer http'\n\n{\"code\":0,\"data\":\"http\",\"msg\":\"\"}\n\n\u279c  curl -X 'GET' \\\n  'http://127.0.0.1:8000/api/user-name-by-http-digest' \\\n  -H 'accept: */*' \\\n  -H 'Authorization: Digest http'\n\n{\"code\":0,\"data\":\"http\",\"msg\":\"\"}\n\n# Fail Result\n\u279c  curl -X 'GET' \\\n  'http://127.0.0.1:8000/api/user-name-by-http-digest' \\\n  -H 'accept: */*' \\\n  -H 'Authorization: Digest '\n\n&lt;!DOCTYPE HTML PUBLIC \"-//W3C//DTD HTML 3.2 Final//EN\"&gt;\n&lt;title&gt;403 Forbidden&lt;/title&gt;\n&lt;h1&gt;Forbidden&lt;/h1&gt;\n&lt;p&gt;Not authenticated&lt;/p&gt;\n\n\u279c  curl -X 'GET' \\\n  'http://127.0.0.1:8000/api/user-name-by-http-bearer' \\\n  -H 'accept: */*' \\\n  -H 'Authorization: Bearer '\n\n&lt;!DOCTYPE HTML PUBLIC \"-//W3C//DTD HTML 3.2 Final//EN\"&gt;\n&lt;title&gt;403 Forbidden&lt;/title&gt;\n&lt;h1&gt;Forbidden&lt;/h1&gt;\n&lt;p&gt;Not authenticated&lt;/p&gt;\n</code></pre></p> <p>Note</p> <p>The <code>HTTPDigest</code> class only provides simple <code>HTTPDigest</code> authentication support, which needs to be modified to suit your business logic when using it.</p>"},{"location":"3_3_security/#3oauth2","title":"3.Oauth2","text":"<p>OAuth 2.0 is an authorization protocol that provides API clients with limited access to user data on the Web server. In addition to providing identity verification, it also supports privilege verification, which is used as follows:</p> FlaskStarletteSanicTornado docs_source_code/openapi/security/flask_with_oauth2_demo.py<pre><code>import random\nimport string\nfrom typing import TYPE_CHECKING, Callable, Dict, List, Optional\n\nfrom flask import Flask\nfrom pydantic import BaseModel, Field\nfrom werkzeug.exceptions import BadRequest\n\nfrom pait.app.flask import pait\nfrom pait.app.flask.security import oauth2\nfrom pait.field import Depends\nfrom pait.model.response import Http400RespModel\nfrom pait.openapi.doc_route import AddDocRoute\n\nif TYPE_CHECKING:\n    from pait.app.base.security.oauth2 import BaseOAuth2PasswordBearerProxy\n\n\nclass User(BaseModel):\n    uid: str = Field(..., description=\"user id\")\n    name: str = Field(..., description=\"user name\")\n    age: int = Field(..., description=\"user age\")\n    sex: str = Field(..., description=\"user sex\")\n    scopes: List[str] = Field(..., description=\"user scopes\")\n\n\ntemp_token_dict: Dict[str, User] = {}\n\n\n@pait(\n    response_model_list=[Http400RespModel, oauth2.OAuth2PasswordBearerJsonRespModel],\n)\ndef oauth2_login(form_data: oauth2.OAuth2PasswordRequestFrom) -&gt; dict:\n    if form_data.username != form_data.password:\n        raise BadRequest()\n    token: str = \"\".join(random.choice(string.ascii_letters + string.digits) for _ in range(10))\n    temp_token_dict[token] = User(uid=\"123\", name=form_data.username, age=23, sex=\"M\", scopes=form_data.scope)\n    return oauth2.OAuth2PasswordBearerJsonRespModel.response_data(access_token=token).dict()\n\n\noauth2_pb: oauth2.OAuth2PasswordBearer = oauth2.OAuth2PasswordBearer(\n    route=oauth2_login,\n    scopes={\n        \"user-info\": \"get all user info\",\n        \"user-name\": \"only get user name\",\n    },\n)\n\n\ndef get_current_user(_oauth2_pb: \"BaseOAuth2PasswordBearerProxy\") -&gt; Callable[[str], User]:\n    def _check_scope(token: str = Depends.i(_oauth2_pb)) -&gt; User:\n        user_model: Optional[User] = temp_token_dict.get(token, None)\n        if not user_model:\n            raise _oauth2_pb.security.not_authenticated_exc\n        if not _oauth2_pb.is_allow(user_model.scopes):\n            raise _oauth2_pb.security.not_authenticated_exc\n        return user_model\n\n    return _check_scope\n\n\n@pait()\ndef oauth2_user_name(user_model: User = Depends.t(get_current_user(oauth2_pb.get_depend([\"user-name\"])))) -&gt; dict:\n    return {\"code\": 0, \"msg\": \"\", \"data\": user_model.name}\n\n\n@pait()\ndef oauth2_user_info(user_model: User = Depends.t(get_current_user(oauth2_pb.get_depend([\"user-info\"])))) -&gt; dict:\n    return {\"code\": 0, \"msg\": \"\", \"data\": user_model.dict()}\n\n\napp = Flask(\"demo\")\napp.add_url_rule(\"/api/oauth2-login\", view_func=oauth2_login, methods=[\"POST\"])\napp.add_url_rule(\"/api/oauth2-user-name\", view_func=oauth2_user_name, methods=[\"GET\"])\napp.add_url_rule(\"/api/oauth2-user-info\", view_func=oauth2_user_info, methods=[\"GET\"])\nAddDocRoute(app)\n\n\nif __name__ == \"__main__\":\n    app.run(port=8000)\n</code></pre> docs_source_code/openapi/security/starlette_with_oauth2_demo.py<pre><code>import random\nimport string\nfrom typing import TYPE_CHECKING, Callable, Dict, List, Optional\n\nfrom pydantic import BaseModel, Field\nfrom starlette.applications import Starlette\nfrom starlette.exceptions import HTTPException\nfrom starlette.responses import JSONResponse\n\nfrom pait.app.starlette import pait\nfrom pait.app.starlette.security import oauth2\nfrom pait.field import Depends\nfrom pait.model.response import Http400RespModel, TextResponseModel\n\nif TYPE_CHECKING:\n    from pait.app.base.security.oauth2 import BaseOAuth2PasswordBearerProxy\n\n\nclass User(BaseModel):\n    uid: str = Field(..., description=\"user id\")\n    name: str = Field(..., description=\"user name\")\n    age: int = Field(..., description=\"user age\")\n    sex: str = Field(..., description=\"user sex\")\n    scopes: List[str] = Field(..., description=\"user scopes\")\n\n\ntemp_token_dict: Dict[str, User] = {}\n\n\n@pait(\n    response_model_list=[\n        oauth2.OAuth2PasswordBearerJsonRespModel,\n        Http400RespModel.clone(resp_model=TextResponseModel),\n    ],\n)\nasync def oauth2_login(form_data: oauth2.OAuth2PasswordRequestFrom) -&gt; JSONResponse:\n    if form_data.username != form_data.password:\n        raise HTTPException(400)\n    token: str = \"\".join(random.choice(string.ascii_letters + string.digits) for _ in range(10))\n    temp_token_dict[token] = User(uid=\"123\", name=form_data.username, age=23, sex=\"M\", scopes=form_data.scope)\n    return JSONResponse(oauth2.OAuth2PasswordBearerJsonRespModel.response_data(access_token=token).dict())\n\n\noauth2_pb: oauth2.OAuth2PasswordBearer = oauth2.OAuth2PasswordBearer(\n    route=oauth2_login,\n    scopes={\n        \"user-info\": \"get all user info\",\n        \"user-name\": \"only get user name\",\n    },\n)\n\n\ndef get_current_user(_oauth2_pb: \"BaseOAuth2PasswordBearerProxy\") -&gt; Callable[[str], User]:\n    def _check_scope(token: str = Depends.i(_oauth2_pb)) -&gt; User:\n        user_model: Optional[User] = temp_token_dict.get(token, None)\n        if not user_model:\n            raise _oauth2_pb.security.not_authenticated_exc\n        if not _oauth2_pb.is_allow(user_model.scopes):\n            raise _oauth2_pb.security.not_authenticated_exc\n        return user_model\n\n    return _check_scope\n\n\n@pait()\ndef oauth2_user_name(\n    user_model: User = Depends.t(get_current_user(oauth2_pb.get_depend([\"user-name\"]))),\n) -&gt; JSONResponse:\n    return JSONResponse({\"code\": 0, \"msg\": \"\", \"data\": user_model.name})\n\n\n@pait()\ndef oauth2_user_info(\n    user_model: User = Depends.t(get_current_user(oauth2_pb.get_depend([\"user-info\"]))),\n) -&gt; JSONResponse:\n    return JSONResponse({\"code\": 0, \"msg\": \"\", \"data\": user_model.dict()})\n\n\napp = Starlette()\napp.add_route(\"/api/oauth2-login\", oauth2_login, methods=[\"POST\"])\napp.add_route(\"/api/oauth2-user-name\", oauth2_user_name, methods=[\"GET\"])\napp.add_route(\"/api/oauth2-user-info\", oauth2_user_info, methods=[\"GET\"])\n\n\nif __name__ == \"__main__\":\n    import uvicorn\n\n    uvicorn.run(app)\n</code></pre> docs_source_code/openapi/security/sanic_with_oauth2_demo.py<pre><code>import random\nimport string\nfrom typing import TYPE_CHECKING, Callable, Dict, List, Optional\n\nfrom pydantic import BaseModel, Field\nfrom sanic import HTTPResponse, Sanic, json\nfrom sanic.exceptions import InvalidUsage\n\nfrom pait.app.sanic import pait\nfrom pait.app.sanic.security import oauth2\nfrom pait.field import Depends\nfrom pait.model.response import Http400RespModel\nfrom pait.openapi.doc_route import AddDocRoute\n\nif TYPE_CHECKING:\n    from pait.app.base.security.oauth2 import BaseOAuth2PasswordBearerProxy\n\n\nclass User(BaseModel):\n    uid: str = Field(..., description=\"user id\")\n    name: str = Field(..., description=\"user name\")\n    age: int = Field(..., description=\"user age\")\n    sex: str = Field(..., description=\"user sex\")\n    scopes: List[str] = Field(..., description=\"user scopes\")\n\n\ntemp_token_dict: Dict[str, User] = {}\n\n\n@pait(\n    response_model_list=[Http400RespModel, oauth2.OAuth2PasswordBearerJsonRespModel],\n)\nasync def oauth2_login(form_data: oauth2.OAuth2PasswordRequestFrom) -&gt; HTTPResponse:\n    if form_data.username != form_data.password:\n        raise InvalidUsage(\"Bad Request\")\n    token: str = \"\".join(random.choice(string.ascii_letters + string.digits) for _ in range(10))\n    temp_token_dict[token] = User(uid=\"123\", name=form_data.username, age=23, sex=\"M\", scopes=form_data.scope)\n    return json(oauth2.OAuth2PasswordBearerJsonRespModel.response_data(access_token=token).dict())\n\n\noauth2_pb: oauth2.OAuth2PasswordBearer = oauth2.OAuth2PasswordBearer(\n    route=oauth2_login,\n    scopes={\n        \"user-info\": \"get all user info\",\n        \"user-name\": \"only get user name\",\n    },\n)\n\n\ndef get_current_user(_oauth2_pb: \"BaseOAuth2PasswordBearerProxy\") -&gt; Callable[[str], User]:\n    def _check_scope(token: str = Depends.i(_oauth2_pb)) -&gt; User:\n        user_model: Optional[User] = temp_token_dict.get(token, None)\n        if not user_model:\n            raise _oauth2_pb.security.not_authenticated_exc\n        if not _oauth2_pb.is_allow(user_model.scopes):\n            raise _oauth2_pb.security.not_authenticated_exc\n        return user_model\n\n    return _check_scope\n\n\n@pait()\ndef oauth2_user_name(\n    user_model: User = Depends.t(get_current_user(oauth2_pb.get_depend([\"user-name\"]))),\n) -&gt; HTTPResponse:\n    return json({\"code\": 0, \"msg\": \"\", \"data\": user_model.name})\n\n\n@pait()\nasync def oauth2_user_info(\n    user_model: User = Depends.t(get_current_user(oauth2_pb.get_depend([\"user-info\"]))),\n) -&gt; HTTPResponse:\n    return json({\"code\": 0, \"msg\": \"\", \"data\": user_model.dict()})\n\n\napp = Sanic(name=\"demo\")\napp.add_route(oauth2_login, \"/api/oauth2-login\", methods={\"POST\"})\napp.add_route(oauth2_user_name, \"/api/oauth2-user-name\", methods={\"GET\"})\napp.add_route(oauth2_user_info, \"/api/oauth2-user-info\", methods={\"GET\"})\nAddDocRoute(app)\n\n\nif __name__ == \"__main__\":\n    import uvicorn\n\n    uvicorn.run(app)\n</code></pre> docs_source_code/openapi/security/tornado_with_oauth2_demo.py<pre><code>import random\nimport string\nfrom typing import TYPE_CHECKING, Callable, Dict, List, Optional\n\nfrom pydantic import BaseModel, Field\nfrom tornado.ioloop import IOLoop\nfrom tornado.web import Application, HTTPError, RequestHandler\n\nfrom pait.app.tornado import pait\nfrom pait.app.tornado.security import oauth2\nfrom pait.field import Depends\nfrom pait.model.response import Http400RespModel\nfrom pait.openapi.doc_route import AddDocRoute\n\nif TYPE_CHECKING:\n    from pait.app.base.security.oauth2 import BaseOAuth2PasswordBearerProxy\n\n\nclass User(BaseModel):\n    uid: str = Field(..., description=\"user id\")\n    name: str = Field(..., description=\"user name\")\n    age: int = Field(..., description=\"user age\")\n    sex: str = Field(..., description=\"user sex\")\n    scopes: List[str] = Field(..., description=\"user scopes\")\n\n\ntemp_token_dict: Dict[str, User] = {}\n\n\nclass OAuth2LoginHandler(RequestHandler):\n    @pait(\n        response_model_list=[oauth2.OAuth2PasswordBearerJsonRespModel, Http400RespModel],\n    )\n    async def post(self, form_data: oauth2.OAuth2PasswordRequestFrom) -&gt; None:\n        if form_data.username != form_data.password:\n            raise HTTPError(400)\n        token: str = \"\".join(random.choice(string.ascii_letters + string.digits) for _ in range(10))\n        temp_token_dict[token] = User(uid=\"123\", name=form_data.username, age=23, sex=\"M\", scopes=form_data.scope)\n        self.write(oauth2.OAuth2PasswordBearerJsonRespModel.response_data(access_token=token).dict())\n\n\noauth2_pb: oauth2.OAuth2PasswordBearer = oauth2.OAuth2PasswordBearer(\n    route=OAuth2LoginHandler.post,\n    scopes={\n        \"user-info\": \"get all user info\",\n        \"user-name\": \"only get user name\",\n    },\n)\n\n\ndef get_current_user(_oauth2_pb: \"BaseOAuth2PasswordBearerProxy\") -&gt; Callable[[str], User]:\n    def _check_scope(token: str = Depends.i(_oauth2_pb)) -&gt; User:\n        user_model: Optional[User] = temp_token_dict.get(token, None)\n        if not user_model:\n            raise _oauth2_pb.security.not_authenticated_exc\n        if not _oauth2_pb.is_allow(user_model.scopes):\n            raise _oauth2_pb.security.not_authenticated_exc\n        return user_model\n\n    return _check_scope\n\n\nclass OAuth2UserNameHandler(RequestHandler):\n    @pait()\n    def get(self, user_model: User = Depends.t(get_current_user(oauth2_pb.get_depend([\"user-name\"])))) -&gt; None:\n        self.write({\"code\": 0, \"msg\": \"\", \"data\": user_model.name})\n\n\nclass OAuth2UserInfoHandler(RequestHandler):\n    @pait()\n    def get(self, user_model: User = Depends.t(get_current_user(oauth2_pb.get_depend([\"user-info\"])))) -&gt; None:\n        self.write({\"code\": 0, \"msg\": \"\", \"data\": user_model.dict()})\n\n\napp: Application = Application(\n    [\n        (r\"/api/security/oauth2-login\", OAuth2LoginHandler),\n        (r\"/api/security/oauth2-user-name\", OAuth2UserNameHandler),\n        (r\"/api/security/oauth2-user-info\", OAuth2UserInfoHandler),\n    ],\n)\nAddDocRoute(app)\n\n\nif __name__ == \"__main__\":\n    app.listen(8000)\n    IOLoop.instance().start()\n</code></pre> <p>The first part is to create a Model -- <code>User</code>  about the user's data and a <code>temp_token_dict</code> with <code>key</code> as token <code>value</code> as <code>User</code> to be used to mocker database storage.</p> <p>The second part is to create a standard login route function that takes a parameter of type <code>OAuth2PasswordRequestFrom</code>, which is <code>Pait</code>'s encapsulation of <code>Oauth2</code>'s login parameters, and which has the following source code: <pre><code>from pydantic import BaseModel\nfrom pait.field import Form\n\nclass BaseOAuth2PasswordRequestFrom(BaseModel):\n    username: str = Form()\n    password: str = Form()\n    scope: ScopeType = Form(\"\")\n    client_id: Optional[str] = Form(None)\n    client_secret: Optional[str] = Form(None)\n\n\nclass OAuth2PasswordRequestFrom(BaseOAuth2PasswordRequestFrom):\n    grant_type: Optional[str] = Form(None, regex=\"password\")\n</code></pre> can see that <code>OAuth2PasswordRequestFrom</code> inherits <code>BaseModel</code> and uses <code>Form</code> for the <code>Field</code> of all its parameters, which means that its parameters get data from the form in the request body. While the login route function simply checks the data after receiving it, and returns a 400 response if the check is wrong. If it passes, it generates a <code>token</code> and stores the <code>token</code> and <code>User</code> in <code>temp_token_dict</code> and returns the Oauth2 standard response via <code>oauth2.OAuth2PasswordBearerJsonRespModel</code>.</p> <p>The third part is the creation of an instance of <code>oauth2_pb</code> via <code>oauth2.OAuth2PasswordBearer</code> as well as the creation of a function  -- <code>get-current_user</code>to get the user. The <code>scopes</code> parameter to create <code>oauth2_pb</code> is the permission description of <code>oauth2_pb</code> and the <code>route</code> parameter is the login route function, when the route function registers with the web framework, <code>oauth2_pb</code> will find the URL of the route function and writes it to the <code>tokenUrl</code> attribute. The <code>get_current_user</code> function will get the current user through the Token, and then through the <code>is_allow</code> method to determine whether the current user has permission to access the route function, if not, then return a 403 response, if so, then return <code>User</code> Model. Note that the <code>get_current_user</code> function receives the value of the <code>oauth2.OAuth2PasswordBearer</code> proxy class, which already specifies only which permissions are allowed(by <code>oauth2_pb.get_depend</code> method). In addition, the class has two functions, one that passes the requested parameters to the function via <code>Depend</code>, and the other that provides the <code>is_allow</code> method for determining whether the user has permission to access the interface.</p> <p>The fourth part is the route functions, which use the <code>get_current_user</code> function created in the third part. where <code>oauth2_pb.get_depend([\"user-name\"])</code> creates an instance of a proxy that only allows access with <code>user-name</code> privileges, via <code>oauth2.OAuth2PasswordBearer</code>. <code>oauth2_pb.get_depend([\"user-info\"])</code> will create a proxy instance that only allows access with <code>user-info</code> permissions via <code>oauth2.OAuth2PasswordBearer</code>. The only difference between them is that the <code>scopes</code> are different.</p> <p>After running the code, run the <code>curl</code> command to see them executed as follows: <pre><code>\u279c  curl 'http://127.0.0.1:8000/api/oauth2-login' \\\n  -H 'Content-Type: application/x-www-form-urlencoded' \\\n  --data-raw 'grant_type=password&amp;scope=user-info&amp;username=so1n&amp;password=so1n' \\\n\n{\"access_token\":\"pomeG4jCDh\",\"token_type\":\"bearer\"}\n\n\u279c  curl 'http://127.0.0.1:8000/api/oauth2-login' \\\n  -H 'Content-Type: application/x-www-form-urlencoded' \\\n  --data-raw 'grant_type=password&amp;scope=user-name&amp;username=so1n1&amp;password=so1n1' \\\n\n{\"access_token\":\"G8ckqKGkDO\",\"token_type\":\"bearer\"}\n\n\u279c  curl -X 'GET' \\\n  'http://127.0.0.1:8000/api/oauth2-user-info' \\\n  -H 'accept: */*' \\\n  -H 'Authorization: Bearer pomeG4jCDh'\n\n{\"code\":0,\"data\":{\"age\":23,\"name\":\"so1n\",\"scopes\":[\"user-info\"],\"sex\":\"M\",\"uid\":\"123\"},\"msg\":\"\"}\n\n\u279c  curl -X 'GET' \\\n  'http://127.0.0.1:8000/api/oauth2-user-info' \\\n  -H 'accept: */*' \\\n  -H 'Authorization: Bearer G8ckqKGkDO'\n\n&lt;!DOCTYPE HTML PUBLIC \"-//W3C//DTD HTML 3.2 Final//EN\"&gt;\n&lt;title&gt;401 Unauthorized&lt;/title&gt;\n&lt;h1&gt;Unauthorized&lt;/h1&gt;\n&lt;p&gt;Not authenticated&lt;/p&gt;\n\n\u279c  curl -X 'GET' \\\n  'http://127.0.0.1:8000/api/oauth2-user-name' \\\n  -H 'accept: */*' \\\n  -H 'Authorization: Bearer pomeG4jCDh'\n\n&lt;!DOCTYPE HTML PUBLIC \"-//W3C//DTD HTML 3.2 Final//EN\"&gt;\n&lt;title&gt;401 Unauthorized&lt;/title&gt;\n&lt;h1&gt;Unauthorized&lt;/h1&gt;\n&lt;p&gt;Not authenticated&lt;/p&gt;\n\n\u279c  curl -X 'GET' \\\n  'http://127.0.0.1:8000/api/oauth2-user-name' \\\n  -H 'accept: */*' \\\n  -H 'Authorization: Bearer G8ckqKGkDO'\n{\"code\":0,\"data\":\"so1n1\",\"msg\":\"\"}\n</code></pre> The response result shows that a user with permission <code>user-info</code> can only access <code>/api/oauth2-user-info</code>, while a user with permission <code>user-name</code> can only access <code>/api/oauth2-user-name</code>.</p> <p>Note</p> <p>The current version does not support <code>refresh Url</code> yet</p>"},{"location":"4_unit_test_helper/","title":"Unit test helper","text":"<p>Currently, <code>Pait</code> provides a simple unit test support through <code>TestHelper</code>, which runs tests by automatically adding URLs, HTTP methods and other parameters by route functions. And when getting the result, it will get the most matching response model from <code>response_modle_list</code> for simple validation, thus reducing the amount of code required for developers to write test cases.</p>"},{"location":"4_unit_test_helper/#1usage-of-testhelper","title":"1.Usage of TestHelper","text":"<p>The sample code used this time is to expand the sample code on the home page, the main change is to add a parameter named <code>return_error_resp</code> in the route function, when <code>return_error_resp</code> is <code>True</code> it will return a response that does not match the response model, the code is as follows:</p> FlaskStarletteSanicTornado docs_source_code/unit_test_helper/flask_test_helper_demo.py<pre><code># flake8: noqa: E402\nfrom typing import Type\n\nfrom flask import Flask, Response, jsonify\nfrom pydantic import BaseModel, Field\n\nfrom pait.app.flask import pait\nfrom pait.field import Json\nfrom pait.model.response import JsonResponseModel\n\n\nclass DemoResponseModel(JsonResponseModel):\n    class ResponseModel(BaseModel):\n        uid: int = Field()\n        user_name: str = Field()\n\n    description: str = \"demo response\"\n    response_data: Type[BaseModel] = ResponseModel\n\n\n@pait(response_model_list=[DemoResponseModel])\ndef demo_post(\n    uid: int = Json.t(description=\"user id\", gt=10, lt=1000),\n    username: str = Json.t(description=\"user name\", min_length=2, max_length=4),\n    return_error_resp: bool = Json.i(description=\"return error resp\", default=False),\n) -&gt; Response:\n    if return_error_resp:\n        return jsonify()\n    return jsonify({\"uid\": uid, \"user_name\": username, \"a\": 123})\n\n\napp.run(port=8000)\n</code></pre> docs_source_code/unit_test_helper/starlette_test_helper_demo.py<pre><code># flake8: noqa: E402\nfrom typing import Type\n\nfrom pydantic import BaseModel, Field\nfrom starlette.applications import Starlette\nfrom starlette.responses import JSONResponse\nfrom starlette.routing import Route\n\nfrom pait.app.starlette import pait\nfrom pait.field import Json\nfrom pait.model.response import JsonResponseModel\n\n\nclass DemoResponseModel(JsonResponseModel):\n    class ResponseModel(BaseModel):\n        uid: int = Field()\n        user_name: str = Field()\n\n    description: str = \"demo response\"\n    response_data: Type[BaseModel] = ResponseModel\n\n\n@pait(response_model_list=[DemoResponseModel])\nasync def demo_post(\n    uid: int = Json.t(description=\"user id\", gt=10, lt=1000),\n    username: str = Json.t(description=\"user name\", min_length=2, max_length=4),\n    return_error_resp: bool = Json.i(description=\"return error resp\", default=False),\n) -&gt; JSONResponse:\n    if return_error_resp:\n        return JSONResponse({})\n    return JSONResponse({\"uid\": uid, \"user_name\": username})\n\n\nimport uvicorn\nuvicorn.run(app)\n</code></pre> docs_source_code/unit_test_helper/sanic_test_helper_demo.py<pre><code># flake8: noqa: E402\nfrom typing import Type\n\nfrom pydantic import BaseModel, Field\nfrom sanic.app import Sanic\nfrom sanic.response import HTTPResponse, json\n\nfrom pait.app.sanic import pait\nfrom pait.field import Json\nfrom pait.model.response import JsonResponseModel\n\n\nclass DemoResponseModel(JsonResponseModel):\n    class ResponseModel(BaseModel):\n        uid: int = Field()\n        user_name: str = Field()\n\n    description: str = \"demo response\"\n    response_data: Type[BaseModel] = ResponseModel\n\n\n@pait(response_model_list=[DemoResponseModel])\nasync def demo_post(\n    uid: int = Json.t(description=\"user id\", gt=10, lt=1000),\n    username: str = Json.t(description=\"user name\", min_length=2, max_length=4),\n    return_error_resp: bool = Json.i(description=\"return error resp\", default=False),\n) -&gt; HTTPResponse:\n    if return_error_resp:\n        return json({})\n    return json({\"uid\": uid, \"user_name\": username})\n\n\n\nimport uvicorn\nuvicorn.run(app)\n</code></pre> docs_source_code/unit_test_helper/tornado_test_helper_demo.py<pre><code># flake8: noqa: E402\nfrom typing import Type\n\nfrom pydantic import BaseModel, Field\nfrom tornado.web import Application, RequestHandler\n\nfrom pait.app.tornado import pait\nfrom pait.field import Json\nfrom pait.model.response import JsonResponseModel\n\n\nclass DemoResponseModel(JsonResponseModel):\n    class ResponseModel(BaseModel):\n        uid: int = Field()\n        user_name: str = Field()\n\n    description: str = \"demo response\"\n    response_data: Type[BaseModel] = ResponseModel\n\n\nclass DemoHandler(RequestHandler):\n    @pait(response_model_list=[DemoResponseModel])\n    def post(\n        self,\n        uid: int = Json.t(description=\"user id\", gt=10, lt=1000),\n        username: str = Json.t(description=\"user name\", min_length=2, max_length=4),\n        return_error_resp: bool = Json.i(description=\"return error resp\", default=False),\n    ) -&gt; None:\n        if return_error_resp:\n            self.write({})\n        else:\n            self.write({\"uid\": uid, \"user_name\": username})\n\napp.listen(8000)\n\nfrom tornado.ioloop import IOLoop\nIOLoop.instance().start()\n</code></pre> <p>Then can write test cases with <code>TestHelper</code>, first need to import <code>TestHelper</code> and the test client for the corresponding web framework and also initialize the test framework:.</p> FlaskStarletteSanicTornado <p>Note</p> <p>Since <code>Flask</code> automatically registers the <code>OPTIONS</code> method in the route that registers the <code>POST</code> method, which interferes with the autodiscovery of <code>TestHelper</code>'s HTTP methods, need to block the <code>OPTIONS</code> method with <code>apply_block_http_method_set</code>.</p> docs_source_code/unit_test_helper/flask_test_helper_demo.py<pre><code>from pait.extra.config import apply_block_http_method_set\n\n###########################################################\n# Block the OPTIONS method that Flask automatically adds  #\n###########################################################\nfrom pait.g import config\n\nconfig.init_config(apply_func_list=[apply_block_http_method_set({\"OPTIONS\"})])\n\n\n#############\n# unit test #\n#############\nfrom typing import Generator\n\nimport pytest\nfrom flask.ctx import AppContext\nfrom flask.testing import FlaskClient\n\nfrom pait.app.flask import FlaskTestHelper\n\n\n@pytest.fixture\ndef client() -&gt; Generator[FlaskClient, None, None]:\n    # Flask provides a way to test your application by exposing the Werkzeug test Client\n    # and handling the context locals for you.\n    client: FlaskClient = app.test_client()\n    # Establish an application context before running the tests.\n    ctx: AppContext = app.app_context()\n    ctx.push()\n    yield client  # this is where the testing happens!\n    ctx.pop()\n</code></pre> <p>Note</p> <p>When using <code>with TestClient(app) as client</code>, <code>Starlette</code> automatically calls the app's <code>startup</code> and <code>shutdown</code> methods, which is a good habit to get into when using <code>with TestClient(app) as client</code>, even though it's not used in this test case.</p> docs_source_code/unit_test_helper/starlette_test_helper_demo.py<pre><code>from typing import Generator\n\n#############\n# unit test #\n#############\nimport pytest\nfrom starlette.testclient import TestClient\n\nfrom pait.app.starlette import StarletteTestHelper\n\n\n@pytest.fixture\ndef client() -&gt; Generator[TestClient, None, None]:\n    with TestClient(app) as client:\n        yield client\n</code></pre> docs_source_code/unit_test_helper/sanic_test_helper_demo.py<pre><code>from typing import Generator\n\n#############\n# unit test #\n#############\nimport pytest\nfrom sanic_testing.testing import SanicTestClient\n\nfrom pait.app.sanic import SanicTestHelper\n\n\n@pytest.fixture\ndef client() -&gt; Generator[SanicTestClient, None, None]:\n    yield app.test_client\n</code></pre> <p>Note</p> <p>Currently I don't know how to execute <code>Tornado</code> test cases via <code>Pytest</code>, so I used <code>Tornado</code>'s <code>AsyncHTTPTestCase</code> for initialization. If you know how to execute <code>Tornado</code> test cases via <code>Pytest</code>, feel free to give feedback via issue.</p> docs_source_code/unit_test_helper/tornado_test_helper_demo.py<pre><code>from tornado.testing import AsyncHTTPTestCase\n\n#############\n# unit test #\n#############\nfrom pait.app.tornado import TornadoTestHelper\n\n\nclass TestTornado(AsyncHTTPTestCase):\n    def get_app(self) -&gt; Application:\n        return app\n\n    def get_url(self, path: str) -&gt; str:\n        \"\"\"Returns an absolute url for the given path on the test server.\"\"\"\n        return \"%s://localhost:%s%s\" % (self.get_protocol(), self.get_http_port(), path)\n</code></pre> <p>After writing the initialization code for the test case, it is time to write the test case code, first it will be demonstrated how to write a test case through <code>TestHelper</code> with the following code:</p> FlaskStarletteSanicTornado docs_source_code/unit_test_helper/flask_test_helper_demo.py<pre><code>def test_demo_post_route_by_call_json(client: FlaskClient) -&gt; None:\n    test_helper = FlaskTestHelper(\n        client=client,\n        func=demo_post,\n        body_dict={\"uid\": 11, \"username\": \"test\"},\n    )\n    assert test_helper.json() == {\"uid\": 11, \"user_name\": \"test\"}\n</code></pre> docs_source_code/unit_test_helper/starlette_test_helper_demo.py<pre><code>def test_demo_post_route_by_call_json(client: TestClient) -&gt; None:\n    test_helper = StarletteTestHelper(\n        client=client,\n        func=demo_post,\n        body_dict={\"uid\": 11, \"username\": \"test\"},\n    )\n    assert test_helper.json() == {\"uid\": 11, \"user_name\": \"test\"}\n</code></pre> docs_source_code/unit_test_helper/sanic_test_helper_demo.py<pre><code>def test_demo_post_route_by_call_json(client: SanicTestClient) -&gt; None:\n    test_helper = SanicTestHelper(\n        client=client,\n        func=demo_post,\n        body_dict={\"uid\": 11, \"username\": \"test\"},\n    )\n    assert test_helper.json() == {\"uid\": 11, \"user_name\": \"test\"}\n</code></pre> docs_source_code/unit_test_helper/tornado_test_helper_demo.py<pre><code>class TestTornado(AsyncHTTPTestCase):\n    ...\n\n    def test_demo_post_route_by_call_json(self) -&gt; None:\n        test_helper = TornadoTestHelper(\n            client=self,\n            func=DemoHandler.post,\n            body_dict={\"uid\": 11, \"username\": \"test\"},\n        )\n        assert test_helper.json() == {\"uid\": 11, \"user_name\": \"test\"}\n</code></pre> <p>In this test case, <code>TestHelper</code> will be initialized, <code>TestHelper</code> initialization requires the Web framework corresponding to the test client, the route function, as well as the route function of some of the request parameters, after the initialization is complete, you can get the request response through the <code>TestHelper</code>.</p> <p>While executing the test, <code>TestHelper</code> automatically discovers the <code>URL</code> and HTTP method of the route function. So when calling the <code>json</code> method, <code>TestHelper</code> will automatically initiate a <code>post</code> request and gets the response result. Then it serializes the response Body into a <code>Python</code> <code>dict</code> object and returns it. However, when the route function is bound to more than one request method, <code>TestHelper</code> will not be able to do this automatically, and need to specify the corresponding HTTP method when calling the <code>json</code> method, using the following method:</p> FlaskStarletteSanicTornado docs_source_code/unit_test_helper/flask_test_helper_demo.py<pre><code>def test_demo_post_route_by_use_method(client: FlaskClient) -&gt; None:\n    test_helper = FlaskTestHelper(\n        client=client,\n        func=demo_post,\n        body_dict={\"uid\": 11, \"username\": \"test\"},\n    )\n    assert test_helper.json(method=\"POST\") == {\"uid\": 11, \"user_name\": \"test\"}\n</code></pre> docs_source_code/unit_test_helper/starlette_test_helper_demo.py<pre><code>def test_demo_post_route_by_use_method(client: TestClient) -&gt; None:\n    test_helper = StarletteTestHelper(\n        client=client,\n        func=demo_post,\n        body_dict={\"uid\": 11, \"username\": \"test\"},\n    )\n    assert test_helper.json(method=\"POST\") == {\"uid\": 11, \"user_name\": \"test\"}\n</code></pre> docs_source_code/unit_test_helper/sanic_test_helper_demo.py<pre><code>def test_demo_post_route_by_use_method(client: SanicTestClient) -&gt; None:\n    test_helper = SanicTestHelper(\n        client=client,\n        func=demo_post,\n        body_dict={\"uid\": 11, \"username\": \"test\"},\n    )\n    assert test_helper.json(method=\"POST\") == {\"uid\": 11, \"user_name\": \"test\"}\n</code></pre> docs_source_code/unit_test_helper/tornado_test_helper_demo.py<pre><code>class TestTornado(AsyncHTTPTestCase):\n    ...\n\n    def test_demo_post_route_by_use_method(self) -&gt; None:\n        test_helper = TornadoTestHelper(\n            client=self,\n            func=DemoHandler.post,\n            body_dict={\"uid\": 11, \"username\": \"test\"},\n        )\n        assert test_helper.json(method=\"POST\") == {\"uid\": 11, \"user_name\": \"test\"}\n</code></pre> <p>In addition, when writing test cases, may need a response object, rather than response data, in order to validate data such as status codes, <code>Header</code>, etc. This can be done by calling the <code>HTTP</code> method of the <code>TestHelper</code> and getting the response object. The following code makes a request to the route function via the <code>post</code> method and returns the response object of the Web framework's test client, which is then asserted:</p> FlaskStarletteSanicTornado docs_source_code/unit_test_helper/flask_test_helper_demo.py<pre><code>def test_demo_post_route_by_raw_web_framework_response(client: FlaskClient) -&gt; None:\n    test_helper = FlaskTestHelper(\n        client=client,\n        func=demo_post,\n        body_dict={\"uid\": 11, \"username\": \"test\"},\n    )\n    resp = test_helper.post()\n    assert resp.status_code == 200\n    assert resp.json == {\"uid\": 11, \"user_name\": \"test\"}\n</code></pre> docs_source_code/unit_test_helper/starlette_test_helper_demo.py<pre><code>def test_demo_post_route_by_raw_web_framework_response(client: TestClient) -&gt; None:\n    test_helper = StarletteTestHelper(\n        client=client,\n        func=demo_post,\n        body_dict={\"uid\": 11, \"username\": \"test\"},\n    )\n    resp = test_helper.post()\n    assert resp.status_code == 200\n    assert resp.json() == {\"uid\": 11, \"user_name\": \"test\"}\n</code></pre> docs_source_code/unit_test_helper/sanic_test_helper_demo.py<pre><code>def test_demo_post_route_by_raw_web_framework_response(client: SanicTestClient) -&gt; None:\n    test_helper = SanicTestHelper(\n        client=client,\n        func=demo_post,\n        body_dict={\"uid\": 11, \"username\": \"test\"},\n    )\n    resp = test_helper.post()\n    assert resp.status_code == 200\n    assert resp.json == {\"uid\": 11, \"user_name\": \"test\"}\n</code></pre> docs_source_code/unit_test_helper/tornado_test_helper_demo.py<pre><code>class TestTornado(AsyncHTTPTestCase):\n    ...\n\n    def test_demo_post_route_by_raw_web_framework_response(self) -&gt; None:\n        test_helper = TornadoTestHelper(\n            client=self,\n            func=DemoHandler.post,\n            body_dict={\"uid\": 11, \"username\": \"test\"},\n        )\n        resp = test_helper.post()\n        assert resp.code == 200\n        assert resp.body.decode() == '{\"uid\": 11, \"user_name\": \"test\"}'\n</code></pre> <p>Although in this case <code>TestHelper</code> is not much different from the way it is used with the Web framework's corresponding test client. However, when <code>TestHelper</code> gets the response from the route function, it will pick the best matching response model from the <code>response_model_list</code> of the route function. If one of the response object's HTTP status code, header and response data does not match the response model, an error is thrown and the test case is aborted, for example:</p> FlaskStarletteSanicTornado docs_source_code/unit_test_helper/flask_test_helper_demo.py<pre><code>def test_demo_post_route_by_test_helper_check_response_error(client: FlaskClient) -&gt; None:\n    test_helper = FlaskTestHelper(\n        client=client,\n        func=demo_post,\n        body_dict={\"uid\": 11, \"username\": \"test\", \"return_error_resp\": True},\n    )\n    assert test_helper.json() == {\"uid\": 11, \"user_name\": \"test\"}\n</code></pre> docs_source_code/unit_test_helper/starlette_test_helper_demo.py<pre><code>def test_demo_post_route_by_test_helper_check_response_error(client: TestClient) -&gt; None:\n    test_helper = StarletteTestHelper(\n        client=client,\n        func=demo_post,\n        body_dict={\"uid\": 11, \"username\": \"test\", \"return_error_resp\": True},\n    )\n    assert test_helper.json() == {\"uid\": 11, \"user_name\": \"test\"}\n</code></pre> docs_source_code/unit_test_helper/sanic_test_helper_demo.py<pre><code>def test_demo_post_route_by_test_helper_check_response_error(client: SanicTestClient) -&gt; None:\n    test_helper = SanicTestHelper(\n        client=client,\n        func=demo_post,\n        body_dict={\"uid\": 11, \"username\": \"test\", \"return_error_resp\": True},\n    )\n    assert test_helper.json() == {\"uid\": 11, \"user_name\": \"test\"}\n</code></pre> docs_source_code/unit_test_helper/tornado_test_helper_demo.py<pre><code>class TestTornado(AsyncHTTPTestCase):\n    ...\n\n    def test_demo_post_route_by_test_helper_check_response_error(self) -&gt; None:\n        test_helper = TornadoTestHelper(\n            client=self,\n            func=DemoHandler.post,\n            body_dict={\"uid\": 11, \"username\": \"test\", \"return_error_resp\": True},\n        )\n        assert test_helper.json() == {\"uid\": 11, \"user_name\": \"test\"}\n</code></pre> <p>After executing the test case, <code>TestHelper</code> will find that the response result of the route function does not match the response model of the route function, then it will throw an exception, interrupt the test case and output the result as follows: <pre><code>&gt; raise exc\nE pait.app.base.test_helper.CheckResponseException: maybe error result:\nE &gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;\nE check json content error, exec: 2 validation errors for ResponseModel\nE uid\nE   field required (type=value_error.missing)\nE user_name\nE   field required (type=value_error.missing)\nE\nE &gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;\nE by response model:&lt;class 'docs_source_code.unit_test_helper.flask_test_helper_demo.DemoResponseModel'&gt;\n</code></pre> The output shows that the exception thrown is <code>CheckResponseException</code>. Meanwhile, according to the exception message, can understand that the response model for this validation is <code>DemoResponseModel</code>, and it found that the response data is missing the <code>uid</code> field and <code>user_name</code> field during the validation process.</p>"},{"location":"4_unit_test_helper/#2parameter-introduction","title":"2.Parameter introduction","text":"<p>The parameters of <code>TestHelper</code> are divided into three types: initialization parameters, request-related parameters, and response-related result parameters. Among them, the initialization parameters are described as follows:</p> Parameters Description client The test client for the Web framework func The route function to be tested <p>There are multiple request parameters, which for most web frameworks encapsulate a layer of calls, but for using frameworks such as <code>Tornado</code> that don't encapsulate the test client much, request parameters provide some convenience, and these parameters are described as follows:</p> <ul> <li>body_dict: Json data of the request.</li> <li>cookie_dict: Cookie data of the request.</li> <li>file_dict: File data of the request.</li> <li>form_dict: Form data of the request.</li> <li>header_dict: Header data of the request.</li> <li>path_dict: Path data of the request.</li> <li>query_dict: Query data of the request.</li> </ul> <p>In addition to this, <code>TestHelper</code> has some parameters related to response result validation, such as <code>strict_inspection_check_json_content</code>. By default, the <code>strict_inspection_check_json_content</code> parameter has a value of True, which will allow <code>TestHelper</code> to perform strict checks on the data structure of the response result, as in the following example: <pre><code>a = {\n    \"a\": 1,\n    \"b\": {\n        \"c\": 3\n    }\n}\nb = {\n    \"a\": 2,\n    \"b\": {\n        \"c\": 3,\n        \"d\": 4\n    }\n}\n</code></pre> In this example, <code>a</code> and <code>b</code> have different data structures, where the <code>a</code> represents the data structure of the response model and the <code>b</code> is the data structure of the response body. When <code>TestHelper</code> performs the validation, it will throw an error because it detects an extra structure <code>['b']['d']</code> in the <code>b</code>. However, it is possible to set the parameter <code>strict_inspection_check_json_content</code> to <code>False</code>, so that <code>TestHelper</code> will only validate fields that appear in the response model, and will not check fields outside the response model.</p> <p>In addition to the above, <code>TestHelper</code> has several other parameters, as follows:</p> parameter description target_pait_response_class If the value is not null, then <code>TestHelper</code> will filter a batch of eligible <code>response_models</code> from the <code>response_model_list</code> by <code>target_pait_response_class</code> to perform the calibration. This value is usually the parent class of the response model, and the default value of <code>None</code> means no match. enable_assert_response Indicates whether <code>TestHelper</code> will assert the response result, default value is True."},{"location":"5_1_introduction/","title":"Introduction","text":"<p>The core of <code>Pait</code> is a decorator, this decorator is only responsible for the assembly and arrangement of plugins, and really responsible for the implementation of the function are these plugins that are initialized by the decorator, of which <code>Pait</code>'s type conversion and validation belong a core plugin of <code>Pait</code> -- <code>ParamPlugin</code>.</p>"},{"location":"5_1_introduction/#brief-introdction","title":"Brief Introdction","text":"<p>In addition to the core plugins, plugins can be divided into two main categories, pre plugins that inherit from <code>PrePluginProtocol</code> and post plugins that inherit from <code>PostPluginProtocol</code>.</p> <p>Developers can use plugins that need to be enabled via <code>Pait</code>, after the program is started, <code>Pait</code> will initialize the plugins in order in the form of an interceptor, if the plugin is a pre-plugin then it will be placed before the core plugin, otherwise it will be placed after the core plugin (post-plugin).</p> <p>In addition to the different parent classes inherited by the pre-plugin and the post-plugin, the main difference between them is that the parameters they get when they are called are different. In this case, the pre-plugin gets the request parameters passed by the web framework (which can be thought of as a simple middleware), while the post-plugin gets the request data converted by the <code>Pait</code> core plugin, as exemplified by the following function: <pre><code>import uvicorn  # type: ignore\nfrom starlette.applications import Starlette\nfrom starlette.responses import JSONResponse\nfrom starlette.routing import Route\n\nfrom pait.app.starlette import pait\nfrom pait import field\n\n\n@pait()\nasync def demo(uid: str = field.Query.i(), user_name: str = field.Query.i()) -&gt; JSONResponse:\n    return JSONResponse({\"uid\": uid, \"user_name\": user_name})\n\n\napp = Starlette(routes=[Route(\"/api/demo\", demo, methods=[\"GET\"])])\n\nuvicorn.run(app)\n</code></pre> Assuming that the <code>app</code> in the code has been loaded with a middleware and the corresponding <code>Pait</code> plugin, when a request is received, it will process the request in the following order (using a different way of describing the processing logic, the core logic is the same):</p> graphsequence diagramjpg <pre><code>graph LR\n  A[client] --&gt; |send request| B[Middleware];\n  B --&gt; |recv response| A;\n  B --&gt;  C{Find match route?};\n  C --&gt; |Yes| D[Pre Plugin];\n  C --&gt; |No| B;\n  D --&gt; B;\n  D --&gt; E[Core Plugin];\n  E --&gt; D;\n  E --&gt; F[Post Plugin];\n  F --&gt; E;\n  F --&gt; G[Route Function];\n  G --&gt; F;</code></pre> <pre><code>sequenceDiagram\n  client-&gt;&gt;Middleware: send request\n  Middleware-&gt;&gt;Route Match: Find match route?\n  Route Match-&gt;&gt;Middleware: Success or Fail\n  Middleware-&gt;&gt;client: Route Match Fail, Return Not Found 404\n  Middleware-&gt;&gt;Pre Plugin: Route Match Success, send Request obj\n  Pre Plugin-&gt;&gt;Core Plugin:  send Request obj\n  Core Plugin-&gt;&gt;Post Plugin: send Param:{\"uid\": \"\", \"user_name\":\"\"}\n  Post Plugin-&gt;&gt;Route Function: send Param:{\"uid\": \"\", \"user_name\":\"\"}\n  Route Function-&gt;&gt;Post Plugin: recv Response obj\n  Post Plugin-&gt;&gt;Core Plugin: recv Response obj\n  Core Plugin-&gt;&gt;Pre Plugin: recv Response obj\n  Pre Plugin-&gt;&gt;Middleware: recv Response obj\n  Middleware-&gt;&gt;client: recv Response obj</code></pre> <p></p> <p>In this logic, the request is first processed by the Web framework's middleware, then the Web framework looks for a route and returns a <code>Not Found</code> response to the client if no route can be found, and passes the request to <code>Pait</code> to process if a corresponding route is found. The processing at <code>Pait</code> can be divided into the following steps:</p> <ul> <li>1.The request will be processed by the Pre plugin, at this time the Pre plugin can only get the <code>request</code> parameter corresponding to the framework (or not if it is a <code>flask</code> framework) and the <code>Path</code> parameter.</li> <li>2.When the Pre plugin processing is complete, the request will be passed to the core plugin for parameter extraction and checksum conversion.</li> <li>3.After processing by the core plugin will pass the extracted parameters to the Post plugin, which will be processed by the Post plugin.</li> <li>4.Finally by the Post plugin parameters to the real route function to generate a response and return one by one.</li> </ul>"},{"location":"5_1_introduction/#how-to-use","title":"How to use","text":"<p>Currently <code>Pait</code> receives pre-plugins and post-plugins via <code>plugin_list</code> and <code>post_plugin_list</code> as follows: <pre><code>from pait.app.any import pait\nfrom pait.plugin.required import RequiredPlugin\n\n@pait(post_plugin_list=[RequiredPlugin.build(required_dict={\"email\": [\"username\"]})])\n</code></pre> The sample code uses a post plugin named <code>RequiredPlugin</code>, which needs to be used through the <code>post_plugin_list</code> parameter. At the same time, the plugin needs to be <code>Pait</code> orchestrated before you can use, so the plugin does not support the <code>__init__</code> method initialization, but need to use the <code>build</code> method to initialize the plugin.</p> <p>If reuse of the plugin, it is recommended to use the <code>create_factory</code> function, which uses PEP-612 to support IDE and type checking, <code>create_factory</code> is used as follows: <pre><code>from pait.app.any import pait\nfrom pait.util import create_factory\nfrom pait.plugin.required import RequiredPlugin\n\n# Pass in the plugin's build method and fill in the parameters needed for build to get a plugin build factory function\nrequired_plugin = create_factory(RequiredPlugin.build)(required_dict={\"email\": [\"username\"]})\n\n# Calling `required_plugin` will get a separate plugin that will not be shared with other functions\n@pait(post_plugin_list=[required_plugin()])\ndef demo_1():\n    pass\n\n@pait(post_plugin_list=[required_plugin()])\ndef demo_2():\n    pass\n</code></pre></p>"},{"location":"5_1_introduction/#turn-off-pre-check","title":"Turn off pre check","text":"<p><code>Pait</code> is a decorator used to decorate the route function, so it loaded with various parameters and initialized at program startup. However, the plugin's <code>pre_check_hook</code> method is called before initialization to check if the plugin is being used correctly, as in the following code. <pre><code>from pait.app.any import pait\nfrom pait.field import Body\n\n@pait()\ndef demo(\n    uid: str = Body.i(default=None)\n) -&gt; None:\n    pass\n</code></pre> At program startup the core plugin checks that the <code>default</code> value is not of type <code>str</code>, so an error is thrown. However, <code>pre-check</code> may affect the startup time of the program, so it is recommended to do <code>pre_check</code> only in test environments, and turn it off in production environments. It can be turned off by setting the environment variable <code>PAIT_IGNORE_PRE_CHECK</code> to True.</p>"},{"location":"5_2_param_check_plugin/","title":"Parameter checking plugin","text":"<p><code>Pait</code> is based on <code>Pydantic</code> to perform parameter checking and type conversion for each parameter, which cannot satisfy the need for multiple parameter dependency checking. For this reason, <code>Pait</code> provides two kinds of parameter dependency checking functions through post plugins <code>Required</code> and <code>AtMostOneOf</code>.</p>"},{"location":"5_2_param_check_plugin/#1required-plugin","title":"1.Required Plugin","text":"<p>In the creation of route functions, often encounter some parameter dependencies, such as having a request parameter A, B, C, which B and C are optional and the requirement that B exists, C also needs to exist, B does not exist, C can not exist. At this point, you can use the <code>Required</code> plugin for parameter restriction, the following code:</p> FlaskStarletteSanicTornado docs_source_code/plugin/param_plugin/flask_with_required_plugin_demo.py<pre><code>from typing import Optional\n\nfrom flask import Flask, Response, jsonify\n\nfrom pait import field\nfrom pait.app.flask import pait\nfrom pait.exceptions import TipException\nfrom pait.plugin.required import RequiredPlugin\n\n\ndef api_exception(exc: Exception) -&gt; Response:\n    if isinstance(exc, TipException):\n        exc = exc.exc\n    return jsonify({\"data\": str(exc)})\n\n\n@pait(post_plugin_list=[RequiredPlugin.build(required_dict={\"email\": [\"user_name\"]})])\ndef demo(\n    uid: str = field.Query.i(),\n    user_name: Optional[str] = field.Query.i(default=None),\n    email: Optional[str] = field.Query.i(default=None),\n) -&gt; Response:\n    return jsonify({\"uid\": uid, \"user_name\": user_name, \"email\": email})\n\n\napp = Flask(\"demo\")\napp.add_url_rule(\"/api/demo\", view_func=demo, methods=[\"GET\"])\napp.errorhandler(Exception)(api_exception)\n\n\nif __name__ == \"__main__\":\n    app.run(port=8000)\n</code></pre> docs_source_code/plugin/param_plugin/starlette_with_required_plugin_demo.py<pre><code>from typing import Optional\n\nfrom starlette.applications import Starlette\nfrom starlette.requests import Request\nfrom starlette.responses import JSONResponse\nfrom starlette.routing import Route\n\nfrom pait import field\nfrom pait.app.starlette import pait\nfrom pait.exceptions import TipException\nfrom pait.plugin.required import RequiredPlugin\n\n\nasync def api_exception(request: Request, exc: Exception) -&gt; JSONResponse:\n    if isinstance(exc, TipException):\n        exc = exc.exc\n    return JSONResponse({\"data\": str(exc)})\n\n\n@pait(post_plugin_list=[RequiredPlugin.build(required_dict={\"email\": [\"user_name\"]})])\nasync def demo(\n    uid: str = field.Query.i(),\n    user_name: Optional[str] = field.Query.i(default=None),\n    email: Optional[str] = field.Query.i(default=None),\n) -&gt; JSONResponse:\n    return JSONResponse({\"uid\": uid, \"user_name\": user_name, \"email\": email})\n\n\napp = Starlette(routes=[Route(\"/api/demo\", demo, methods=[\"GET\"])])\napp.add_exception_handler(Exception, api_exception)\n\n\nif __name__ == \"__main__\":\n    import uvicorn\n\n    uvicorn.run(app)\n</code></pre> docs_source_code/plugin/param_plugin/sanic_with_required_plugin_demo.py<pre><code>from typing import Optional\n\nfrom sanic import Request, Sanic\nfrom sanic.response import HTTPResponse, json\n\nfrom pait import field\nfrom pait.app.sanic import pait\nfrom pait.exceptions import TipException\nfrom pait.plugin.required import RequiredPlugin\n\n\nasync def api_exception(request: Request, exc: Exception) -&gt; HTTPResponse:\n    if isinstance(exc, TipException):\n        exc = exc.exc\n    return json({\"data\": str(exc)})\n\n\n@pait(post_plugin_list=[RequiredPlugin.build(required_dict={\"email\": [\"user_name\"]})])\nasync def demo(\n    uid: str = field.Query.i(),\n    user_name: Optional[str] = field.Query.i(default=None),\n    email: Optional[str] = field.Query.i(default=None),\n) -&gt; HTTPResponse:\n    return json({\"uid\": uid, \"user_name\": user_name, \"email\": email})\n\n\napp = Sanic(\"demo\")\napp.add_route(demo, \"/api/demo\", methods=[\"GET\"])\napp.exception(Exception)(api_exception)\n\n\nif __name__ == \"__main__\":\n    import uvicorn\n\n    uvicorn.run(app)\n</code></pre> docs_source_code/plugin/param_plugin/tornado_with_required_plugin_demo.py<pre><code>from typing import Optional\n\nfrom tornado.ioloop import IOLoop\nfrom tornado.web import Application, RequestHandler\n\nfrom pait import field\nfrom pait.app.tornado import pait\nfrom pait.exceptions import TipException\nfrom pait.plugin.required import RequiredPlugin\n\n\nclass _Handler(RequestHandler):\n    def _handle_request_exception(self, exc: BaseException) -&gt; None:\n        if isinstance(exc, TipException):\n            exc = exc.exc\n        self.write({\"data\": str(exc)})\n        self.finish()\n\n\nclass DemoHandler(_Handler):\n    @pait(post_plugin_list=[RequiredPlugin.build(required_dict={\"email\": [\"user_name\"]})])\n    async def get(\n        self,\n        uid: str = field.Query.i(),\n        user_name: Optional[str] = field.Query.i(default=None),\n        email: Optional[str] = field.Query.i(default=None),\n    ) -&gt; None:\n        self.write({\"uid\": uid, \"user_name\": user_name, \"email\": email})\n\n\napp: Application = Application([(r\"/api/demo\", DemoHandler)])\n\n\nif __name__ == \"__main__\":\n    app.listen(8000)\n    IOLoop.instance().start()\n</code></pre> <p>The parameter <code>uid</code> is a required parameter in the route function, while the parameters <code>user_name</code> and <code>email</code> are optional, but a new validation rule is added when the <code>ReuiredPlugin</code> plugin is used. This validation rule is defined by <code>required_dict</code>, which states that the parameter <code>email</code> must depend on a collection of parameters to exist, and that collection has only one parameter -- <code>user_name</code>. So the validation rule for <code>RequiredPlugin</code> is that the parameter <code>email</code> can only exist if the parameter <code>user_name</code> exists.</p> <p>After using <code>curl</code> to send a request through the response results can be found, if the request parameter is only <code>uid</code> can be returned normally, but the request parameter <code>user_name</code> is null, the parameter <code>email</code> must be null, otherwise it will report an error. <pre><code>\u279c ~ curl http://127.0.0.1:8000/api/demo\\?uid\\=123\n{\"uid\":\"123\",\"user_name\":null,\"email\":null}%\n\u279c ~ curl http://127.0.0.1:8000/api/demo\\?uid\\=123\\&amp;email\\=aaa\n{\"data\":\"email requires param user_name, which if not none\"}%\n\u279c ~ curl http://127.0.0.1:8000/api/demo\\?uid\\=123\\&amp;email\\=aaa\\&amp;user_name\\=so1n\n{\"uid\":\"123\",\"user_name\":\"so1n\",\"email\":\"aaa\"}%\n</code></pre></p> <p>The <code>Required</code> plugin can pass dependency rules through the <code>build</code> method, but it can also define rules through the <code>ExtraParam</code> extension parameter. The <code>Required</code> plugin supports both <code>RequiredExtraParam</code> and <code>RequiredGroupExtraParam</code> extension parameter. The following code is a use of <code>RequiredExtraParam</code>, which generates a validation rule for <code>user_name</code> dependent on <code>email</code> via <code>extra_param_list=[RequiredExtraParam(main_column=\"email\")</code>.</p> FlaskStarletteSanicTornado docs_source_code/plugin/param_plugin/flask_with_required_plugin_and_extra_param_demo.py<pre><code>from typing import Optional\n\nfrom flask import Flask, Response, jsonify\n\nfrom pait import field\nfrom pait.app.flask import pait\nfrom pait.exceptions import TipException\nfrom pait.plugin.required import RequiredExtraParam, RequiredPlugin\n\n\ndef api_exception(exc: Exception) -&gt; Response:\n    if isinstance(exc, TipException):\n        exc = exc.exc\n    return jsonify({\"data\": str(exc)})\n\n\n@pait(post_plugin_list=[RequiredPlugin.build()])\ndef demo(\n    uid: str = field.Query.i(),\n    user_name: Optional[str] = field.Query.i(default=None, extra_param_list=[RequiredExtraParam(main_column=\"email\")]),\n    email: Optional[str] = field.Query.i(default=None),\n) -&gt; Response:\n    return jsonify({\"uid\": uid, \"user_name\": user_name, \"email\": email})\n\n\napp = Flask(\"demo\")\napp.add_url_rule(\"/api/demo\", view_func=demo, methods=[\"GET\"])\napp.errorhandler(Exception)(api_exception)\n\n\nif __name__ == \"__main__\":\n    app.run(port=8000)\n</code></pre> docs_source_code/plugin/param_plugin/starlette_with_required_plugin_and_extra_param_demo.py<pre><code>from typing import Optional\n\nfrom starlette.applications import Starlette\nfrom starlette.requests import Request\nfrom starlette.responses import JSONResponse\nfrom starlette.routing import Route\n\nfrom pait import field\nfrom pait.app.starlette import pait\nfrom pait.exceptions import TipException\nfrom pait.plugin.required import RequiredExtraParam, RequiredPlugin\n\n\nasync def api_exception(request: Request, exc: Exception) -&gt; JSONResponse:\n    if isinstance(exc, TipException):\n        exc = exc.exc\n    return JSONResponse({\"data\": str(exc)})\n\n\n@pait(post_plugin_list=[RequiredPlugin.build()])\nasync def demo(\n    uid: str = field.Query.i(),\n    user_name: Optional[str] = field.Query.i(default=None, extra_param_list=[RequiredExtraParam(main_column=\"email\")]),\n    email: Optional[str] = field.Query.i(default=None),\n) -&gt; JSONResponse:\n    return JSONResponse({\"uid\": uid, \"user_name\": user_name, \"email\": email})\n\n\napp = Starlette(routes=[Route(\"/api/demo\", demo, methods=[\"GET\"])])\napp.add_exception_handler(Exception, api_exception)\n\n\nif __name__ == \"__main__\":\n    import uvicorn\n\n    uvicorn.run(app)\n</code></pre> docs_source_code/plugin/param_plugin/sanic_with_required_plugin_and_extra_param_demo.py<pre><code>from typing import Optional\n\nfrom sanic import Request, Sanic\nfrom sanic.response import HTTPResponse, json\n\nfrom pait import field\nfrom pait.app.sanic import pait\nfrom pait.exceptions import TipException\nfrom pait.plugin.required import RequiredExtraParam, RequiredPlugin\n\n\nasync def api_exception(request: Request, exc: Exception) -&gt; HTTPResponse:\n    if isinstance(exc, TipException):\n        exc = exc.exc\n    return json({\"data\": str(exc)})\n\n\n@pait(post_plugin_list=[RequiredPlugin.build()])\nasync def demo(\n    uid: str = field.Query.i(),\n    user_name: Optional[str] = field.Query.i(default=None, extra_param_list=[RequiredExtraParam(main_column=\"email\")]),\n    email: Optional[str] = field.Query.i(default=None),\n) -&gt; HTTPResponse:\n    return json({\"uid\": uid, \"user_name\": user_name, \"email\": email})\n\n\napp = Sanic(\"demo\")\napp.add_route(demo, \"/api/demo\", methods=[\"GET\"])\napp.exception(Exception)(api_exception)\n\n\nif __name__ == \"__main__\":\n    import uvicorn\n\n    uvicorn.run(app)\n</code></pre> docs_source_code/plugin/param_plugin/tornado_with_required_plugin_and_extra_param_demo.py<pre><code>from typing import Optional\n\nfrom tornado.ioloop import IOLoop\nfrom tornado.web import Application, RequestHandler\n\nfrom pait import field\nfrom pait.app.tornado import pait\nfrom pait.exceptions import TipException\nfrom pait.plugin.required import RequiredExtraParam, RequiredPlugin\n\n\nclass _Handler(RequestHandler):\n    def _handle_request_exception(self, exc: BaseException) -&gt; None:\n        if isinstance(exc, TipException):\n            exc = exc.exc\n        self.write({\"data\": str(exc)})\n        self.finish()\n\n\nclass DemoHandler(_Handler):\n    @pait(post_plugin_list=[RequiredPlugin.build()])\n    async def get(\n        self,\n        uid: str = field.Query.i(),\n        email: Optional[str] = field.Query.i(default=None),\n        user_name: Optional[str] = field.Query.i(\n            default=None, extra_param_list=[RequiredExtraParam(main_column=\"email\")]\n        ),\n    ) -&gt; None:\n        self.write({\"uid\": uid, \"user_name\": user_name, \"email\": email})\n\n\napp: Application = Application([(r\"/api/demo\", DemoHandler)])\n\n\nif __name__ == \"__main__\":\n    app.listen(8000)\n    IOLoop.instance().start()\n</code></pre> <p>Another extension parameter <code>RequiredGroupExtraParam</code> is to categorize the parameters by <code>group</code> and mark one of the parameters in this group as the main parameter by <code>is_main</code>, so that all other parameters in the group will depend on the main parameter. The following sample code categorizes <code>user_name</code> and <code>email</code> parameters into <code>my-group</code>, and defines the <code>email</code> parameter as the main parameter of <code>my-group</code>, so that the generated validation rules depend on the <code>user_name</code> parameter and the <code>email</code> parameter.</p> FlaskStarletteSanicTornado docs_source_code/plugin/param_plugin/flask_with_required_plugin_and_group_extra_param_demo.py<pre><code>from typing import Optional\n\nfrom flask import Flask, Response, jsonify\n\nfrom pait import field\nfrom pait.app.flask import pait\nfrom pait.exceptions import TipException\nfrom pait.plugin.required import RequiredGroupExtraParam, RequiredPlugin\n\n\ndef api_exception(exc: Exception) -&gt; Response:\n    if isinstance(exc, TipException):\n        exc = exc.exc\n    return jsonify({\"data\": str(exc)})\n\n\n@pait(post_plugin_list=[RequiredPlugin.build()])\ndef demo(\n    uid: str = field.Query.i(),\n    user_name: Optional[str] = field.Query.i(\n        default=None, extra_param_list=[RequiredGroupExtraParam(group=\"my-group\")]\n    ),\n    email: Optional[str] = field.Query.i(\n        default=None, extra_param_list=[RequiredGroupExtraParam(group=\"my-group\", is_main=True)]\n    ),\n) -&gt; Response:\n    return jsonify({\"uid\": uid, \"user_name\": user_name, \"email\": email})\n\n\napp = Flask(\"demo\")\napp.add_url_rule(\"/api/demo\", view_func=demo, methods=[\"GET\"])\napp.errorhandler(Exception)(api_exception)\n\n\nif __name__ == \"__main__\":\n    app.run(port=8000)\n</code></pre> docs_source_code/plugin/param_plugin/starlette_with_required_plugin_and_group_extra_param_demo.py<pre><code>from typing import Optional\n\nfrom starlette.applications import Starlette\nfrom starlette.requests import Request\nfrom starlette.responses import JSONResponse\nfrom starlette.routing import Route\n\nfrom pait import field\nfrom pait.app.starlette import pait\nfrom pait.exceptions import TipException\nfrom pait.plugin.required import RequiredGroupExtraParam, RequiredPlugin\n\n\nasync def api_exception(request: Request, exc: Exception) -&gt; JSONResponse:\n    if isinstance(exc, TipException):\n        exc = exc.exc\n    return JSONResponse({\"data\": str(exc)})\n\n\n@pait(post_plugin_list=[RequiredPlugin.build()])\nasync def demo(\n    uid: str = field.Query.i(),\n    user_name: Optional[str] = field.Query.i(\n        default=None, extra_param_list=[RequiredGroupExtraParam(group=\"my-group\")]\n    ),\n    email: Optional[str] = field.Query.i(\n        default=None, extra_param_list=[RequiredGroupExtraParam(group=\"my-group\", is_main=True)]\n    ),\n) -&gt; JSONResponse:\n    return JSONResponse({\"uid\": uid, \"user_name\": user_name, \"email\": email})\n\n\napp = Starlette(routes=[Route(\"/api/demo\", demo, methods=[\"GET\"])])\napp.add_exception_handler(Exception, api_exception)\n\n\nif __name__ == \"__main__\":\n    import uvicorn\n\n    uvicorn.run(app)\n</code></pre> docs_source_code/plugin/param_plugin/sanic_with_required_plugin_and_group_extra_param_demo.py<pre><code>from typing import Optional\n\nfrom sanic import Request, Sanic\nfrom sanic.response import HTTPResponse, json\n\nfrom pait import field\nfrom pait.app.sanic import pait\nfrom pait.exceptions import TipException\nfrom pait.plugin.required import RequiredGroupExtraParam, RequiredPlugin\n\n\nasync def api_exception(request: Request, exc: Exception) -&gt; HTTPResponse:\n    if isinstance(exc, TipException):\n        exc = exc.exc\n    return json({\"data\": str(exc)})\n\n\n@pait(post_plugin_list=[RequiredPlugin.build()])\nasync def demo(\n    uid: str = field.Query.i(),\n    user_name: Optional[str] = field.Query.i(\n        default=None, extra_param_list=[RequiredGroupExtraParam(group=\"my-group\")]\n    ),\n    email: Optional[str] = field.Query.i(\n        default=None, extra_param_list=[RequiredGroupExtraParam(group=\"my-group\", is_main=True)]\n    ),\n) -&gt; HTTPResponse:\n    return json({\"uid\": uid, \"user_name\": user_name, \"email\": email})\n\n\napp = Sanic(\"demo\")\napp.add_route(demo, \"/api/demo\", methods=[\"GET\"])\napp.exception(Exception)(api_exception)\n\n\nif __name__ == \"__main__\":\n    import uvicorn\n\n    uvicorn.run(app)\n</code></pre> docs_source_code/plugin/param_plugin/tornado_with_required_plugin_and_group_extra_param_demo.py<pre><code>from typing import Optional\n\nfrom tornado.ioloop import IOLoop\nfrom tornado.web import Application, RequestHandler\n\nfrom pait import field\nfrom pait.app.tornado import pait\nfrom pait.exceptions import TipException\nfrom pait.plugin.required import RequiredGroupExtraParam, RequiredPlugin\n\n\nclass _Handler(RequestHandler):\n    def _handle_request_exception(self, exc: BaseException) -&gt; None:\n        if isinstance(exc, TipException):\n            exc = exc.exc\n        self.write({\"data\": str(exc)})\n        self.finish()\n\n\nclass DemoHandler(_Handler):\n    @pait(post_plugin_list=[RequiredPlugin.build()])\n    async def get(\n        self,\n        uid: str = field.Query.i(),\n        user_name: Optional[str] = field.Query.i(\n            default=None, extra_param_list=[RequiredGroupExtraParam(group=\"my-group\")]\n        ),\n        email: Optional[str] = field.Query.i(\n            default=None, extra_param_list=[RequiredGroupExtraParam(group=\"my-group\", is_main=True)]\n        ),\n    ) -&gt; None:\n        self.write({\"uid\": uid, \"user_name\": user_name, \"email\": email})\n\n\napp: Application = Application([(r\"/api/demo\", DemoHandler)])\n\n\nif __name__ == \"__main__\":\n    app.listen(8000)\n    IOLoop.instance().start()\n</code></pre>"},{"location":"5_2_param_check_plugin/#2atmostoneof-plugin","title":"2.AtMostOneOf Plugin","text":"<p>The main function of the <code>AtMostOneOf</code> plugin is to verify whether the parameters are mutually exclusive. for example, if there are three parameters A, B and C and the B parameter is required to be mutually exclusive with the C parameter, that if B exists, C cannot exist, and if C exists, B cannot exist. This can use <code>AtMostOneOf</code> plugin configuration rules to achieve the function, the code is as follows:</p> FlaskStarletteSanicTornado docs_source_code/plugin/param_plugin/flask_with_at_most_one_of_plugin_demo.py<pre><code>from typing import Optional\n\nfrom flask import Flask, Response, jsonify\n\nfrom pait import field\nfrom pait.app.flask import pait\nfrom pait.exceptions import TipException\nfrom pait.plugin.at_most_one_of import AtMostOneOfPlugin\n\n\ndef api_exception(exc: Exception) -&gt; Response:\n    if isinstance(exc, TipException):\n        exc = exc.exc\n    return jsonify({\"data\": str(exc)})\n\n\n@pait(post_plugin_list=[AtMostOneOfPlugin.build(at_most_one_of_list=[[\"email\", \"user_name\"]])])\ndef demo(\n    uid: str = field.Query.i(),\n    user_name: Optional[str] = field.Query.i(default=None),\n    email: Optional[str] = field.Query.i(default=None),\n) -&gt; Response:\n    return jsonify({\"uid\": uid, \"user_name\": user_name, \"email\": email})\n\n\napp = Flask(\"demo\")\napp.add_url_rule(\"/api/demo\", view_func=demo, methods=[\"GET\"])\napp.errorhandler(Exception)(api_exception)\n\n\nif __name__ == \"__main__\":\n    app.run(port=8000)\n</code></pre> docs_source_code/plugin/param_plugin/starlette_with_at_most_one_of_plugin_demo.py<pre><code>from typing import Optional\n\nfrom starlette.applications import Starlette\nfrom starlette.requests import Request\nfrom starlette.responses import JSONResponse\nfrom starlette.routing import Route\n\nfrom pait import field\nfrom pait.app.starlette import pait\nfrom pait.exceptions import TipException\nfrom pait.plugin.at_most_one_of import AtMostOneOfPlugin\n\n\nasync def api_exception(request: Request, exc: Exception) -&gt; JSONResponse:\n    if isinstance(exc, TipException):\n        exc = exc.exc\n    return JSONResponse({\"data\": str(exc)})\n\n\n@pait(post_plugin_list=[AtMostOneOfPlugin.build(at_most_one_of_list=[[\"email\", \"user_name\"]])])\nasync def demo(\n    uid: str = field.Query.i(),\n    user_name: Optional[str] = field.Query.i(default=None),\n    email: Optional[str] = field.Query.i(default=None),\n) -&gt; JSONResponse:\n    return JSONResponse({\"uid\": uid, \"user_name\": user_name, \"email\": email})\n\n\napp = Starlette(routes=[Route(\"/api/demo\", demo, methods=[\"GET\"])])\napp.add_exception_handler(Exception, api_exception)\n\n\nif __name__ == \"__main__\":\n    import uvicorn\n\n    uvicorn.run(app)\n</code></pre> docs_source_code/plugin/param_plugin/sanic_with_at_most_one_of_plugin_demo.py<pre><code>from typing import Optional\n\nfrom sanic import Request, Sanic\nfrom sanic.response import HTTPResponse, json\n\nfrom pait import field\nfrom pait.app.sanic import pait\nfrom pait.exceptions import TipException\nfrom pait.plugin.at_most_one_of import AtMostOneOfPlugin\n\n\nasync def api_exception(request: Request, exc: Exception) -&gt; HTTPResponse:\n    if isinstance(exc, TipException):\n        exc = exc.exc\n    return json({\"data\": str(exc)})\n\n\n@pait(post_plugin_list=[AtMostOneOfPlugin.build(at_most_one_of_list=[[\"email\", \"user_name\"]])])\nasync def demo(\n    uid: str = field.Query.i(),\n    user_name: Optional[str] = field.Query.i(default=None),\n    email: Optional[str] = field.Query.i(default=None),\n) -&gt; HTTPResponse:\n    return json({\"uid\": uid, \"user_name\": user_name, \"email\": email})\n\n\napp = Sanic(\"demo\")\napp.add_route(demo, \"/api/demo\", methods=[\"GET\"])\napp.exception(Exception)(api_exception)\n\n\nif __name__ == \"__main__\":\n    import uvicorn\n\n    uvicorn.run(app)\n</code></pre> docs_source_code/plugin/param_plugin/tornado_with_at_most_one_of_plugin_demo.py<pre><code>from typing import Optional\n\nfrom tornado.ioloop import IOLoop\nfrom tornado.web import Application, RequestHandler\n\nfrom pait import field\nfrom pait.app.tornado import pait\nfrom pait.exceptions import TipException\nfrom pait.plugin.at_most_one_of import AtMostOneOfPlugin\n\n\nclass _Handler(RequestHandler):\n    def _handle_request_exception(self, exc: BaseException) -&gt; None:\n        if isinstance(exc, TipException):\n            exc = exc.exc\n        self.write({\"data\": str(exc)})\n        self.finish()\n\n\nclass DemoHandler(_Handler):\n    @pait(post_plugin_list=[AtMostOneOfPlugin.build(at_most_one_of_list=[[\"email\", \"user_name\"]])])\n    async def get(\n        self,\n        uid: str = field.Query.i(),\n        user_name: Optional[str] = field.Query.i(default=None),\n        email: Optional[str] = field.Query.i(default=None),\n    ) -&gt; None:\n        self.write({\"uid\": uid, \"user_name\": user_name, \"email\": email})\n\n\napp: Application = Application([(r\"/api/demo\", DemoHandler)])\n\n\nif __name__ == \"__main__\":\n    app.listen(8000)\n    IOLoop.instance().start()\n</code></pre> <p>In the sample code, <code>uid</code> is a required parameter, while <code>user_name</code> and <code>email</code> are optional parameters, and after using the <code>AtMostOneOfPlugin</code> plugin a new validation rule will be added. This validation rule is defined by the parameter <code>at_most_one_of_list</code>, which indicates that the parameters <code>email</code> and <code>user_name</code> cannot exist at the same time.</p> <p>After sending a request using <code>curl</code>, the response shows that an error is returned when both <code>email</code> and <code>user_name</code> are present, but otherwise the response is returned normally. <pre><code>\u279c ~ curl http://127.0.0.1:8000/api/demo\\?uid\\=123\n{\"uid\":\"123\",\"user_name\":null,\"email\":null}%\n\u279c ~ curl http://127.0.0.1:8000/api/demo\\?uid\\=123\\&amp;email\\=aaa\n{\"uid\":\"123\",\"user_name\":null,\"email\":\"aaa\"}%\n\u279c  ~ curl http://127.0.0.1:8000/api/demo\\?uid\\=123\\&amp;user_name\\=so1n\n{\"uid\":\"123\",\"user_name\":\"so1n\",\"email\":null}%\n\u279c ~ curl http://127.0.0.1:8000/api/demo\\?uid\\=123\\&amp;email\\=aaa\\&amp;user_name\\=so1n\n{\"data\":\"requires at most one of param email or user_name\"}%\n</code></pre></p> <p>In addition, the <code>AtMostOneOf</code> plugin also supports grouping parameters by <code>ExtraParam</code> and restricting them to not appearing at the same time, using the following method:</p> FlaskStarletteSanicTornado docs_source_code/plugin/param_plugin/flask_with_at_most_one_of_plugin_and_extra_param_demo.py<pre><code>from typing import Optional\n\nfrom flask import Flask, Response, jsonify\n\nfrom pait import field\nfrom pait.app.flask import pait\nfrom pait.exceptions import TipException\nfrom pait.plugin.at_most_one_of import AtMostOneOfExtraParam, AtMostOneOfPlugin\n\n\ndef api_exception(exc: Exception) -&gt; Response:\n    if isinstance(exc, TipException):\n        exc = exc.exc\n    return jsonify({\"data\": str(exc)})\n\n\n@pait(post_plugin_list=[AtMostOneOfPlugin.build()])\ndef demo(\n    uid: str = field.Query.i(),\n    email: Optional[str] = field.Query.i(default=None, extra_param_list=[AtMostOneOfExtraParam(group=\"my-group\")]),\n    user_name: Optional[str] = field.Query.i(default=None, extra_param_list=[AtMostOneOfExtraParam(group=\"my-group\")]),\n) -&gt; Response:\n    return jsonify({\"uid\": uid, \"user_name\": user_name, \"email\": email})\n\n\napp = Flask(\"demo\")\napp.add_url_rule(\"/api/demo\", view_func=demo, methods=[\"GET\"])\napp.errorhandler(Exception)(api_exception)\n\n\nif __name__ == \"__main__\":\n    app.run(port=8000)\n</code></pre> docs_source_code/plugin/param_plugin/starlette_with_at_most_one_of_plugin_and_extra_param_demo.py<pre><code>from typing import Optional\n\nfrom starlette.applications import Starlette\nfrom starlette.requests import Request\nfrom starlette.responses import JSONResponse\nfrom starlette.routing import Route\n\nfrom pait import field\nfrom pait.app.starlette import pait\nfrom pait.exceptions import TipException\nfrom pait.plugin.at_most_one_of import AtMostOneOfExtraParam, AtMostOneOfPlugin\n\n\nasync def api_exception(request: Request, exc: Exception) -&gt; JSONResponse:\n    if isinstance(exc, TipException):\n        exc = exc.exc\n    return JSONResponse({\"data\": str(exc)})\n\n\n@pait(post_plugin_list=[AtMostOneOfPlugin.build()])\nasync def demo(\n    uid: str = field.Query.i(),\n    email: Optional[str] = field.Query.i(default=None, extra_param_list=[AtMostOneOfExtraParam(group=\"my-group\")]),\n    user_name: Optional[str] = field.Query.i(default=None, extra_param_list=[AtMostOneOfExtraParam(group=\"my-group\")]),\n) -&gt; JSONResponse:\n    return JSONResponse({\"uid\": uid, \"user_name\": user_name, \"email\": email})\n\n\napp = Starlette(routes=[Route(\"/api/demo\", demo, methods=[\"GET\"])])\napp.add_exception_handler(Exception, api_exception)\n\n\nif __name__ == \"__main__\":\n    import uvicorn\n\n    uvicorn.run(app)\n</code></pre> docs_source_code/plugin/param_plugin/sanic_with_at_most_one_of_plugin_and_extra_param_demo.py<pre><code>from typing import Optional\n\nfrom sanic import Request, Sanic\nfrom sanic.response import HTTPResponse, json\n\nfrom pait import field\nfrom pait.app.sanic import pait\nfrom pait.exceptions import TipException\nfrom pait.plugin.at_most_one_of import AtMostOneOfExtraParam, AtMostOneOfPlugin\n\n\nasync def api_exception(request: Request, exc: Exception) -&gt; HTTPResponse:\n    if isinstance(exc, TipException):\n        exc = exc.exc\n    return json({\"data\": str(exc)})\n\n\n@pait(post_plugin_list=[AtMostOneOfPlugin.build()])\nasync def demo(\n    uid: str = field.Query.i(),\n    email: Optional[str] = field.Query.i(default=None, extra_param_list=[AtMostOneOfExtraParam(group=\"my-group\")]),\n    user_name: Optional[str] = field.Query.i(default=None, extra_param_list=[AtMostOneOfExtraParam(group=\"my-group\")]),\n) -&gt; HTTPResponse:\n    return json({\"uid\": uid, \"user_name\": user_name, \"email\": email})\n\n\napp = Sanic(\"demo\")\napp.add_route(demo, \"/api/demo\", methods=[\"GET\"])\napp.exception(Exception)(api_exception)\n\n\nif __name__ == \"__main__\":\n    import uvicorn\n\n    uvicorn.run(app)\n</code></pre> docs_source_code/plugin/param_plugin/tornado_with_at_most_one_of_plugin_and_extra_param_demo.py<pre><code>from typing import Optional\n\nfrom tornado.ioloop import IOLoop\nfrom tornado.web import Application, RequestHandler\n\nfrom pait import field\nfrom pait.app.tornado import pait\nfrom pait.exceptions import TipException\nfrom pait.plugin.at_most_one_of import AtMostOneOfExtraParam, AtMostOneOfPlugin\n\n\nclass _Handler(RequestHandler):\n    def _handle_request_exception(self, exc: BaseException) -&gt; None:\n        if isinstance(exc, TipException):\n            exc = exc.exc\n        self.write(str(exc))\n        self.finish()\n\n\nclass DemoHandler(_Handler):\n    @pait(post_plugin_list=[AtMostOneOfPlugin.build()])\n    async def get(\n        self,\n        uid: str = field.Query.i(),\n        user_name: Optional[str] = field.Query.i(\n            default=None, extra_param_list=[AtMostOneOfExtraParam(group=\"my-group\")]\n        ),\n        email: Optional[str] = field.Query.i(default=None, extra_param_list=[AtMostOneOfExtraParam(group=\"my-group\")]),\n    ) -&gt; None:\n        self.write({\"uid\": uid, \"user_name\": user_name, \"email\": email})\n\n\napp: Application = Application([(r\"/api/demo\", DemoHandler)])\n\n\nif __name__ == \"__main__\":\n    app.listen(8000)\n    IOLoop.instance().start()\n</code></pre> <p>In this code, the <code>user_name</code> and <code>email</code> parameters are grouped into <code>my-group</code> using <code>AtMostOneOfExtraParam</code>. At runtime, the <code>AtMostOneOf</code> plugin verifies that both the <code>user_name</code> and <code>email</code> parameters exist, and throws an error if both exist.</p>"},{"location":"5_3_json_response_plugin/","title":"Json response plugin","text":"<p>Currently the most used serialization method in the route function is JSON, so <code>Pait</code> also comes with some JSON response related plug-ins, such as checking the JSON response result, automatically replenishing the JSON response result data, etc., which all use the <code>response model_list</code> in the response model to expand the corresponding functions.</p> <p>Note</p> <ul> <li>1.Since the plugin needs to get the returned results, the plugin may intrude into the web framework, resulting in a somewhat different usage than the original usage.</li> <li>2.Plugins need to be adapted to different web frameworks, so please introduce the corresponding plugin in the form of <code>from pait.app.{web framework name}.plugin.{plugin name} import xxx</code>.</li> </ul>"},{"location":"5_3_json_response_plugin/#check-the-json-response-result-plugin","title":"Check the JSON response result plugin","text":"<p>The <code>CheckJsonPlugin</code> plugin is mainly used to check the response result of the route function, if the check is successful, the response will be returned, otherwise an error will be thrown, as shown below:</p> FlaskStarletteSanicTornado docs_source_code/plugin/json_plugin/flask_with_check_json_plugin_demo.py<pre><code>from typing import Type\n\nfrom flask import Flask, Response, jsonify\nfrom pydantic import BaseModel, Field\n\nfrom pait.app.flask import pait\nfrom pait.app.flask.plugin import CheckJsonRespPlugin\nfrom pait.exceptions import TipException\nfrom pait.field import Query\nfrom pait.model.response import JsonResponseModel\n\n\nclass UserSuccessRespModel3(JsonResponseModel):\n    class ResponseModel(BaseModel):  # type: ignore\n        class DataModel(BaseModel):\n            uid: int = Field(description=\"user id\", gt=10, lt=1000)\n            user_name: str = Field(description=\"user name\", min_length=2, max_length=4)\n            age: int = Field(description=\"age\", gt=1, lt=100)\n            email: str = Field(description=\"user email\")\n\n        code: int = Field(0, description=\"api code\")\n        msg: str = Field(\"success\", description=\"api status msg\")\n        data: DataModel\n\n    description: str = \"success response\"\n    response_data: Type[BaseModel] = ResponseModel\n\n\ndef api_exception(exc: Exception) -&gt; Response:\n    if isinstance(exc, TipException):\n        exc = exc.exc\n    return jsonify({\"data\": str(exc)})\n\n\n@pait(response_model_list=[UserSuccessRespModel3], plugin_list=[CheckJsonRespPlugin.build()])\ndef demo(\n    uid: int = Query.i(description=\"user id\", gt=10, lt=1000),\n    email: str = Query.i(default=\"example@xxx.com\", description=\"user email\"),\n    user_name: str = Query.i(description=\"user name\", min_length=2, max_length=4),\n    age: int = Query.i(description=\"age\", gt=1, lt=100),\n    display_age: int = Query.i(0, description=\"display_age\"),\n) -&gt; Response:\n    return_dict: dict = {\n        \"code\": 0,\n        \"msg\": \"\",\n        \"data\": {\n            \"uid\": uid,\n            \"user_name\": user_name,\n            \"email\": email,\n        },\n    }\n    if display_age == 1:\n        return_dict[\"data\"][\"age\"] = age\n    return jsonify(return_dict)\n\n\napp = Flask(\"demo\")\napp.add_url_rule(\"/api/demo\", view_func=demo, methods=[\"GET\"])\napp.errorhandler(Exception)(api_exception)\n\n\nif __name__ == \"__main__\":\n    app.run(port=8000)\n</code></pre> docs_source_code/plugin/json_plugin/starlette_with_check_json_plugin_demo.py<pre><code>from typing import Type\n\nfrom pydantic import BaseModel, Field\nfrom starlette.applications import Starlette\nfrom starlette.requests import Request\nfrom starlette.responses import JSONResponse, Response\nfrom starlette.routing import Route\n\nfrom pait.app.starlette import pait\nfrom pait.app.starlette.plugin import CheckJsonRespPlugin\nfrom pait.exceptions import TipException\nfrom pait.field import Query\nfrom pait.model.response import JsonResponseModel\n\n\nclass UserSuccessRespModel3(JsonResponseModel):\n    class ResponseModel(BaseModel):  # type: ignore\n        class DataModel(BaseModel):\n            uid: int = Field(description=\"user id\", gt=10, lt=1000)\n            user_name: str = Field(description=\"user name\", min_length=2, max_length=4)\n            age: int = Field(description=\"age\", gt=1, lt=100)\n            email: str = Field(description=\"user email\")\n\n        code: int = Field(0, description=\"api code\")\n        msg: str = Field(\"success\", description=\"api status msg\")\n        data: DataModel\n\n    description: str = \"success response\"\n    response_data: Type[BaseModel] = ResponseModel\n\n\nasync def api_exception(request: Request, exc: Exception) -&gt; Response:\n    if isinstance(exc, TipException):\n        exc = exc.exc\n    return JSONResponse({\"data\": str(exc)})\n\n\n@pait(response_model_list=[UserSuccessRespModel3], plugin_list=[CheckJsonRespPlugin.build()])\nasync def demo(\n    uid: int = Query.i(description=\"user id\", gt=10, lt=1000),\n    email: str = Query.i(default=\"example@xxx.com\", description=\"user email\"),\n    user_name: str = Query.i(description=\"user name\", min_length=2, max_length=4),\n    age: int = Query.i(description=\"age\", gt=1, lt=100),\n    display_age: int = Query.i(0, description=\"display_age\"),\n) -&gt; Response:\n    return_dict: dict = {\n        \"code\": 0,\n        \"msg\": \"\",\n        \"data\": {\n            \"uid\": uid,\n            \"user_name\": user_name,\n            \"email\": email,\n        },\n    }\n    if display_age == 1:\n        return_dict[\"data\"][\"age\"] = age\n    return JSONResponse(return_dict)\n\n\napp = Starlette(routes=[Route(\"/api/demo\", demo, methods=[\"GET\"])])\napp.add_exception_handler(Exception, api_exception)\n\n\nif __name__ == \"__main__\":\n    import uvicorn\n\n    uvicorn.run(app)\n</code></pre> docs_source_code/plugin/json_plugin/sanic_with_check_json_plugin_demo.py<pre><code>from typing import Type\n\nfrom pydantic import BaseModel, Field\nfrom sanic import HTTPResponse, Request, Sanic, response\n\nfrom pait.app.sanic import pait\nfrom pait.app.sanic.plugin import CheckJsonRespPlugin\nfrom pait.exceptions import TipException\nfrom pait.field import Query\nfrom pait.model.response import JsonResponseModel\n\n\nclass UserSuccessRespModel3(JsonResponseModel):\n    class ResponseModel(BaseModel):  # type: ignore\n        class DataModel(BaseModel):\n            uid: int = Field(description=\"user id\", gt=10, lt=1000)\n            user_name: str = Field(description=\"user name\", min_length=2, max_length=4)\n            age: int = Field(description=\"age\", gt=1, lt=100)\n            email: str = Field(description=\"user email\")\n\n        code: int = Field(0, description=\"api code\")\n        msg: str = Field(\"success\", description=\"api status msg\")\n        data: DataModel\n\n    description: str = \"success response\"\n    response_data: Type[BaseModel] = ResponseModel\n\n\nasync def api_exception(request: Request, exc: Exception) -&gt; response.HTTPResponse:\n    if isinstance(exc, TipException):\n        exc = exc.exc\n    return response.json({\"data\": str(exc)})\n\n\n@pait(response_model_list=[UserSuccessRespModel3], plugin_list=[CheckJsonRespPlugin.build()])\nasync def demo(\n    uid: int = Query.i(description=\"user id\", gt=10, lt=1000),\n    email: str = Query.i(default=\"example@xxx.com\", description=\"user email\"),\n    user_name: str = Query.i(description=\"user name\", min_length=2, max_length=4),\n    age: int = Query.i(description=\"age\", gt=1, lt=100),\n    display_age: int = Query.i(0, description=\"display_age\"),\n) -&gt; HTTPResponse:\n    return_dict: dict = {\n        \"code\": 0,\n        \"msg\": \"\",\n        \"data\": {\n            \"uid\": uid,\n            \"user_name\": user_name,\n            \"email\": email,\n        },\n    }\n    if display_age == 1:\n        return_dict[\"data\"][\"age\"] = age\n    return response.json(return_dict)\n\n\napp = Sanic(\"demo\")\napp.add_route(demo, \"/api/demo\", methods=[\"GET\"])\napp.exception(Exception)(api_exception)\n\n\nif __name__ == \"__main__\":\n    import uvicorn\n\n    uvicorn.run(app)\n</code></pre> docs_source_code/plugin/json_plugin/tornado_with_check_json_plugin_demo.py<pre><code>from typing import Type\n\nfrom pydantic import BaseModel, Field\nfrom tornado.ioloop import IOLoop\nfrom tornado.web import Application, RequestHandler\n\nfrom pait.app.tornado import pait\nfrom pait.app.tornado.plugin import CheckJsonRespPlugin\nfrom pait.exceptions import TipException\nfrom pait.field import Query\nfrom pait.model.response import JsonResponseModel\n\n\nclass UserSuccessRespModel3(JsonResponseModel):\n    class ResponseModel(BaseModel):  # type: ignore\n        class DataModel(BaseModel):\n            uid: int = Field(description=\"user id\", gt=10, lt=1000)\n            user_name: str = Field(description=\"user name\", min_length=2, max_length=4)\n            age: int = Field(description=\"age\", gt=1, lt=100)\n            email: str = Field(description=\"user email\")\n\n        code: int = Field(0, description=\"api code\")\n        msg: str = Field(\"success\", description=\"api status msg\")\n        data: DataModel\n\n    description: str = \"success response\"\n    response_data: Type[BaseModel] = ResponseModel\n\n\nclass _Handler(RequestHandler):\n    def _handle_request_exception(self, exc: BaseException) -&gt; None:\n        if isinstance(exc, TipException):\n            exc = exc.exc\n\n        self.write({\"data\": str(exc)})\n        self.finish()\n\n\nclass DemoHandler(_Handler):\n    @pait(response_model_list=[UserSuccessRespModel3], plugin_list=[CheckJsonRespPlugin.build()])\n    async def get(\n        self,\n        uid: int = Query.i(description=\"user id\", gt=10, lt=1000),\n        email: str = Query.i(default=\"example@xxx.com\", description=\"user email\"),\n        user_name: str = Query.i(description=\"user name\", min_length=2, max_length=4),\n        age: int = Query.i(description=\"age\", gt=1, lt=100),\n        display_age: int = Query.i(0, description=\"display_age\"),\n    ) -&gt; None:\n        return_dict: dict = {\n            \"code\": 0,\n            \"msg\": \"\",\n            \"data\": {\n                \"uid\": uid,\n                \"user_name\": user_name,\n                \"email\": email,\n            },\n        }\n        if display_age == 1:\n            return_dict[\"data\"][\"age\"] = age\n        self.write(return_dict)\n\n\napp: Application = Application([(r\"/api/demo\", DemoHandler)])\n\n\nif __name__ == \"__main__\":\n    app.listen(8000)\n    IOLoop.instance().start()\n</code></pre> <p>The first step is to define a JSON response result model called <code>UserSuccessRespModel3</code>. Then define an error handler function that catches exceptions thrown when the plugin fails to validate the results. Next is to define a <code>demo</code> route function that uses the <code>CheckJsonRespPlugin</code> plugin. Also, when <code>display_age</code> is not equal to 1, the result returned by the <code>demo</code> route function will not match the <code>UserSuccessRespModel3</code>.</p> <p>After running the code and executing the following commands, can find through the execution results that when the response result does not match the defined response Model, an error will be thrown directly: <pre><code>\u279c  curl http://127.0.0.1:8000/api/demo\\?uid\\=123\\&amp;user_name\\=so1n\\&amp;age\\=18\\&amp;display_age\\=1\n{\"code\": 0, \"msg\": \"\", \"data\": {\"uid\": 123, \"user_name\": \"so1n\", \"email\": \"example@xxx.com\", \"age\": 18}}\n\u279c  curl http://127.0.0.1:8000/api/demo\\?uid\\=123\\&amp;user_name\\=so1n\\&amp;age\\=18\n1 validation error for ResponseModel\ndata -&gt; age\n  field required (type=value_error.missing)\n</code></pre></p>"},{"location":"5_3_json_response_plugin/#autocomplete-json-response-result-plugin","title":"Autocomplete JSON response result plugin","text":"<p>The result returned by the route function should be consistent with the structure defined in the API documentation, because returning only some of the fields may cause the client to crash. If for some reason only part of the structure can be returned, then can use the AutoComplete JSON Response plugin to fill in the default values for the fields that are missing, as in the following example:</p> FlaskStarletteSanicTornado docs_source_code/plugin/json_plugin/flask_with_auto_complete_json_plugin_demo.py<pre><code>from typing import List, Type\n\nfrom flask import Flask\nfrom pydantic import BaseModel, Field\n\nfrom pait.app.flask import pait\nfrom pait.app.flask.plugin import AutoCompleteJsonRespPlugin\nfrom pait.model.response import JsonResponseModel\n\n\nclass AutoCompleteRespModel(JsonResponseModel):\n    class ResponseModel(BaseModel):\n        class DataModel(BaseModel):\n            class MusicModel(BaseModel):\n                name: str = Field(\"\")\n                url: str = Field()\n                singer: str = Field(\"\")\n\n            uid: int = Field(100, description=\"user id\", gt=10, lt=1000)\n            music_list: List[MusicModel] = Field(description=\"music list\")\n            image_list: List[dict] = Field(description=\"music list\")\n\n        code: int = Field(0, description=\"api code\")\n        msg: str = Field(\"success\", description=\"api status msg\")\n        data: DataModel\n\n    description: str = \"success response\"\n    response_data: Type[BaseModel] = ResponseModel\n\n\n@pait(response_model_list=[AutoCompleteRespModel], plugin_list=[AutoCompleteJsonRespPlugin.build()])\ndef demo() -&gt; dict:\n    \"\"\"Test json plugin by resp type is dict\"\"\"\n    return {\n        \"code\": 0,\n        \"msg\": \"\",\n        \"data\": {\n            # \"uid\": 0,\n            \"image_list\": [\n                {\"aaa\": 10},\n                {\"aaa\": \"123\"},\n            ],\n            \"music_list\": [\n                {\n                    \"name\": \"music1\",\n                    \"url\": \"http://music1.com\",\n                    \"singer\": \"singer1\",\n                },\n                {\n                    # \"name\": \"music1\",\n                    \"url\": \"http://music1.com\",\n                    # \"singer\": \"singer1\",\n                },\n            ],\n        },\n    }\n\n\napp = Flask(\"demo\")\napp.add_url_rule(\"/api/demo\", view_func=demo, methods=[\"GET\"])\n\n\nif __name__ == \"__main__\":\n    app.run(port=8000)\n</code></pre> docs_source_code/plugin/json_plugin/starlette_with_auto_complete_json_plugin_demo.py<pre><code>from typing import List, Type\n\nfrom pydantic import BaseModel, Field\nfrom starlette.applications import Starlette\nfrom starlette.routing import Route\n\nfrom pait.app.starlette import pait\nfrom pait.app.starlette.plugin import AutoCompleteJsonRespPlugin\nfrom pait.model.response import JsonResponseModel\n\n\nclass AutoCompleteRespModel(JsonResponseModel):\n    class ResponseModel(BaseModel):\n        class DataModel(BaseModel):\n            class MusicModel(BaseModel):\n                name: str = Field(\"\")\n                url: str = Field()\n                singer: str = Field(\"\")\n\n            uid: int = Field(100, description=\"user id\", gt=10, lt=1000)\n            music_list: List[MusicModel] = Field(description=\"music list\")\n            image_list: List[dict] = Field(description=\"music list\")\n\n        code: int = Field(0, description=\"api code\")\n        msg: str = Field(\"success\", description=\"api status msg\")\n        data: DataModel\n\n    description: str = \"success response\"\n    response_data: Type[BaseModel] = ResponseModel\n\n\n@pait(response_model_list=[AutoCompleteRespModel], plugin_list=[AutoCompleteJsonRespPlugin.build()])\nasync def demo() -&gt; dict:\n    \"\"\"Test json plugin by resp type is dict\"\"\"\n    return {\n        \"code\": 0,\n        \"msg\": \"\",\n        \"data\": {\n            # \"uid\": 0,\n            \"image_list\": [\n                {\"aaa\": 10},\n                {\"aaa\": \"123\"},\n            ],\n            \"music_list\": [\n                {\n                    \"name\": \"music1\",\n                    \"url\": \"http://music1.com\",\n                    \"singer\": \"singer1\",\n                },\n                {\n                    # \"name\": \"music1\",\n                    \"url\": \"http://music1.com\",\n                    # \"singer\": \"singer1\",\n                },\n            ],\n        },\n    }\n\n\napp = Starlette(routes=[Route(\"/api/demo\", demo, methods=[\"GET\"])])\n\n\nif __name__ == \"__main__\":\n    import uvicorn\n\n    uvicorn.run(app)\n</code></pre> docs_source_code/plugin/json_plugin/sanic_with_auto_complete_json_plugin_demo.py<pre><code>from typing import List, Type\n\nfrom pydantic import BaseModel, Field\nfrom sanic import Request, Sanic\n\nfrom pait.app.sanic import pait\nfrom pait.app.sanic.plugin import AutoCompleteJsonRespPlugin\nfrom pait.model.response import JsonResponseModel\n\n\nclass AutoCompleteRespModel(JsonResponseModel):\n    class ResponseModel(BaseModel):\n        class DataModel(BaseModel):\n            class MusicModel(BaseModel):\n                name: str = Field(\"\")\n                url: str = Field()\n                singer: str = Field(\"\")\n\n            uid: int = Field(100, description=\"user id\", gt=10, lt=1000)\n            music_list: List[MusicModel] = Field(description=\"music list\")\n            image_list: List[dict] = Field(description=\"music list\")\n\n        code: int = Field(0, description=\"api code\")\n        msg: str = Field(\"success\", description=\"api status msg\")\n        data: DataModel\n\n    description: str = \"success response\"\n    response_data: Type[BaseModel] = ResponseModel\n\n\n@pait(response_model_list=[AutoCompleteRespModel], plugin_list=[AutoCompleteJsonRespPlugin.build()])\nasync def demo(request: Request) -&gt; dict:\n    \"\"\"Test json plugin by resp type is dict\"\"\"\n    return {\n        \"code\": 0,\n        \"msg\": \"\",\n        \"data\": {\n            # \"uid\": 0,\n            \"image_list\": [\n                {\"aaa\": 10},\n                {\"aaa\": \"123\"},\n            ],\n            \"music_list\": [\n                {\n                    \"name\": \"music1\",\n                    \"url\": \"http://music1.com\",\n                    \"singer\": \"singer1\",\n                },\n                {\n                    # \"name\": \"music1\",\n                    \"url\": \"http://music1.com\",\n                    # \"singer\": \"singer1\",\n                },\n            ],\n        },\n    }\n\n\napp = Sanic(\"demo\")\napp.add_route(demo, \"/api/demo\", methods=[\"GET\"])\n\n\nif __name__ == \"__main__\":\n    import uvicorn\n\n    uvicorn.run(app)\n</code></pre> docs_source_code/plugin/json_plugin/tornado_with_auto_complete_json_plugin_demo.py<pre><code>from typing import List, Type\n\nfrom pydantic import BaseModel, Field\nfrom tornado.ioloop import IOLoop\nfrom tornado.web import Application, RequestHandler\n\nfrom pait.app.tornado import pait\nfrom pait.app.tornado.plugin import AutoCompleteJsonRespPlugin\nfrom pait.model.response import JsonResponseModel\n\n\nclass AutoCompleteRespModel(JsonResponseModel):\n    class ResponseModel(BaseModel):\n        class DataModel(BaseModel):\n            class MusicModel(BaseModel):\n                name: str = Field(\"\")\n                url: str = Field()\n                singer: str = Field(\"\")\n\n            uid: int = Field(100, description=\"user id\", gt=10, lt=1000)\n            music_list: List[MusicModel] = Field(description=\"music list\")\n            image_list: List[dict] = Field(description=\"music list\")\n\n        code: int = Field(0, description=\"api code\")\n        msg: str = Field(\"success\", description=\"api status msg\")\n        data: DataModel\n\n    description: str = \"success response\"\n    response_data: Type[BaseModel] = ResponseModel\n\n\nclass DemoHandler(RequestHandler):\n    @pait(response_model_list=[AutoCompleteRespModel], plugin_list=[AutoCompleteJsonRespPlugin.build()])\n    async def get(\n        self,\n    ) -&gt; dict:\n        \"\"\"Test json plugin by resp type is dict\"\"\"\n        return {\n            \"code\": 0,\n            \"msg\": \"\",\n            \"data\": {\n                # \"uid\": 0,\n                \"image_list\": [\n                    {\"aaa\": 10},\n                    {\"aaa\": \"123\"},\n                ],\n                \"music_list\": [\n                    {\n                        \"name\": \"music1\",\n                        \"url\": \"http://music1.com\",\n                        \"singer\": \"singer1\",\n                    },\n                    {\n                        # \"name\": \"music1\",\n                        \"url\": \"http://music1.com\",\n                        # \"singer\": \"singer1\",\n                    },\n                ],\n            },\n        }\n\n\napp: Application = Application([(r\"/api/demo\", DemoHandler)])\n\n\nif __name__ == \"__main__\":\n    app.listen(8000)\n    IOLoop.instance().start()\n</code></pre> <p>First define an <code>AutoCompleteRespModel</code> response Model with a default value of 100 for the <code>UID</code> in the Model. Then create a <code>demo</code> function, which has some fields missing from the return structure, but uses the <code>AutoCompleteJsonRespPlugin</code> plugin.</p> <p>Run the code and execute the following command: <pre><code>\u279c  ~ curl http://127.0.0.1:8000/api/demo\n{\n  \"code\":0,\n  \"data\":{\n      \"image_list\":[{},{}],\n      \"music_list\":[{\"name\":\"music1\",\"singer\":\"singer1\",\"url\":\"http://music1.com\"},{\"name\":\"\",\"singer\":\"\",\"url\":\"http://music1.com\"}],\n      \"uid\":100\n    },\n  \"msg\":\"\"\n}\n</code></pre> The output shows that <code>data-&gt;uid</code>, <code>data-&gt;music_list-&gt;[0]-&gt;name</code> and <code>data-&gt;music_list-&gt;[0]-&gt;singer</code> have been supplemented with default values. The default value of <code>data-&gt;uid</code> is defined for the Field of <code>AutoCompleteRespModel</code>, while the default values of the other fields are zero values corresponding to the type.</p> <p>Note</p> <p>1.The default value of the response can be defined through <code>default</code> or <code>default_factory</code> of <code>Field</code>. 2.AutoCompletePlugin intrudes into the routing function, causing the routing function to return only <code>Python</code> types instead of response objects.</p>"},{"location":"5_4_mock_json_response_check_plugin/","title":"Mock response plugin","text":"<p>In the development process, the back-end developer will often define the API document and discuss the implementation of the API with the front-end developer through the API document and make modifications, there is no specific implementation of the API in this stage. In this stage, the front-end and back-end developers will be developed at the same time, then there may be a front-end developers need to debug the API in the development process, but due to the back-end developers have not yet completed the development of the front-end developers can not be debugging the situation.</p> <p>To do this, the <code>Mock</code> plugin can be used to return the specified response data for route functions that do not implement the logic, as follows:</p> FlaskStarletteSanicTornado docs_source_code/plugin/mock_plugin/flask_with_mock_plugin_demo.py<pre><code>from typing import List, Type\n\nfrom flask import Flask\nfrom pydantic import BaseModel, Field\n\nfrom pait.app.flask import pait\nfrom pait.app.flask.plugin import MockPlugin\nfrom pait.field import Query\nfrom pait.model.response import JsonResponseModel\n\n\nclass UserSuccessRespModel2(JsonResponseModel):\n    class ResponseModel(BaseModel):\n        class DataModel(BaseModel):\n            uid: int = Field(description=\"user id\", gt=10, lt=1000, example=666)\n            user_name: str = Field(example=\"mock_name\", description=\"user name\", min_length=2, max_length=10)\n            multi_user_name: List[str] = Field(\n                example=[\"mock_name\"], description=\"user name\", min_length=1, max_length=10\n            )\n            age: int = Field(example=99, description=\"age\", gt=1, lt=100)\n            email: str = Field(example=\"example@so1n.me\", description=\"user email\")\n\n        code: int = Field(0, description=\"api code\")\n        msg: str = Field(\"success\", description=\"api status msg\")\n        data: DataModel\n\n    description: str = \"success response\"\n    response_data: Type[BaseModel] = ResponseModel\n\n\n@pait(response_model_list=[UserSuccessRespModel2], plugin_list=[MockPlugin.build()])\ndef demo(\n    uid: int = Query.i(description=\"user id\", gt=10, lt=1000),\n    user_name: str = Query.i(description=\"user name\", min_length=2, max_length=4),\n    email: str = Query.i(default=\"example@xxx.com\", description=\"user email\"),\n) -&gt; dict:\n    return {}\n\n\napp = Flask(\"demo\")\napp.add_url_rule(\"/api/demo\", view_func=demo, methods=[\"GET\"])\n\n\nif __name__ == \"__main__\":\n    app.run(port=8000)\n</code></pre> docs_source_code/plugin/mock_plugin/starlette_with_mock_plugin_demo.py<pre><code>from typing import List, Type\n\nfrom pydantic import BaseModel, Field\nfrom starlette.applications import Starlette\nfrom starlette.routing import Route\n\nfrom pait.app.starlette import pait\nfrom pait.app.starlette.plugin import MockPlugin\nfrom pait.field import Query\nfrom pait.model.response import JsonResponseModel\n\n\nclass UserSuccessRespModel2(JsonResponseModel):\n    class ResponseModel(BaseModel):\n        class DataModel(BaseModel):\n            uid: int = Field(description=\"user id\", gt=10, lt=1000, example=666)\n            user_name: str = Field(example=\"mock_name\", description=\"user name\", min_length=2, max_length=10)\n            multi_user_name: List[str] = Field(\n                example=[\"mock_name\"], description=\"user name\", min_length=1, max_length=10\n            )\n            age: int = Field(example=99, description=\"age\", gt=1, lt=100)\n            email: str = Field(example=\"example@so1n.me\", description=\"user email\")\n\n        code: int = Field(0, description=\"api code\")\n        msg: str = Field(\"success\", description=\"api status msg\")\n        data: DataModel\n\n    description: str = \"success response\"\n    response_data: Type[BaseModel] = ResponseModel\n\n\n@pait(response_model_list=[UserSuccessRespModel2], plugin_list=[MockPlugin.build()])\nasync def demo(\n    uid: int = Query.i(description=\"user id\", gt=10, lt=1000),\n    user_name: str = Query.i(description=\"user name\", min_length=2, max_length=4),\n    email: str = Query.i(default=\"example@xxx.com\", description=\"user email\"),\n) -&gt; dict:\n    return {}\n\n\napp = Starlette(routes=[Route(\"/api/demo\", demo, methods=[\"GET\"])])\n\n\nif __name__ == \"__main__\":\n    import uvicorn\n\n    uvicorn.run(app)\n</code></pre> docs_source_code/plugin/mock_plugin/sanic_with_mock_plugin_demo.py<pre><code>from typing import List, Type\n\nfrom pydantic import BaseModel, Field\nfrom sanic import Sanic\n\nfrom pait.app.sanic import pait\nfrom pait.app.sanic.plugin import MockPlugin\nfrom pait.field import Query\nfrom pait.model.response import JsonResponseModel\n\n\nclass UserSuccessRespModel2(JsonResponseModel):\n    class ResponseModel(BaseModel):\n        class DataModel(BaseModel):\n            uid: int = Field(description=\"user id\", gt=10, lt=1000, example=666)\n            user_name: str = Field(example=\"mock_name\", description=\"user name\", min_length=2, max_length=10)\n            multi_user_name: List[str] = Field(\n                example=[\"mock_name\"], description=\"user name\", min_length=1, max_length=10\n            )\n            age: int = Field(example=99, description=\"age\", gt=1, lt=100)\n            email: str = Field(example=\"example@so1n.me\", description=\"user email\")\n\n        code: int = Field(0, description=\"api code\")\n        msg: str = Field(\"success\", description=\"api status msg\")\n        data: DataModel\n\n    description: str = \"success response\"\n    response_data: Type[BaseModel] = ResponseModel\n\n\n@pait(response_model_list=[UserSuccessRespModel2], plugin_list=[MockPlugin.build()])\nasync def demo(\n    uid: int = Query.i(description=\"user id\", gt=10, lt=1000),\n    user_name: str = Query.i(description=\"user name\", min_length=2, max_length=4),\n    email: str = Query.i(default=\"example@xxx.com\", description=\"user email\"),\n) -&gt; dict:\n    return {}\n\n\napp = Sanic(\"demo\")\napp.add_route(demo, \"/api/demo\", methods=[\"GET\"])\n\n\nif __name__ == \"__main__\":\n    import uvicorn\n\n    uvicorn.run(app)\n</code></pre> docs_source_code/plugin/mock_plugin/tornado_with_mock_plugin_demo.py<pre><code>from typing import List, Type\n\nfrom pydantic import BaseModel, Field\nfrom tornado.ioloop import IOLoop\nfrom tornado.web import Application, RequestHandler\n\nfrom pait.app.tornado import pait\nfrom pait.app.tornado.plugin import MockPlugin\nfrom pait.field import Query\nfrom pait.model.response import JsonResponseModel\n\n\nclass UserSuccessRespModel2(JsonResponseModel):\n    class ResponseModel(BaseModel):\n        class DataModel(BaseModel):\n            uid: int = Field(description=\"user id\", gt=10, lt=1000, example=666)\n            user_name: str = Field(example=\"mock_name\", description=\"user name\", min_length=2, max_length=10)\n            multi_user_name: List[str] = Field(\n                example=[\"mock_name\"], description=\"user name\", min_length=1, max_length=10\n            )\n            age: int = Field(example=99, description=\"age\", gt=1, lt=100)\n            email: str = Field(example=\"example@so1n.me\", description=\"user email\")\n\n        code: int = Field(0, description=\"api code\")\n        msg: str = Field(\"success\", description=\"api status msg\")\n        data: DataModel\n\n    description: str = \"success response\"\n    response_data: Type[BaseModel] = ResponseModel\n\n\nclass DemoHandler(RequestHandler):\n    @pait(response_model_list=[UserSuccessRespModel2], plugin_list=[MockPlugin.build()])\n    async def get(\n        uid: int = Query.i(description=\"user id\", gt=10, lt=1000),\n        user_name: str = Query.i(description=\"user name\", min_length=2, max_length=4),\n        email: str = Query.i(default=\"example@xxx.com\", description=\"user email\"),\n    ) -&gt; dict:\n        return {}\n\n\napp: Application = Application([(r\"/api/demo\", DemoHandler)])\n\n\nif __name__ == \"__main__\":\n    app.listen(8000)\n    IOLoop.instance().start()\n</code></pre> <p>The code first implements a response object called <code>UserSuccessRespModel2</code>, which differs from the previous response object in that some of its fields have <code>example</code> attributes. Then it creates a <code>demo</code> route function without any code logic, which has only a few parameters and uses the <code>Mock</code> plugin and the <code>UserSuccessRespModel2</code> response object via <code>pait</code>.</p> <p>Run the code and execute the following command, the output shows that after using the <code>Mock</code> plugin, the route function is able to return data and the data is the same as the value of <code>example</code> in the <code>UserSuccessRespModel2</code> response object: <pre><code>\u279c  curl http://127.0.0.1:8000/api/demo\n{\"code\":0,\"data\":{\"age\":99,\"email\":\"example@so1n.me\",\"multi_user_name\":[\"mock_name\"],\"uid\":666,\"user_name\":\"mock_name\"},\"msg\":\"success\"}\n</code></pre></p> <p>Note</p> <ul> <li>1.example also supports factory functions, which have a similar effect to <code>default_factory</code>. Available values are <code>example=time.now</code>, <code>example=lambda :random.randint(100000, 900000)</code> and so on.</li> <li>2.Mock plugin supports defining the name of the field to be adopted by the parameter <code>example_column_name</code>, which is <code>example</code> by default and can also be <code>mock</code>.</li> </ul>"},{"location":"5_5_cache_response/","title":"Response caching plugin","text":"<p>The Cache plugin can cache any response object other than streaming responses based on different request parameters. It can be used as follows.</p> FlaskStarletteSanicTornado docs_source_code/plugin/cache_plugin/flask_with_cache_plugin_demo.py<pre><code>import time\n\nfrom flask import Flask, Response, make_response\nfrom redis import Redis  # type: ignore\n\nfrom pait.app.flask import pait\nfrom pait.app.flask.plugin.cache_response import CacheRespExtraParam, CacheResponsePlugin\nfrom pait.field import Query\nfrom pait.model.response import HtmlResponseModel\n\n\n@pait(\n    response_model_list=[HtmlResponseModel],\n    post_plugin_list=[CacheResponsePlugin.build(cache_time=10, enable_cache_name_merge_param=True)],\n)\ndef demo(key1: str = Query.i(extra_param_list=[CacheRespExtraParam()]), key2: str = Query.i()) -&gt; Response:\n    return make_response(str(time.time()), 200)\n\n\napp = Flask(\"demo\")\nCacheResponsePlugin.set_redis_to_app(app, Redis(decode_responses=True))\napp.add_url_rule(\"/api/demo\", view_func=demo, methods=[\"GET\"])\n\n\nif __name__ == \"__main__\":\n    app.run(port=8000)\n</code></pre> docs_source_code/plugin/cache_plugin/starlette_with_cache_plugin_demo.py<pre><code>import time\nfrom typing import Any\n\nfrom redis.asyncio import Redis  # type: ignore\nfrom starlette.applications import Starlette\nfrom starlette.responses import HTMLResponse\n\nfrom pait.app.starlette import pait\nfrom pait.app.starlette.plugin.cache_response import CacheRespExtraParam, CacheResponsePlugin\nfrom pait.field import Query\nfrom pait.model.response import HtmlResponseModel\n\n\n@pait(\n    response_model_list=[HtmlResponseModel],\n    post_plugin_list=[CacheResponsePlugin.build(cache_time=10, enable_cache_name_merge_param=True)],\n)\nasync def demo(key1: str = Query.i(extra_param_list=[CacheRespExtraParam()]), key2: str = Query.i()) -&gt; HTMLResponse:\n    return HTMLResponse(str(time.time()), 200)\n\n\napp = Starlette()\napp.add_route(\"/api/demo\", demo, methods=[\"GET\"])\n\n\ndef before_start(*args: Any, **kwargs: Any) -&gt; None:\n    CacheResponsePlugin.set_redis_to_app(app, Redis(decode_responses=True))\n\n\napp.add_event_handler(\"startup\", before_start)\n\n\nif __name__ == \"__main__\":\n    import uvicorn\n\n    uvicorn.run(app)\n</code></pre> docs_source_code/plugin/cache_plugin/sanic_with_cache_plugin_demo.py<pre><code>import time\nfrom typing import Any\n\nfrom redis.asyncio import Redis  # type: ignore\nfrom sanic import Sanic, response\n\nfrom pait.app.sanic import pait\nfrom pait.app.sanic.plugin.cache_response import CacheRespExtraParam, CacheResponsePlugin\nfrom pait.field import Query\nfrom pait.model.response import HtmlResponseModel\n\n\n@pait(\n    response_model_list=[HtmlResponseModel],\n    post_plugin_list=[CacheResponsePlugin.build(cache_time=10, enable_cache_name_merge_param=True)],\n)\nasync def demo(\n    key1: str = Query.i(extra_param_list=[CacheRespExtraParam()]), key2: str = Query.i()\n) -&gt; response.HTTPResponse:\n    return response.html(str(time.time()), 200)\n\n\napp = Sanic(\"demo\")\napp.add_route(demo, \"/api/demo\", methods=[\"GET\"])\n\n\ndef before_start(*args: Any, **kwargs: Any) -&gt; None:\n    CacheResponsePlugin.set_redis_to_app(app, Redis(decode_responses=True))\n\n\napp.before_server_start(before_start)\n\n\nif __name__ == \"__main__\":\n    app.run(port=8000)\n</code></pre> docs_source_code/plugin/cache_plugin/tornado_with_cache_plugin_demo.py<pre><code>import time\n\nfrom redis.asyncio import Redis  # type: ignore\nfrom tornado.ioloop import IOLoop\nfrom tornado.web import Application, RequestHandler\n\nfrom pait.app.tornado import pait\nfrom pait.app.tornado.plugin.cache_response import CacheRespExtraParam, CacheResponsePlugin\nfrom pait.field import Query\nfrom pait.model.response import HtmlResponseModel\n\n\nclass DemoHandler(RequestHandler):\n    @pait(\n        response_model_list=[HtmlResponseModel],\n        post_plugin_list=[CacheResponsePlugin.build(cache_time=10, enable_cache_name_merge_param=True)],\n    )\n    async def get(self, key1: str = Query.i(extra_param_list=[CacheRespExtraParam()]), key2: str = Query.i()) -&gt; None:\n        self.write(str(time.time()))\n\n\napp: Application = Application([(r\"/api/demo\", DemoHandler)])\nCacheResponsePlugin.set_redis_to_app(app, Redis(decode_responses=True))\n\n\nif __name__ == \"__main__\":\n    app.listen(8000)\n    IOLoop.instance().start()\n</code></pre> <p>The route function uses a <code>CachePlugin</code> that declares a cache time of 10 seconds and enables the cache name to include the request parameters. Also, only the <code>key1</code> parameter in the route function uses the <code>CacheRespExtraParam</code> expansion parameter, so that the <code>CachePlugin</code> will only take the parameter that uses the <code>CacheRespExtraParam</code> parameter, not all of them.</p> <p>After running the code and executing the <code>curl</code> command, can see that the route function returns the same content when the request parameters are the same:</p> curl http://127.0.0.1:8000/api/demo\\?key1\\=1\\&amp;key2\\=11695627610.021101curl http://127.0.0.1:8000/api/demo\\?key1\\=1\\&amp;key2\\=11695627610.021101curl http://127.0.0.1:8000/api/demo\\?key1\\=2\\&amp;key2\\=11695627613.0265439 <p>In addition to the <code>cache_time</code> and <code>enable_cache_name_merge_param</code> parameters, <code>CachePlugin</code> supports other parameters, as described below:</p> <ul> <li>redis: Specify the Redis instance used by the cache plugin, it is recommended to specify the Redis instance via the <code>CacheResponsePlugin.set_redis_to_app</code> method.</li> <li>name: Specify the cache Key of the route function, if this value is null, the cache Key is the name of the route function.</li> <li>enable_cache_name_merge_param: If True, the construction of the cached Key will include other parameter values, such as the following route function.     <pre><code>from pait.app.any import pait\nfrom pait.plugin.cache_response import CacheResponsePlugin\nfrom pait.field import Query\n\n@pait(post_plugin_list=[CacheResponsePlugin.build(cache_time=10)])\nasync def demo(uid: str = Query.i(), name: str = Query.i()) -&gt; None:\n    pass\n</code></pre>     When the request url carries <code>?uid=10086&amp;name=so1n</code>, the cache plugin generates a cache Key of <code>demo:10086:so1n</code>.     However, if the parameter <code>uid</code> uses the <code>CacheRespExtraParam</code> expansion parameter, then the cached Key will only include the value of the parameter that uses the <code>CacheRespExtraParam</code> expansion parameter, such as the following route function:     <pre><code>from pait.app.any import pait\nfrom pait.plugin.cache_response import CacheResponsePlugin, CacheRespExtraParam\nfrom pait.field import Query\n\n@pait(post_plugin_list=[CacheResponsePlugin.build(cache_time=10)])\nasync def demo(uid: str = Query.i(extra_param_list=[CacheRespExtraParam()]), name: str = Query.i()) -&gt; None:\n    pass\n</code></pre>     When the request url carries <code>?uid=10086&amp;name=so1n</code>, the cache plugin generates a cache Key of <code>demo:10086</code>.</li> <li>include_exc: Receive a Tuple that can be exception, if the error thrown by the route function belongs to one of the errors in the Tuple, the exception will be cached, otherwise the exception will be thrown.</li> <li>cache_time: cache time in seconds.</li> <li>timeout: To prevent cache conflicts in highly concurrent scenarios, the cache plugin uses <code>Reids</code> locks to prevent resource contention. timeout represents the maximum time the lock can be held.</li> <li>sleep: When a lock is found to be held by another request, the current request will sleep for a specified amount of time before attempting to acquire the lock, and so on until it acquires the corresponding lock or times out.</li> <li>blocking_timeout: the maximum time to try to acquire the lock, if None, it will wait forever.</li> </ul>"},{"location":"5_x_how_to_customize_the_plugin/","title":"How to customize the plugin","text":"<p>Both pre-plugin and post-plugin inherit from <code>PluginProtocol</code>, so they both implement the following methods: <pre><code>from typing import Any, Dict\n\nclass PluginProtocol(object):\n\n    def __post_init__(self, **kwargs: Any) -&gt; None:\n        pass\n\n    @classmethod\n    def pre_check_hook(cls, pait_core_model: \"PaitCoreModel\", kwargs: Dict) -&gt; None:\n        ...\n\n    @classmethod\n    def pre_load_hook(cls, pait_core_model: \"PaitCoreModel\", kwargs: Dict) -&gt; Dict:\n        ...\n\n    @classmethod\n    def build(cls, **kwargs: Any) -&gt; \"PluginManager[_PluginT]\":\n        ...\n\n    def __call__(self, context: \"PluginContext\") -&gt; Any:\n        ...\n</code></pre> If want to customize the plugin, need to inherit <code>PrePluginProtocol</code> or <code>PostPluginProtocol</code> depending on the plugin type and implement the methods mentioned above. The methods in <code>PluginProtocol</code> correspond to the different lifecycles of the plugin, which are the build of the plugin - <code>build</code>, the pre-check of the plugin - <code>pre_check_hook</code>, the pre-load of the plugin - <code>pre_load_hook</code>, the initialization of the plugin - <code>__post_init__</code>, and the run of the plugin <code>__call__</code>.</p>"},{"location":"5_x_how_to_customize_the_plugin/#1life-cycle","title":"1.Life cycle","text":""},{"location":"5_x_how_to_customize_the_plugin/#11build-of-the-plugin","title":"1.1.Build of the plugin","text":"<p>The <code>build</code> method of a plugin actually stores the plugin and its corresponding required initialization parameters and is called by <code>Pait</code>. If want to create a pre-plugin that uses the variables <code>a</code>, <code>b</code>, then the plugin's implementation code would look like this: <pre><code>from pait.plugin.base import PrePluginProtocol\n\nclass DemoPlugin(PrePluginProtocol):\n    a: int\n    b: str\n\n    @classmethod\n    def build(\n        cls,\n        a: int,\n        b: str,\n    ) -&gt; \"PluginManager[_PluginT]\":\n        cls.build(a=a, b=b)\n</code></pre> First of all, <code>DemoPlugin</code> is defined to have <code>a</code> and <code>b</code> attributes and neither of them is assigned a value, which means that the <code>DemoPlugin</code> plugin requires the <code>a</code> and <code>b</code> parameters, and the plugin fails to initialize if the <code>a</code> and <code>b</code> parameters are not passed through the <code>build</code> method.</p>"},{"location":"5_x_how_to_customize_the_plugin/#12pre-check-of-plugins","title":"1.2.Pre-check of plugins","text":"<p>Different plugins depend on different properties of <code>CoreModel</code> , and <code>pre_check_hook</code> checks whether the current <code>CoreModel</code> meets the plugin's requirements before the plugin is initialized, to detect problems as early as possible. The code is as follows: <pre><code>from typing import Dict\nfrom pait.plugin.base import PrePluginProtocol\nfrom pait.model.status import PaitStatus\n\nclass DemoPlugin(PrePluginProtocol):\n    @classmethod\n    def pre_check_hook(cls, pait_core_model: \"PaitCoreModel\", kwargs: Dict) -&gt; None:\n        if pait_core_model.status is not PaitStatus.test:\n            raise ValueError(\"Only functions that are in test can be used\")\n        if not isinstance(kwargs.get(\"a\", None), int):\n            raise TypeError(\"param `a` type must int\")\n        super().pre_load_hook(pait_core_model, kwargs)\n</code></pre> The sample code through the <code>pre_check_hook</code> for two checks, the first check is to determine whether the state of the current function is set to <code>TEST</code>, the second check the type of the parameter <code>a</code> is whether the type of int, in the case of checking the failure of an exception will be thrown to interrupt the operation of the program.</p>"},{"location":"5_x_how_to_customize_the_plugin/#13pre-load-of-plugins","title":"1.3.Pre-load of plugins","text":"<p>Each route function decorated by <code>Pait</code> stores some initial values in <code>CoreModel</code>. The plugin will extract the values from the <code>CoreModel</code> at runtime and process them, but it is time consuming to extract the data again for each request. This can be done by extracting the data and saving it with <code>pre_load_hook</code> to reduce repetitive operations. For example: <pre><code>from typing import Dict\nfrom pait.plugin.base import PrePluginProtocol\nfrom pait.model.response import JsonResponseModel\n\nclass DemoPlugin(PrePluginProtocol):\n    example_value: dict\n\n    @classmethod\n    def pre_load_hook(cls, pait_core_model: \"PaitCoreModel\", kwargs: Dict) -&gt; Dict:\n        if not pait_core_model.response_model_list:\n            raise ValueError(\"Not found response model\")\n        response_model = pait_core_model.response_model_list\n        if not issubclass(response_model, JsonResponseModel):\n            raise TypeError(\"Only support json response model\")\n        kwargs[\"example_value\"] = response_model.get_example_value()\n        return super().pre_load_hook(pait_core_model, kwargs)\n</code></pre> The <code>DemoPlugin</code> is defined to require a parameter called <code>example_value</code>. However, this parameter is not passed through the <code>build</code> method, but is obtained by parsing the example value of the response model object in the <code>pre_load_hook</code> method. which gets its example data via the <code>get_example_value</code> of the response object and stores it in the <code>example_value</code> of <code>kwargs</code>. After that, <code>DemoPlugin</code> can store the <code>example_value</code> of <code>kwargs</code> to its own <code>example_value</code> property during the initialization phase.</p>"},{"location":"5_x_how_to_customize_the_plugin/#14__post_init__","title":"1.4.<code>__post_init__</code>","text":"<p>As you know from the above methods, <code>kwargs</code> is a container that stores the plugin's initialization parameters, which will be used by the <code>build</code>, <code>pre_check_hook</code>, and <code>pre_load_hook</code> methods. It is then written to the plugin instance via the plugin's <code>__init__</code> method.</p> <p>However, this process is handled automatically by <code>Pait</code> based on the properties of the plugin, which may not be compatible with some scenarios. So the plugin executes the <code>__post_init__</code> method in the last step of initialization, and the developer can complete the custom plugin initialization logic with the <code>kwargs</code> variable in the <code>__post_init__</code> method.</p>"},{"location":"5_x_how_to_customize_the_plugin/#15__call__","title":"1.5.<code>__call__</code>","text":"<p><code>Pait</code> will organize the plugins in order and set the next plugin to the current plugin's <code>next_plugin</code> variable. When a request hits, <code>Pait</code> passes the request data to the <code>__call__</code> method of the first plugin and waits for the plugin to process and return. And each plugin will call the <code>self.next_plugin</code> method in the <code>__call__</code> method to continue calling the next plugin as follows. <pre><code>from typing import Any\nfrom pait.plugin.base import PrePluginProtocol\n\n\nclass DemoPlugin(PrePluginProtocol):\n    def __call__(self, context: \"PluginContext\") -&gt; Any:\n        next_plugin_result = None\n        try:\n            next_plugin_result = self.next_plugin(context)\n        except Exception as e:\n            pass\n        return next_plugin_result\n</code></pre> In this sample code, plugin functionality can be implemented before or after calling <code>next_plugin</code> and catch <code>next_plugin</code> exceptions in the <code>except</code> syntax block. Also, each plugin is driven by the previous plugin and plugins do not affect each other's functionality, but they can share data via <code>context</code>.</p> <p>It is also possible to don't calling the <code>next_plugin</code> method to return a value or to throw an exception, as follows: <pre><code>from typing import Any\nfrom pait.plugin.base import PrePluginProtocol\n\n\nclass RaiseExcDemoPlugin(PrePluginProtocol):\n    def __call__(self, context: \"PluginContext\") -&gt; Any:\n        raise RuntimeError(\"Not working\")\n</code></pre> When the plugin is executed, <code>Pait</code> does not call all subsequent plugins and route functions and throws an exception.</p>"},{"location":"5_x_how_to_customize_the_plugin/#2a-real-world-example","title":"2.A real-world example","text":"<p>Here's a simple example of a implementation based on the <code>starlette</code> framework: <pre><code>from typing import Optional\nimport uvicorn  # type: ignore\nfrom starlette.applications import Starlette\nfrom starlette.requests import Request\nfrom starlette.responses import JSONResponse\nfrom starlette.routing import Route\nfrom pait.exceptions import TipException\n\nfrom pait.app.starlette import pait\nfrom pait import field\n\n\nasync def api_exception(request: Request, exc: Exception) -&gt; JSONResponse:\n    if isinstance(exc, TipException):\n        exc = exc.exc\n    return JSONResponse({\"data\": str(exc)})\n\n\n@pait()\nasync def demo(\n    uid: str = field.Query.i(),\n    user_name: Optional[str] = field.Query.i(default=None),\n    email: Optional[str] = field.Query.i(default=None)\n) -&gt; JSONResponse:\n    return JSONResponse({\"uid\": uid, \"user_name\": user_name, \"email\": email})\n\n\napp = Starlette(routes=[Route(\"/api/demo\", demo, methods=[\"GET\"])])\napp.add_exception_handler(Exception, api_exception)\nuvicorn.run(app)\n</code></pre> The route function is provided with parameter validation by <code>Pait</code>, when the caller's parameter does not match the validation rules, the route function throws an exception and is caught by <code>starlette</code> and then distributed to the <code>api_exception</code> function to handle. For example, a request that carries no request parameters:</p>  ~ curl http://127.0.0.1:8000/api/demo{\"data\":\"Can not found uid value\"} <p>Since <code>Pait</code> finds a missing parameter uid when validating the request parameters, an error is thrown and caught by <code>api_exception</code> and an exception response is generated and returned to the caller.</p> <p>Assuming that exceptions to the route function do not want to be handled by <code>api_exception</code>, a plugin can be implemented to handle exceptions to the route function, as follows: <pre><code>from typing import Any, Dict\nfrom pait.plugin.base import PrePluginProtocol\nfrom pydantic import ValidationError\nfrom pait.exceptions import PaitBaseException\nfrom starlette.responses import JSONResponse\n\n\nclass DemoExceptionPlugin(PrePluginProtocol):\n\n    @classmethod\n    def pre_check_hook(cls, pait_core_model: \"PaitCoreModel\", kwargs: Dict) -&gt; Dict:\n        if pait_core_model.func.__name__ != \"demo\":\n            raise RuntimeError(f\"The {cls.__name__} is only used for demo func\")\n\n    async def __call__(self, *args: Any, **kwargs: Any) -&gt; Any:\n        try:\n            return await self.next_plugin(args, kwargs)\n        except (ValidationError, PaitBaseException) as e:\n            return JSONResponse({\"plugin exc info\": str(e)})\n</code></pre></p> <p>As you can see there are several features of this plugin:.</p> <ul> <li>1.The plugin inherits <code>PrePluginProtocol</code>, this is because of the need to catch exceptions thrown by <code>Pait</code>.</li> <li>2.The plugin determines whether the current plugin is a <code>demo</code> function through the <code>pre_check_hook</code> method, and throws an exception if it is not.</li> <li>3.Since the route function is <code>async def</code>, the <code>__call__</code> method of the plugin is also infected by <code>async</code> and needs to be <code>async def</code>.</li> </ul> <p>After creating the plugin, can use it in the route function, for example: <pre><code>@pait(plugin_list=[DemoExceptionPlugin.build])\nasync def demo(...): pass\n</code></pre> Next restart the program and run the same request, can see that the response has changed: <pre><code>\u279c  ~ curl http://127.0.0.1:8000/api/demo\n{\"plugin exc info\":\"File \\\"/home/so1n/demo.py\\\", line 48, in demo.\\nerror:Can not found uid value\"}\n</code></pre></p>"},{"location":"6_config/","title":"config","text":"<p>config provide some functional configurations for <code>Pait</code>, however, it is only allowed to be initialized once during the entire runtime of the program, and it is recommended to do so after all routes have been added and <code>load_app</code> has been called, as in the following code, <code>config.init_config</code> is called before the <code>run app</code> code block: <pre><code>from starlette.applications import Starlette\nfrom pait.g import config\nfrom pait.app.any import load_app\n\n# ------\n# By `from ... import` import routing module\n# ------\n\napp: Starlette = Starlette()\n# --------\n# app.add_route\n# --------\nload_app(app)\nconfig.init_config(author=(\"so1n\", ))\n# --------\n# run app\n# --------\n</code></pre></p> <p><code>config.init_config</code> supports the following parameters:</p> Parameters Description author Global author of the default route function, if author in <code>@pait</code> is null, the author for the route function is <code>config.author</code> status Global status of the default route function, if status in <code>@pait</code> is null, the status for the route function is  is <code>config.status</code> json_type_default_value_dict Configure the default value of the json type, which will be useful when auto-generating the response. python_type_default_value_dict Configure a default value for the python type that will work when auto-generating the response. json_encoder Pait's Json encoder  object apply_func_list A list of functions that change the attributes of the route function according to certain rules"},{"location":"6_config/#1apply-func","title":"1.apply func","text":"<p>When using <code>Pait</code>, it may be possible to use different <code>Pait</code> attributes depending on the route function lifecycle. For example, if the <code>status</code> is <code>design</code>, the Mock plugin will be used, and if the <code>status</code> is <code>test</code>, the response check plugin will be used. If you have to change the configuration manually every time, it will be very troublesome, and you can use the apply func function at this time.</p> <p>Note</p> <p>This function can be thought of as a routing group, but don't think of it as middleware, as it can't handle routes that aren't decorated by <code>Pait</code>.</p> <p><code>Pait</code> provides a series of apply func, each apply func will only handle one kind of <code>Pait</code> attribute, its function protocol is as follows: <pre><code>from typing import Any, Optional\nfrom pait.model.config import APPLY_FN\nfrom pait.extra.config import MatchRule\n\ndef apply_func_demo(\n    value: Any, match_rule: Optional[\"MatchRule\"] = None\n) -&gt; \"APPLY_FN\":\n    pass\n</code></pre> It requires 2 parameters, the first parameter is the value to be applied and the second parameter is to match which route functions need to be applied.</p> <p>The <code>match_rule</code> parameter is an object called <code>MatchRule</code>, which is initialized to accept two parameters, one named <code>key</code> and the other named <code>target</code>. Where <code>key</code> is the Key of the corresponding <code>Pait</code> attribute of the route function, with a default value of <code>all</code> (which means that all route functions match). Target is the value of the attribute to be matched, Key currently supports the following values: <pre><code>MatchKeyLiteral = Literal[\n    \"all\",              # Match all route functions\n    \"status\",           # The status of the route function will be matched if it corresponds to the value\n    \"group\",            # The group of the route function will be matched to the corresponding value\n    \"tag\",              # The tag of the route function will match the corresponding values\n    \"method_list\",      # The HTTP method of the route function will match the corresponding value\n    \"path\",             # The URL of the route function matches the regular match of the input\n    \"!status\",\n    \"!group\",\n    \"!tag\",\n    \"!method_list\",\n    \"!path\",\n]\n</code></pre> They are of three types. The first type is <code>all</code>, such as  <code>MatchRule(\"all\")</code> means that all route functions will match. The second type is <code>status</code>, <code>group</code>, <code>tag</code>, <code>method_list</code>, <code>path</code>, such as <code>MatchRule(\"group\", \"demo\")</code> means that route functions with a <code>group</code> of <code>demo</code> will be matched. The last type starts with <code>!</code>, which means reverse matching, such as <code>MatchRule(\"!status\", \"test\")</code> means that route functions that match <code>status</code> with a value other than <code>test</code> will be matched.</p> <p>In addition to this, the matching rules support multi-rule matching for <code>&amp;</code> and <code>|</code> as follows: <pre><code>from pait.extra.config import MatchRule\nfrom pait.model.status import PaitStatus\n\n# Match the route function whose status is test or dev\nMatchRule(\"status\", PaitStatus.test) | MatchRule(\"status\", PaitStatus.dev)\n# Match the route function whose path is /api/user, method_list is GET, or group is gRPC\nMatchRule(\"path\", \"/api/user\") &amp; (MatchRule(\"method_list\", \"GET\") | MatchRule(\"group\", \"gRPC\"))\n</code></pre></p> <p>Note</p> <p>It is important to note that <code>apply func</code> only appends the value for array-type values, not overrides the value.</p>"},{"location":"6_config/#11apply_extra_openapi_model","title":"1.1.apply_extra_openapi_model","text":"<p>When using the Web framework, may use some request parameters through the middleware, these parameters will not be used in the route function. For example, there is a middleware that gets the APP version from the Header, and returns a 404 response for APP versions less than 1, and only allows access if the APP version is greater than 1. In this case, <code>Pait</code> will not be able to get the request values used by the middleware, resulting in the generated OpanAPI data missing these request values. This can be solved by using <code>apply_extra_openapi_model</code>, which is used as follows: <pre><code>from pydantic import BaseModel\nfrom pait.field import Header\nfrom pait.extra.config import apply_extra_openapi_model\nfrom pait.g import config\n\nclass DemoModel(BaseModel):\n    \"\"\"Middleware generally reads the corresponding version value through the header\"\"\"\n    version_code: int = Header.i(description=\"Version code\")\n    version_name: str = Header.i(description=\"Version name\")\n\n\n# Use the `apply_extra_openapi_model` to apply the current model,\n# and use the default value of the MatchRule because the middleware is applied to all route functions.\nconfig.init_config(apply_func_list=[apply_extra_openapi_model(DemoModel)])\n</code></pre></p>"},{"location":"6_config/#12apply_response_model","title":"1.2.apply_response_model","text":"<p>As with the <code>apply_extra_openapi_model</code>, an exception response may be returned when using a middleware restriction with a version number less than 1. In this case a default response can be added using apply_response_model, used as follows: <pre><code>from pait.extra.config import apply_response_model\nfrom pait.g import config\nfrom pait.model.response import HtmlResponseModel\n\n\n\nclass DefaultResponseModel(HtmlResponseModel):\n    response_data: str = \"&lt;h1&gt; Default Html&lt;/h1&gt;\"\n\n\n# Since middleware is applied to all route functions, the matching rules use the default values\nconfig.init_config(apply_func_list=[apply_response_model([DefaultResponseModel])])\n</code></pre></p>"},{"location":"6_config/#13apply_block_http_method_set","title":"1.3.apply_block_http_method_set","text":"<p><code>Pait</code> is a decorator, so it can only capture the attributes of the route function, like URL, HTTP method parameters need to be added by <code>load_app</code>. However, many web frameworks will automatically supplement the route function with HTTP methods like <code>HEAD</code>, <code>OPTIONS</code>, etc. when registering the route function. This will cause the OpenAPI data of the route function to contain HTTP methods such as <code>HEAD</code> and <code>OPTIONS</code>. In this case, can use <code>apply_block_http_method_set</code> to disable some HTTP methods from being captured by <code>Pait</code>, using the following method: <pre><code>from pait.extra.config import apply_block_http_method_set\nfrom pait.g import config\n\n\nconfig.init_config(apply_func_list=[apply_block_http_method_set({\"HEAD\", \"OPTIONS\"})])\n</code></pre></p>"},{"location":"6_config/#14apply_multi_plugin","title":"1.4.apply_multi_plugin","text":"<p>Plugins are an important part of <code>Pait</code>, however there are plugins that only work for route functions with certain statuses. It is recommended to use different plugins based on the <code>status</code> of the route function via <code>apply_multi_plugin</code> as follows: <pre><code>from pait.app.starlette.plugin.mock_response import MockPlugin\nfrom pait.app.starlette.plugin.check_json_resp import CheckJsonRespPlugin\nfrom pait.extra.config import apply_multi_plugin, MatchRule\nfrom pait.g import config\nfrom pait.model.status import PaitStatus\n\n\nconfig.init_config(\n    apply_func_list=[\n        apply_multi_plugin(\n            # In order to be able to reuse the plugin, the lambda writing method is used here,\n            # and can also use the create_factory that comes with pait\n            [lambda: MockPlugin.build()],\n            # Using the Mock plugin for route functions where status is design\n            match_rule=MatchRule(key=\"status\", target=PaitStatus.design)\n        ),\n        apply_multi_plugin(\n            [lambda: CheckJsonRespPlugin.build()],\n            # Using the CheckJsonPlugin for route functions where status is test\n            match_rule=MatchRule(key=\"status\", target=PaitStatus.test)\n        ),\n    ]\n)\n</code></pre></p>"},{"location":"6_config/#15apply_pre_depend","title":"1.5.apply_pre_depend","text":"<p>Most of the time, may use a Token check function for a group of route functions, which is not suitable for middleware, but adding <code>depend</code> one by one to a route function is cumbersome, so can use <code>apply_pre_depend</code>, which is used as follows: <pre><code>from pait.extra.config import apply_pre_depend, MatchRule\nfrom pait.field import Header\nfrom pait.g import config\n\n\ndef check_token(token: str = Header.i(\"\")) -&gt; bool:\n    return bool(token)\n\n\nconfig.init_config(\n    apply_func_list=[\n        # Match url starting with /api/v1/user\n        apply_pre_depend(check_token, match_rule=MatchRule(key=\"path\", target=\"^/api/v1/user\")),\n        # Match route functions whose group attribute is user\n        apply_pre_depend(check_token, match_rule=MatchRule(key=\"group\", target=\"user\"))\n    ],\n)\n</code></pre></p>"},{"location":"7_gRPC_gateway/","title":"gRPC Gateway","text":""},{"location":"7_gRPC_gateway/#1","title":"1.\u4ecb\u7ecd","text":"<p>gRPC\u57fa\u4e8eHTTP/2.0\u8fdb\u884c\u901a\u4fe1\uff0c\u7406\u8bba\u4e0a\u5f88\u5bb9\u6613\u81ea\u52a8\u8f6c\u6362\u6210\u4e00\u4e2aRESTful\u63a5\u53e3\uff0c\u6240\u4ee5<code>Go gRPC</code>\u5f88\u5bb9\u6613\u7684\u5c31\u80fd\u5b9e\u73b0<code>gRPC GatwWay</code>\u529f\u80fd\uff0c\u5982grpc-gateway\u3002\u4f46\u662f<code>Python gRPC</code>\u5374\u5f88\u96be\u505a\u5230\uff0c\u56e0\u4e3a\u5b83\u4e0d\u50cf<code>Go gRPC</code>\u4e00\u6837\u662f\u4f7f\u7528Go\u8bed\u8a00\u7f16\u5199\u7684\u5e93\uff0c\u800c\u662f\u7528C\u8bed\u8a00\u7f16\u5199\u7684\uff0c\u540c\u65f6<code>Python gRPC</code>\u63d0\u4f9b\u7684API\u6bd4\u8f83\u5c11\uff0c\u6240\u4ee5<code>Python</code>\u8981\u5199\u4e00\u4e2a\u8f6c\u53d1HTTP\u8bf7\u6c42\u5230gRPC\u670d\u52a1\u6bd4\u8f83\u9ebb\u70e6\uff0c\u800c<code>Pait</code>\u63d0\u4f9b\u7684<code>gRPC GateWay</code>\u529f\u80fd\u53ef\u4ee5\u4e3a\u5f00\u53d1\u8005\u4ee5\u6700\u5c0f\u7684\u4ee3\u7801\u5b9e\u73b0\u4e00\u4e2a\u7b80\u5355\u7684<code>gRPC Gateway</code>\u3002</p> <p>Note</p> <p><code>Pait</code>\u63d0\u4f9b\u7684<code>gRPC GateWay</code>\u529f\u80fd\u5b9e\u9645\u4e0a\u662f\u7c7b\u4f3c\u4e00\u4e2a\u4ee3\u7406\u670d\u52a1\uff0c\u5b83\u4f1a\u628aHTTP\u5ba2\u6237\u7aef\u53d1\u9001\u7684\u8bf7\u6c42\u8f6c\u4e3a\u5bf9\u5e94\u7684Msg\u5bf9\u8c61\uff0c\u518d\u901a\u8fc7channel\u53d1\u9001\u7ed9gRPC\u670d\u52a1\u7aef\uff0c\u6700\u540e\u628agRPC\u670d\u52a1\u7aef\u8fd4\u56de\u7684Msg\u5bf9\u8c61\u8f6c\u4e3a\u6846\u67b6\u5bf9\u5e94\u7684Json\u54cd\u5e94\u8fd4\u56de\u7ed9HTTP\u5ba2\u6237\u7aef\u3002</p>"},{"location":"7_gRPC_gateway/#2","title":"2.\u4f7f\u7528","text":"<p><code>gRPC GateWay</code>\u7684\u4f7f\u7528\u975e\u5e38\u7b80\u5355\uff0c \u4ee3\u7801\u4f8b\u5b50\u5982\u4e0b\uff1a <pre><code>from typing import Any\nimport grpc\nfrom starlette.applications import Starlette\nfrom pait.app.starlette.grpc_route import GrpcGatewayRoute\nfrom pait.app.starlette import AddDocRoute\nfrom pait.util.grpc_inspect.message_to_pydantic import grpc_timestamp_int_handler\n\n# \u5f15\u5165\u6839\u636eProtobuf\u6587\u4ef6\u751f\u6210\u7684\u5bf9\u5e94\u4ee3\u7801\nfrom example.example_grpc.python_example_proto_code.example_proto.user import user_pb2_grpc\nfrom example.example_grpc.python_example_proto_code.example_proto.book import social_pb2_grpc, manager_pb2_grpc\n\n\ndef create_app() -&gt; Starlette:\n    app: Starlette = Starlette()\n    # \u4e3aapp\u6ce8\u518cUserStub,BookSocialStub\u548cBookManagerStub\u7684\u8def\u7531\u51fd\u6570\n    grpc_gateway_route: GrpcGatewayRoute = GrpcGatewayRoute(\n        app,\n        # \u4f20\u5165\u5bf9\u5e94\u7684Stub\u7c7b\n        user_pb2_grpc.UserStub,\n        social_pb2_grpc.BookSocialStub,\n        manager_pb2_grpc.BookManagerStub,\n        # \u6307\u5b9aurl\u5f00\u5934\n        prefix=\"/api\",\n        # \u6307\u5b9a\u751f\u6210\u7684\u8def\u7531\u51fd\u6570\u540d\u7684\u5f00\u5934\n        title=\"Grpc\",\n        # \u5b9a\u4e49\u8def\u7531\u5c5e\u6027\u7684\u89e3\u6790\u65b9\u6cd5\uff0c\u5177\u4f53\u89c1\u4e0b\u9762\u8bf4\u660e\n        parse_msg_desc=\"by_mypy\",\n    )\n    def _before_server_start(*_: Any) -&gt; None:\n        # \u542f\u52a8\u65f6\u6ce8\u518c\u5bf9\u5e94\u7684channel,\u8fd9\u6837\u6ce8\u518c\u7684\u8def\u7531\u51fd\u6570\u5728\u63a5\u6536\u8bf7\u6c42\u65f6\u53ef\u4ee5\u628a\u53c2\u6570\u901a\u8fc7grpc.channel\u4f20\u7ed9grpc\u670d\u52a1\u7aef\n        grpc_gateway_route.init_channel(grpc.aio.insecure_channel(\"0.0.0.0:9000\"))\n\n    async def _after_server_stop(*_: Any) -&gt; None:\n        # \u5173\u95ed\u65f6\u5173\u95ed\u5efa\u7acb\u7684channel\n        await grpc_gateway_route.channel.close()\n\n    app.add_event_handler(\"startup\", _before_server_start)\n    app.add_event_handler(\"shutdown\", _after_server_stop)\n\n    # \u6ce8\u518c\u6587\u6863\u8def\u7531\uff0c\u8fd9\u6837\u53ef\u4ee5\u65b9\u4fbf\u7684\u770b\u51faGrpcGateWayRoute\u7684\u8def\u7531\u51fd\u6570\u662f\u4ec0\u4e48\n    AddDocRoute(prefix=\"/api-doc\", title=\"Pait Api Doc\").gen_route(app)\n    return app\n\n\nif __name__ == \"__main__\":\n\n    import uvicorn  # type: ignore\n    from pait.extra.config import apply_block_http_method_set\n    from pait.g import config\n\n    config.init_config(\n        apply_func_list=[apply_block_http_method_set({\"HEAD\", \"OPTIONS\"})]\n    )\n\n    uvicorn.run(create_app(), log_level=\"debug\")\n</code></pre> \u8fd0\u884c\u4ee3\u7801\u540e\uff0c\u8bbf\u95ee\u5bf9\u5e94\u7684\u94fe\u63a5http://127.0.0.1:8000/api-doc/swagge\u5c31\u53ef\u4ee5\u770b\u5230\u5982\u4e0b\u9875\u9762\uff1a </p> <p>\u9875\u9762\u4e2d\u7684API\u90fd\u662f<code>GrpcGatewayRoute</code>\u901a\u8fc7\u89e3\u6790Protobuf\u751f\u6210\u7684Stub\u7c7b\u751f\u6210\u7684\uff0c\u5177\u4f53\u7684Protobuf\u6587\u4ef6\u53ef\u4ee5\u8bbf\u95eeexample_proto\u4e86\u89e3\u3002</p> <p>Note</p> <p>\u9700\u8981\u6ce8\u610f\u7684\u662f\uff0c\u5982\u679c\u4e0d\u901a\u8fc7<code>GrpcGatewayRoute</code>\u7684<code>init_channel</code>\u65b9\u6cd5\u6307\u5b9agrpc.channel\uff0c\u90a3\u4e48\u8def\u7531\u51fd\u6570\u6536\u5230\u8bf7\u6c42\u540e\u65e0\u6cd5\u628a\u8be5\u8bf7\u6c42\u8f6c\u6210grpc\u8bf7\u6c42\u53d1\u9001\u7ed9\u5bf9\u5e94\u7684gRPC\u670d\u52a1\u3002</p>"},{"location":"7_gRPC_gateway/#3","title":"3.\u53c2\u6570\u4ecb\u7ecd","text":"<p><code>GrpcGatewayRoute</code>\u63d0\u4f9b\u7684\u53c2\u6570\u90fd\u4f1a\u5e94\u7528\u5230\u6240\u6709Stub\u4e2d\uff0c\u5982\u679c\u6bcf\u4e2aStub\u9700\u8981\u5e94\u7528\u4e0d\u540c\u7684\u53c2\u6570\uff0c\u5219\u53ef\u4ee5\u5206\u5f00\u6ce8\u518cStub\uff0c<code>GrpcGatewayRoute</code>\u652f\u6301\u7684\u53c2\u6570\u5982\u4e0b:</p> <ul> <li>app: \u5fc5\u586b\uff0c\u4e14\u5fc5\u987b\u662f\u5bf9\u5e94\u7684app\u5b9e\u4f8b\uff0c<code>GrpcGatewayRoute</code>\u4f1a\u628aStub\u751f\u6210\u7684\u8def\u7531\u51fd\u6570\u6ce8\u518c\u5230\u5bf9\u5e94\u7684app\u5b9e\u4f8b\u4e2d\u3002</li> <li>stub_list: \u652f\u6301\u4e00\u4e2a\u6216\u591a\u4e2a\u7684stub\u53c2\u6570\uff0c\u9700\u8981\u6ce8\u610f\u7684\u662f\uff0c\u4f20\u5165\u7684Stub\u5fc5\u987b\u662f\u7531Protobuf\u751f\u6210\u7684gRPC Stub\u7c7b\u3002</li> <li>prefix: \u751f\u6210\u8def\u7531\u51fd\u6570\u7684URL\u524d\u7f00\uff0c\u5047\u5982<code>prefix</code>\u4e3a<code>/api</code>\uff0cStub\u7c7b\u7684\u4e00\u4e2agRPC\u65b9\u6cd5\u5bf9\u5e94\u7684URL\u4e3a<code>/user.User/get_uid_by_token</code>\uff0c\u90a3\u4e48\u751f\u6210\u7684URL\u5219\u662f<code>/api/user.User/get_uid_by_token</code>\u3002</li> <li>title: \u751f\u6210\u8def\u7531\u51fd\u6570\u540d\u662f\u7531title\u4ee5\u53ca\u4e00\u4e2agRPC\u65b9\u6cd5\u7684\u65b9\u6cd5\u540d\u51b3\u5b9a\u7684\uff0c\u5982\u679c\u4e00\u4e2aapp\u5b9e\u4f8b\u7ed1\u5b9a\u8fc7\u4e2a\u76f8\u540c\u7684Stub\u7c7b\uff0c\u5219title\u5fc5\u987b\u4e0d\u540c\u3002\uff08\u5bf9\u4e8e<code>Tornado</code>\uff0c\u662f\u901a\u8fc7title\u548cgRPC\u65b9\u6cd5\u540d\u6765\u5b9a\u4e49\u5bf9\u5e94Handler\u7c7b\u7684\u540d\u79f0\u3002\uff09</li> <li>parse_msg_desc: \u6307\u5b9a\u8981\u89e3\u6790msg\u6ce8\u91ca\u7684\u7c7b\u578b\uff0c\u5982\u679c\u4e0d\u586b\u5219\u4f1a\u89e3\u6790Message\u5bf9\u5e94\u7684Option\uff0c\u5982\u679c\u586b\u5165\u7684\u503c\u4e3a<code>by_mypy</code>\uff0c\u5219\u4f1a\u89e3\u6790\u901a\u8fc7<code>mypy-protobuf</code>\u63d2\u4ef6\u751f\u6210\u7684pyi\u6587\u4ef6\uff0c\u5982\u679c\u586b\u5165\u7684\u662f\u4e00\u4e2a\u8def\u5f84\uff0c\u5219\u4f1a\u89e3\u6790\u5bf9\u5e94\u8def\u5f84\u4e0b\u7684Protobuf\u6587\u4ef6\uff0c\u5177\u4f53\u4f7f\u7528\u65b9\u6cd5\u89c1:protobuf_to_pydantic\u3002</li> <li>msg_to_dict: \u9ed8\u8ba4\u4e3a<code>google.protobuf.json_format.MessageToDict</code>\u3002\u8def\u7531\u51fd\u6570\u6536\u5230gRPC\u670d\u52a1\u8fd4\u56de\u7684Message\u5bf9\u8c61\u540e\uff0c\u4f1a\u901a\u8fc7msg_to_dict\u8f6c\u4e3aPython\u7684dict\u5bf9\u8c61\uff0c\u518d\u8fd4\u56dejson\u5230\u5ba2\u6237\u7aef\u3002</li> <li>parse_dict: \u9ed8\u8ba4\u4e3a\u7a7a\uff0c\u8be5\u53c2\u6570\u4ec5\u652f\u6301<code>google.protobuf.json_format.ParseDict</code>\u4ee5\u53ca\u5b83\u7684\u53d8\u4f53\u3002\u8def\u7531\u51fd\u6570\u6536\u5230HTTP\u5ba2\u6237\u7aef\u7684\u8bf7\u6c42\u540e\u4f1a\u5bf9\u6570\u636e\u8fdb\u884c\u6821\u9a8c\uff0c\u7136\u540e\u8f6c\u4e3agRPC\u65b9\u6cd5\u9700\u8981\u7684Message\u5bf9\u8c61\u3002</li> <li>pait: \u7528\u4e8e\u88c5\u9970\u8def\u7531\u51fd\u6570\u7684<code>pait</code>\u88c5\u9970\u5668\u5bf9\u8c61\u3002</li> <li>make_response: \u8d1f\u8d23\u628a\u8def\u7531\u51fd\u6570\u8fd4\u56de\u7684Dict\u5bf9\u8c61\u8f6c\u4e3a\u5bf9\u5e94Web\u6846\u67b6\u7684Json\u54cd\u5e94\u5bf9\u8c61\u3002</li> <li>url_handler: \u7528\u4e8e\u66f4\u6539gRPC\u81ea\u5e26\u7684URL\uff0c\u9ed8\u8ba4\u4f1a\u628agRPC\u65b9\u6cd5\u7684<code>.</code>\u6539\u4e3a<code>-</code>\u3002</li> <li>gen_response_model_handle(0.8\u7248\u672c\u65b0\u589e): \u7528\u4e8e\u751f\u6210\u8def\u7531\u51fd\u6570\u5bf9\u5e94\u7684Pait\u54cd\u5e94\u5bf9\u8c61\u51fd\u6570\uff0c\u9ed8\u8ba4\u7684\u751f\u6210\u51fd\u6570\u5982\u4e0b\uff1a     <pre><code>def _gen_response_model_handle(grpc_model: GrpcModel) -&gt; Type[PaitBaseResponseModel]:\n    class CustomerJsonResponseModel(PaitJsonResponseModel):\n        name: str = grpc_model.response.DESCRIPTOR.name\n        description: str = grpc_model.response.__doc__ or \"\"\n\n        # Rename it,\n        # otherwise it will overwrite the existing scheme with the same name when generating OpenAPI documents.\n        response_data: Type[BaseModel] = type(\n            f\"{grpc_model.method}RespModel\", (msg_to_pydantic_model(grpc_model.response),), {}\n        )\n\n    return CustomerJsonResponseModel\n</code></pre></li> <li>request_param_field_dict(0.8\u7248\u672c\u79fb\u9664): \u6307\u5b9a\u4e00\u4e2a\u53c2\u6570\u540d\u5bf9\u5e94\u7684field\u5bf9\u8c61\uff0c\u9700\u8981\u6ce8\u610f\u7684\u662f\uff0c\u8fd9\u662f\u4f1a\u5e94\u7528\u5230\u6240\u6709\u7684Stub\u5bf9\u8c61\u3002</li> <li>grpc_timestamp_handler_tuple(0.8\u7248\u672c\u79fb\u9664): \u8be5\u65b9\u6cd5\u652f\u6301\u4f20\u5165\u4e00\u4e2a(type, callback)\u7684\u6570\u7ec4\uff0ctype\u4ee3\u8868\u5b57\u6bb5\u5bf9\u5e94\u7684\u7c7b\u578b\uff0ccallback\u4ee3\u8868\u8f6c\u6362\u65b9\u6cd5\uff0c\u5b57\u6bb5\u7684\u7c7b\u578b\u4e3aTimestamp\u65f6\u4f1a\u542f\u7528\u3002\u56e0\u4e3agRPC\u7684Timestamp\u9ed8\u8ba4\u60c5\u51b5\u4e0b\u53ea\u652f\u6301\u5b57\u7b26\u4e32\u8f6c\u6362\uff0c\u6240\u4ee5\u63d0\u4f9b\u4e86\u8fd9\u4e2a\u65b9\u6cd5\u6765\u652f\u6301\u5176\u5b83\u7c7b\u578b\u8f6c\u4e3agRPC Timestamp\u5bf9\u8c61\uff0c\u6bd4\u5982\u628aint\u7c7b\u578b\u8f6c\u4e3aTimestamp\u5bf9\u8c61\uff0c\u5219\u5bf9\u5e94\u7684callback\u53ef\u4ee5\u5199\u4e3a:     <pre><code>def grpc_timestamp_int_handler(cls: Any, v: int) -&gt; Timestamp:\n    t: Timestamp = Timestamp()\n\n    if v:\n        t.FromDatetime(datetime.datetime.fromtimestamp(v))\n    return t\n</code></pre></li> </ul>"},{"location":"7_gRPC_gateway/#4","title":"4.\u5b9a\u4e49\u8def\u7531\u5c5e\u6027","text":"<p>\u901a\u8fc7Swagger\u9875\u9762\u53ef\u4ee5\u53d1\u73b0\uff0cUserStub\u76f8\u5173\u7684\u8def\u7531\u51fd\u6570\u7684url\u4e0e\u5176\u5b83Stub\u7684\u8def\u7531\u51fd\u6570\u4e0d\u4e00\u6837\uff0c\u8fd9\u662f\u56e0\u4e3a\u5728Protobuf\u4e2d\u5b9a\u4e49\u4e86UserStub\u751f\u6210\u8def\u7531\u51fd\u6570\u7684\u4e00\u4e9b\u884c\u4e3a\uff0c\u76ee\u524d\u652f\u6301\u591a\u79cd\u65b9\u6cd5\u6765\u81ea\u5b9a\u4e49\u8def\u7531\u5c5e\u6027\uff0c\u4e0b\u9762\u4ecb\u7ecd\u4e24\u79cd\u5e38\u7528\u65b9\u6cd5\u3002</p>"},{"location":"7_gRPC_gateway/#41protobufoption","title":"4.1.\u901a\u8fc7Protobuf\u7684Option\u5b9a\u4e49\u8def\u7531\u7684\u5c5e\u6027(\u63a8\u8350)","text":"<p>Note</p> <p>0.8\u4ee5\u53ca\u540e\u7eed\u7248\u672c\u624d\u652f\u6301\u672c\u529f\u80fd</p> <p>UserStub\u5bf9\u5e94\u7684user.proto\u6587\u4ef6\u7684<code>service</code>\u5757\uff0c\u8fd9\u91cc\u901a\u8fc7Option\u5b9a\u4e49\u4e86UserStub\u8def\u7531\u51fd\u6570\u7684\u884c\u4e3a\uff0c\u5177\u4f53\u5982\u4e0b\uff1a <pre><code>// \u5f15\u5165\u4e86pait.api\u5305\nimport \"example_proto_by_option/common/api.proto\";\n\nservice User {\n  // The interface should not be exposed for external use\n  rpc get_uid_by_token (GetUidByTokenRequest) returns (GetUidByTokenResult) {\n    option (pait.api.http) = {\n      not_enable: true, // \u5b9a\u4e49\u4e0d\u89e3\u6790\u8be5\u51fd\u6570\n      group: \"user\", // \u5b9a\u4e49\u51fd\u6570\u7684group\n      tag: [{name: \"grpc-user\", desc: \"grpc_user_service\"}]  // \u5b9a\u4e49\u51fd\u6570\u7684\u6807\u7b7e\n    };\n  };\n  rpc logout_user (LogoutUserRequest) returns (google.protobuf.Empty) {\n    option (pait.api.http) = {\n      summary: \"User exit from the system\",  // \u5b9a\u4e49\u51fd\u6570\u7684\u7b80\u4ecb\n      any: {url: \"/user/logout\"},  // \u5b9a\u4e49\u51fd\u6570\u7684url\u662f\u4ec0\u4e48\uff0cany\u4ee3\u8868\u5177\u4f53\u7684HTTP\u65b9\u6cd5\u7531GrpcGateway\u65b9\u6cd5\u5b9a\u4e49\uff0c\u5982\u679c\u8981\u6307\u5b9aHTTP\u65b9\u6cd5\u4e3aPOST,\u90a3\u4e48\u9700\u8981\u628aany\u66ff\u6362\u4e3apost\n      tag: [{name: \"grpc-user\", desc: \"grpc_user_service\"}]\n    };\n  };\n  rpc login_user(LoginUserRequest) returns (LoginUserResult) {\n    option (pait.api.http) = {\n      summary: \"User login to system\",\n      any: {url: \"/user/login\"},\n      tag: [{name: \"grpc-user\", desc: \"grpc_user_service\"}]\n    };\n  };\n  rpc create_user(CreateUserRequest) returns (google.protobuf.Empty) {\n    option (pait.api.http) = {\n      summary: \"Create users through the system\",\n      any: {url: \"/user/create\"},\n      tag: [\n        {name: \"grpc-user\", desc: \"grpc_user_service\"},\n        {name: \"grpc-user-system\", desc: \"grpc_user_service\"}\n      ]\n    };\n  };\n  rpc delete_user(DeleteUserRequest) returns (google.protobuf.Empty) {\n    option (pait.api.http) = {\n      desc: \"This interface performs a logical delete, not a physical delete\",\n      any: {url: \"/user/delete\"},\n      tag: [\n        {name: \"grpc-user\", desc: \"grpc_user_service\"},\n        {name: \"grpc-user-system\", desc: \"grpc_user_service\"}\n      ]\n    };\n  };\n}\n</code></pre> \u8fd9\u4efdprotobuf\u6587\u4ef6\u4e2d\u7684\u7b2c\u4e00\u884c\u5f15\u5165\u4e86<code>pait.api</code>\u5305\uff0c\u5728\u4f7f\u7528\u7684\u8fc7\u7a0b\u4e2d\u5efa\u8bae\u628a\u8be5\u6587\u4ef6\u4e0b\u8f7d\u5230\u5bf9\u5e94\u7684\u76ee\u5f55\u4e2d\uff0c\u5e76\u5728\u81ea\u5df1\u7684Protobuf\u6587\u4ef6\u4e2d\u5f15\u5165\u8be5\u5305\u3002</p> <p><code>pait.api</code>\u652f\u6301\u7684\u62d3\u5c55\u5c5e\u6027\u5982\u4e0b:</p> <ul> <li>group\uff1a\u8def\u7531\u51fd\u6570\u5bf9\u5e94\u7684group</li> <li>tag: \u8def\u7531\u51fd\u6570\u5bf9\u5e94\u7684tag\u5bf9\u8c61</li> <li>summary: \u8def\u7531\u51fd\u6570\u5bf9\u5e94\u7684\u63cf\u8ff0</li> <li>url: \u8def\u7531\u51fd\u6570\u5bf9\u5e94\u7684url</li> <li>enable: \u662f\u5426\u8981\u751f\u6210\u5bf9\u5e94\u65b9\u6cd5\u7684\u8def\u7531\uff0c\u9ed8\u8ba4\u4e3afalse</li> <li>additional_bindings: \u589e\u52a0\u4e00\u4e2a\u65b0\u7684\u8def\u7531\u6620\u5c04\u65b9\u6cd5</li> </ul> <p>\u5176\u4e2durl\u548cadditional_bindings\u7684\u4f7f\u7528\u65b9\u6cd5\u6bd4\u8f83\u7279\u6b8a\uff0c\u5177\u4f53\u4f7f\u7528\u65b9\u6cd5\u5982\u4e0b\uff1a <pre><code>service Demo {\n  // http\u65b9\u6cd5\u7531GrpcGateway\u751f\u6210\uff0c\u4f46\u6307\u5b9a\u4e86url\u4e3a/demo\n  rpc demo_request_1 (Empty) returns (Empty) {\n    option (pait.api.http) = {\n      any: {url: \"/demo\"},\n    };\n  };\n  rpc demo_request_2 (Empty) returns (Empty) {\n    // \u6307\u5b9ahttp\u65b9\u6cd5\u4e3apost\uff0cURL\u4e3a/demo\n    option (pait.api.http) = {\n      post: {url: \"/demo\"},\n    };\n  };\n  rpc demo_request_3 (Empty) returns (Empty) {\n    // \u6307\u5b9ahttp\u65b9\u6cd5\u4e3apost,\u4f46\u662furl\u91c7\u7528\u4e86gRPC\u751f\u6210\u7684url\n    option (pait.api.http) = {\n      post: {default: true},\n    };\n  };\n  rpc demo_request_4 (Empty) returns (Empty) {\n    // \u6307\u5b9ahttp\u65b9\u6cd5\u4e3aget\uff0cURL\u4e3a/demo\n    option (pait.api.http) = {\n      get: {url: \"/demo\"},\n    };\n    // \u989d\u5916\u6620\u5c04\u4e86\u4e00\u4e2ahttp\u65b9\u6cd5\u4e3apost,URL\u4e3a/demo\u7684\u8def\u7531\uff0c\u4e14\u6307\u5b9a\u4e86\u5bf9\u5e94\u7684desc\n    additional_bindings: {\n      post: {url: \"/demo1\"},\n      desc: \"test additional bindings\"\n    }\n  };\n}\n</code></pre></p> <p>Note</p> <p>\u5177\u4f53\u7684\u793a\u4f8b\u6587\u4ef6\u89c1\uff1ahttps://github.com/so1n/pait/tree/master/example/example_grpc/example_proto_by_option</p>"},{"location":"7_gRPC_gateway/#42protobuf","title":"4.2.\u901a\u8fc7Protobuf\u6587\u4ef6\u6ce8\u91ca\u5b9a\u4e49\u8def\u7531\u7684\u5c5e\u6027","text":"<p>UserStub\u5bf9\u5e94\u7684user.proto\u6587\u4ef6\u7684<code>service</code>\u5757\uff0c\u8fd9\u91cc\u901a\u8fc7\u6ce8\u91ca\u5b9a\u4e49\u4e86UserStub\u8def\u7531\u51fd\u6570\u7684\u884c\u4e3a\uff0c\u8fd9\u4e9b\u6ce8\u91ca\u90fd\u662f\u901a\u8fc7<code>pait:</code>\u5f00\u5934\uff0c\u7136\u540e\u8ddf\u7740\u7684\u662f\u4e00\u6bb5json\u6570\u636e\uff0c\u5177\u4f53\u5982\u4e0b\uff1a <pre><code>// \u5b9a\u4e49\u4e86\u6574\u4e2aUser\u670d\u52a1\u751f\u6210\u7684\u8def\u7531\u51fd\u6570\u7684group\u90fd\u662fuser, tag\u90fd\u662fgrpc-user(\u540e\u9762\u8ddf\u7740\u7684grpc_user_service\u662f\u5bf9\u5e94\u7684\u6587\u6863\u63cf\u8ff0)\n// pait: {\"group\": \"user\", \"tag\": [[\"grpc-user\", \"grpc_user_service\"]]}\nservice User {\n  // \u5b9a\u4e49\u4e0d\u8981\u751f\u6210get_uid_by_token\u7684\u8def\u7531\u51fd\u6570\n  // pait: {\"enable\": false}\n  rpc get_uid_by_token (GetUidByTokenRequest) returns (GetUidByTokenResult);\n  // \u5b9a\u4e49logout_user \u51fd\u6570\u7684summary\u548curl\n  // pait: {\"summary\": \"User exit from the system\", \"url\": \"/user/logout\"}\n  rpc logout_user (LogoutUserRequest) returns (google.protobuf.Empty);\n  // pait: {\"summary\": \"User login to system\", \"url\": \"/user/login\"}\n  rpc login_user(LoginUserRequest) returns (LoginUserResult);\n  // pait: {\"tag\": [[\"grpc-user\", \"grpc_user_service\"], [\"grpc-user-system\", \"grpc_user_service\"]]}\n  // pait: {\"summary\": \"Create users through the system\", \"url\": \"/user/create\"}\n  rpc create_user(CreateUserRequest) returns (google.protobuf.Empty);\n  // pait: {\"url\": \"/user/delete\", \"tag\": [[\"grpc-user\", \"grpc_user_service\"], [\"grpc-user-system\", \"grpc_user_service\"]]}\n  // pait: {\"desc\": \"This interface performs a logical delete, not a physical delete\"}\n  rpc delete_user(DeleteUserRequest) returns (google.protobuf.Empty);\n}\n</code></pre> \u8fd9\u4efd\u6587\u4ef6\u7684\u6ce8\u91ca\u90fd\u662f\u901a\u8fc7<code>pait:</code>\u5f00\u5934\uff0c\u7136\u540e\u8ddf\u7740\u4e00\u6bb5json\u6570\u636e\uff0c\u76ee\u524d\u89e3\u6790\u65b9\u6cd5\u5e76\u4e0d\u662f\u975e\u5e38\u7684\u667a\u80fd\uff0c\u6240\u4ee5\u4e0d\u652f\u6301\u6362\u884c\uff0c\u5982\u679c\u5b9a\u4e49\u7684\u5c5e\u6027\u8fc7\u591a\u5219\u9700\u8981\u53e6\u8d77\u4e00\u884c\u6ce8\u91ca\uff0c\u8fd9\u884c\u6ce8\u91ca\u4e5f\u9700\u8981\u4ee5<code>pait:</code>\u5f00\u5934\uff0c\u540c\u65f6\u6ce8\u91ca\u4e00\u5b9a\u8981\u5199\u5728\u5bf9\u5e94\u65b9\u6cd5\u7684\u524d\u9762\u3002\u5982\u679cservice\u5b9a\u4e49\u4e86\u5bf9\u5e94\u7684\u5c5e\u6027\uff0c\u800crpc\u65b9\u6cd5\u6ca1\u6709\u5b9a\u4e49\uff0c\u5219\u5728\u751f\u4ea7rpc\u65b9\u6cd5\u5bf9\u5e94\u7684\u8def\u7531\u65f6\u4f1a\u91c7\u7528service\u5b9a\u4e49\u7684\u5c5e\u6027\u3002</p> <p>\u76ee\u524d\u652f\u6301\u7684\u53ef\u5b9a\u4e49\u7684\u5c5e\u6027\u5982\u4e0b:</p> <ul> <li>name: \u8def\u7531\u51fd\u6570\u7684\u540d\u79f0\uff0c\u9ed8\u8ba4\u4e3a\u7a7a\u5b57\u7b26\u4e32</li> <li>tag: \u8def\u7531\u51fd\u6570\u5bf9\u5e94\u7684tag\u5217\u8868\uff0c\u5217\u8868\u5185\u5fc5\u987b\u662f\u4e00\u4e2a\u5143\u7956\uff0c\u5206\u522b\u4e3atag\u7684\u540d\u548ctag\u7684\u63cf\u8ff0</li> <li>group\uff1a\u8def\u7531\u51fd\u6570\u5bf9\u5e94\u7684group</li> <li>summary: \u8def\u7531\u51fd\u6570\u5bf9\u5e94\u7684\u63cf\u8ff0</li> <li>url: \u8def\u7531\u51fd\u6570\u5bf9\u5e94\u7684url</li> <li>enable: \u662f\u5426\u8981\u751f\u6210\u5bf9\u5e94\u65b9\u6cd5\u7684\u8def\u7531\uff0c\u9ed8\u8ba4\u4e3afalse</li> </ul> <p>Note</p> <p>\u5177\u4f53\u7684\u793a\u4f8b\u6587\u4ef6\u89c1\uff1ahttps://github.com/so1n/pait/tree/master/example/example_grpc/example_proto</p>"},{"location":"7_gRPC_gateway/#5message","title":"5.\u5b9a\u4e49Message\u7684\u5c5e\u6027","text":"<p>\u5728\u751f\u6210\u8def\u7531\u51fd\u6570\u65f6\uff0c<code>GrpcGatewayRoute</code>\u4f1a\u628a\u65b9\u6cd5\u5bf9\u5e94\u7684\u8bf7\u6c42message\u548c\u54cd\u5e94message\u89e3\u6790\u4e3a\u8def\u7531\u51fd\u6570\u5bf9\u5e94\u7684\u8bf7\u6c42\u548c\u54cd\u5e94\u5bf9\u8c61\uff0c\u8fd9\u4e9b\u5bf9\u8c61\u7684\u7c7b\u578b\u90fd\u4e3a<code>pydantic.BaseModel</code>\uff0c\u4e4b\u540e<code>Pait</code>\u5c31\u53ef\u4ee5\u901a\u8fc7\u5bf9\u5e94\u7684<code>pydantic.BaseModel</code>\u5bf9\u8c61\u6765\u751f\u6210\u6587\u6863\u6216\u8005\u505a\u53c2\u6570\u6821\u9a8c\u3002</p> <p>\u4e0d\u8fc7\u8fd9\u6837\u751f\u6210\u7684<code>pydantic.BaseModel</code>\u5bf9\u8c61\u53ea\u6709\u57fa\u672c\u7684\u4fe1\u606f\uff0c\u4e3a\u4e86\u80fd\u8ba9\u751f\u6210\u7684<code>pydantic.BaseModel</code>\u5bf9\u8c61\u66f4\u52a0\u7684\u4e30\u5bcc\uff0c<code>Pait</code>\u901a\u8fc7protobuf_to_pydantic\u6765\u62d3\u5c55<code>pydantic.BaseModel</code>\u5bf9\u8c61\u7684\u4fe1\u606f\u3002</p>"},{"location":"7_gRPC_gateway/#51protobufoptionmessage","title":"5.1.\u901a\u8fc7Protobuf\u7684Option\u5b9a\u4e49Message\u7684\u5c5e\u6027(\u63a8\u8350)","text":"<p>Note</p> <p>0.8\u4ee5\u53ca\u540e\u7eed\u7248\u672c\u624d\u652f\u6301\u672c\u529f\u80fd</p> <p>\u8be5\u65b9\u6cd5\u901a\u8fc7Protobuf\u7684Option\u6765\u62d3\u5c55<code>pydantic.BaseModel</code>\u5bf9\u8c61\u7684\u4fe1\u606f\uff0c\u5728\u4f7f\u7528\u4e4b\u524d\uff0c\u9700\u8981\u628a\u6587\u4ef6\u4e0b\u8f7d\u5230\u81ea\u5df1\u7684\u9879\u76ee\u91cc\u9762\uff0c\u5e76\u5728\u81ea\u5df1\u7684Protobuf\u6587\u4ef6\u4e2d\u5f15\u7528\uff0c\u793a\u4f8b\u4ee3\u7801\u5982\u4e0b\uff1a <pre><code>import \"example_proto_by_option/common/p2p_validate.proto\";\n\n// create user\nmessage CreateUserRequest {\n  string uid = 1 [\n    (p2p_validate.rules).string.miss_default = true,  // \u5b9a\u4e49\u4e86\u8be5\u5b57\u6bb5\u6ca1\u6709\u9ed8\u8ba4\u503c\n    (p2p_validate.rules).string.example = \"10086\",  // \u5b9a\u4e49\u5b57\u6bb5\u7684\u793a\u4f8b\u503c\u4e3a10086\n    (p2p_validate.rules).string.title = \"UID\",  // \u5b9a\u4e49\u4e86\u5b57\u6bb5\u7684Title\u4e3aUID\n    (p2p_validate.rules).string.description = \"user union id\" // \u5b9a\u4e49\u4e86\u5b57\u6bb5\u7684desc\n  ];\n  string user_name = 2 [\n    (p2p_validate.rules).string.description = \"user name\",\n    (p2p_validate.rules).string.min_length = 1,\n    (p2p_validate.rules).string.max_length = 10,\n    (p2p_validate.rules).string.example = \"so1n\"\n  ];\n  string password = 3 [\n    (p2p_validate.rules).string.description = \"user password\",\n    (p2p_validate.rules).string.alias = \"pw\",\n    (p2p_validate.rules).string.min_length = 6,\n    (p2p_validate.rules).string.max_length = 18,\n    (p2p_validate.rules).string.example = \"123456\"\n  ];\n  SexType sex = 4;\n}\n</code></pre></p> <p>\u4e4b\u540e\u751f\u6210\u7684\u6587\u6863\u4e2d\u5173\u4e8e<code>CreateUserRequest</code>\u7684\u5c55\u793a\u5982\u4e0b: </p> <p>\u8fd9\u79cd\u65b9\u5f0f\u8fd8\u652f\u6301\u5176\u5b83\u7684\u62d3\u5c55\uff0c\u5177\u4f53\u89c1protobuf_to_pydantic\u6587\u6863</p>"},{"location":"7_gRPC_gateway/#52protobufmessage","title":"5.2.\u901a\u8fc7Protobuf\u6587\u4ef6\u6ce8\u91ca\u5b9a\u4e49Message\u7684\u5c5e\u6027","text":"<p>\u8be5\u65b9\u6cd5\u901a\u8fc7\u83b7\u53d6Protobuf\u6587\u4ef6\u7684\u6ce8\u91ca\u6765\u62d3\u5c55<code>pydantic.BaseModel</code>\u5bf9\u8c61\u7684\u4fe1\u606f\uff0c\u6bd4\u5982user.proto\u6587\u4ef6\u7684<code>CreateUserRequest</code>\uff0c\u5b83\u7684\u6ce8\u91ca\u5982\u4e0b\uff1a <pre><code>message CreateUserRequest {\n  // \u901a\u5e38Protobuf\u7684Message\u90fd\u6709\u9ed8\u8ba4\u503c\uff0c\u5982\u679c\u6307\u5b9amiss_default\u4e3atrue\uff0c\u5219\u4e0d\u4f1a\u4f7f\u7528gRPC\u7684\u9ed8\u8ba4\u503c\n  // pait: {\"miss_default\": true, \"example\": \"10086\", \"title\": \"UID\", \"description\": \"user union id\"}\n  string uid = 1;\n  // pait: {\"description\": \"user name\"}\n  // pait: {\"default\": \"\", \"min_length\": 1, \"max_length\": \"10\", \"example\": \"so1n\"}\n  string user_name = 2;\n  // pait: {\"description\": \"user password\"}\n  // pait: {\"alias\": \"pw\", \"min_length\": 6, \"max_length\": 18, \"example\": \"123456\"}\n  string password = 3;\n  SexType sex = 4;\n}\n\n// logout user\nmessage LogoutUserRequest {\n  string uid = 1;\n  // \u4e0d\u89e3\u6790\u8be5\u5b57\u6bb5\n  // pait: {\"enable\": false}\n  string token = 2; }\n</code></pre> \u4e4b\u540e\u751f\u6210\u7684\u6587\u6863\u4e2d\u5173\u4e8e<code>CreateUserRequest</code>\u7684\u5c55\u793a\u5982\u4e0b: </p> <p>\u53ef\u4ee5\u53d1\u73b0Message\u6ce8\u91ca\u7f16\u5199\u7684\u65b9\u6cd5\u4e0eService\u7684\u4e00\u81f4\uff0c\u53ea\u4e0d\u8fc7\u662f\u5c5e\u6027\u4e0d\u540c\uff0cMessage\u652f\u6301\u7684\u5c5e\u6027\u9664\u4e86<code>miss_default</code>\u548c<code>enable</code>\u5916\uff0c\u4e0e<code>Pait</code>\u7684Field\u5bf9\u8c61\u4e00\u81f4\uff0c<code>miss_default</code>\u9ed8\u8ba4\u4e3afalse\uff0c\u5982\u679c\u4e3atrue,\u5219\u4ee3\u8868\u8be5\u5b57\u6bb5\u6ca1\u6709\u9ed8\u8ba4\u503c\uff0c\u5982\u679c\u4e3afalse\uff0c\u5219\u4ee3\u8868\u8be5\u5b57\u6bb5\u7684\u9ed8\u8ba4\u503c\u4e3aProtobuf\u5bf9\u5e94\u5c5e\u6027\u7684\u9ed8\u8ba4\u503c\uff1b<code>enable</code>\u9ed8\u8ba4\u4e3aTrue\uff0c\u5982\u679c\u4e3aFalse\uff0c\u5219\u4e0d\u4f1a\u89e3\u6790\u8be5\u5b57\u6bb5\u3002</p> <p>\u652f\u6301\u7684\u5c5e\u6027\u5217\u8868</p> <ul> <li>miss_default</li> <li>enable</li> <li>example</li> <li>alias</li> <li>title</li> <li>description</li> <li>const</li> <li>gt</li> <li>ge</li> <li>lt</li> <li>le</li> <li>min_length</li> <li>max_length</li> <li>min_items</li> <li>max_items</li> <li>multiple_of</li> <li>regex</li> <li>extra</li> </ul> <p>Note</p> <p>\u66f4\u591a\u4f7f\u7528\u65b9\u6cd5\u89c1protobuf_to_pydantic\u6587\u6863</p>"},{"location":"7_gRPC_gateway/#6gateway-route","title":"6.\u81ea\u5b9a\u4e49<code>Gateway Route</code>\u8def\u7531\u51fd\u6570","text":"<p>\u867d\u7136\u63d0\u4f9b\u4e86\u4e00\u4e9b\u53c2\u6570\u7528\u4e8e<code>Gateway Route</code>\u8def\u7531\u7684\u5b9a\u5236\uff0c\u4f46\u662f\u5149\u9760\u8fd9\u4e9b\u53c2\u6570\u8fd8\u662f\u4e0d\u591f\u7684\uff0c\u6240\u4ee5\u652f\u6301\u5f00\u53d1\u8005\u901a\u8fc7\u7ee7\u627f\u7684\u65b9\u5f0f\u6765\u5b9a\u4e49<code>Gateway Route</code>\u8def\u7531\u51fd\u6570\u7684\u6784\u9020\u3002</p> <p>\u6bd4\u5982\u4e0b\u8ff0\u793a\u4f8b\u7684User.proto\u6587\u4ef6: <pre><code>// \u539f\u6587\u4ef6\u89c1\uff1ahttps://github.com/so1n/pait/blob/master/example/example_grpc/example_proto_by_option/user/user.proto\n// logout user\nmessage LogoutUserRequest {\n  string uid = 1;\n  // \u4e0d\u89e3\u6790\u8be5\u5b57\u6bb5\n  string token = 2 [(p2p_validate.rules).string.enable = false];\n}\n\nservice User {\n  // The interface should not be exposed for external use\n  rpc get_uid_by_token (GetUidByTokenRequest) returns (GetUidByTokenResult) {\n    option (pait.api.http) = {\n      not_enable: true,\n      group: \"user\",\n      tag: [{name: \"grpc-user\", desc: \"grpc_user_service\"}]\n    };\n  };\n  rpc logout_user (LogoutUserRequest) returns (google.protobuf.Empty) {\n    option (pait.api.http) = {\n      summary: \"User exit from the system\",\n      any: {url: \"/user/logout\"},\n      tag: [{name: \"grpc-user\", desc: \"grpc_user_service\"}]\n    };\n  };\n  rpc login_user(LoginUserRequest) returns (LoginUserResult) {\n    option (pait.api.http) = {\n      summary: \"User login to system\",\n      any: {url: \"/user/login\"},\n      tag: [{name: \"grpc-user\", desc: \"grpc_user_service\"}]\n    };\n  };\n  rpc create_user(CreateUserRequest) returns (google.protobuf.Empty) {\n    option (pait.api.http) = {\n      summary: \"Create users through the system\",\n      any: {url: \"/user/create\"},\n      tag: [\n        {name: \"grpc-user\", desc: \"grpc_user_service\"},\n        {name: \"grpc-user-system\", desc: \"grpc_user_service\"}\n      ]\n    };\n  };\n  rpc delete_user(DeleteUserRequest) returns (google.protobuf.Empty) {\n    option (pait.api.http) = {\n      desc: \"This interface performs a logical delete, not a physical delete\",\n      any: {url: \"/user/delete\"},\n      tag: [\n        {name: \"grpc-user\", desc: \"grpc_user_service\"},\n        {name: \"grpc-user-system\", desc: \"grpc_user_service\"}\n      ]\n    };\n  };\n}\n</code></pre> \u6587\u4ef6\u4e2d\u5b9a\u4e49\u7684\u63a5\u53e3\u4e2d\u6709\u4e00\u4e2a\u540d\u4e3a<code>User.get_uid_by_token</code>\u7684\u63a5\u53e3\uff0c\u5b83\u7528\u4e8e\u901a\u8fc7token\u83b7\u53d6uid, \u540c\u65f6\u62e5\u6709\u6821\u9a8cToken\u662f\u5426\u6b63\u786e\u7684\u6548\u679c\uff0c\u8fd9\u4e2a\u63a5\u53e3\u4e0d\u4f1a\u76f4\u63a5\u66b4\u9732\u7ed9\u5916\u90e8\u8c03\u7528\uff0c\u4e5f\u5c31\u4e0d\u4f1a\u901a\u8fc7<code>Gateway Route</code>\u751f\u6210\u5bf9\u5e94\u7684HTTP\u63a5\u53e3\u3002 \u800c\u5176\u5b83\u63a5\u53e3\u88ab\u8c03\u7528\u65f6\uff0c\u9700\u8981\u4eceHeader\u83b7\u53d6Token\u5e76\u901a\u8fc7gRPC\u63a5\u53e3<code>User.get_uid_by_token</code>\u8fdb\u884c\u5224\u65ad\uff0c\u5224\u65ad\u5f53\u524d\u8bf7\u6c42\u7684\u7528\u6237\u662f\u5426\u6b63\u5e38\uff0c\u53ea\u6709\u6821\u9a8c\u901a\u8fc7\u65f6\u624d\u4f1a\u53bb\u8c03\u7528\u5bf9\u5e94\u7684gRPC\u63a5\u53e3\u3002 \u540c\u65f6\uff0c\u63a5\u53e3<code>User.logout_user</code>\u8bf7\u6c42\u4f53<code>LogoutUserRequest</code>\u7684<code>token</code>\u5b57\u6bb5\u88ab\u6807\u6ce8\u4e3a\u4e0d\u89e3\u6790\uff0c\u5e76\u901a\u8fc7Herder\u7684\u83b7\u53d6Token\uff0c\u4f7f\u5176\u8ddf\u5176\u5b83\u63a5\u53e3\u7edf\u4e00\u3002</p> <p>\u63a5\u4e0b\u6765\u5c31\u901a\u8fc7\u7ee7\u627f\u7684\u65b9\u6cd5\u6765\u91cd\u65b0\u5b9a\u4e49<code>Gateway Route</code>\u8def\u7531\u51fd\u6570\u7684\u6784\u9020\uff1a <pre><code>from sys import modules\nfrom typing import Callable, Type\nfrom uuid import uuid4\n\nfrom example.example_grpc.python_example_proto_code.example_proto.user import user_pb2\nfrom pait.util.grpc_inspect.stub import GrpcModel\nfrom pait.util.grpc_inspect.types import Message\n\nclass CustomerGrpcGatewayRoute(GrpcGatewayRoute):\n    # \u7ee7\u627f`GrpcGatewayRoute.gen_route`\u65b9\u6cd5\n    def gen_route(\n        self, grpc_model: GrpcModel, request_pydantic_model_class: Type[BaseModel]\n    ) -&gt; Callable:\n\n        # \u5982\u679c\u4e0d\u662flogin_user\u63a5\u53e3\uff0c\u5c31\u8d70\u81ea\u5b9a\u4e49\u7684\u8def\u7531\u51fd\u6570\n        if grpc_model.method!= \"/user.User/login_user\":\n\n            async def _route(\n                request_pydantic_model: request_pydantic_model_class,  # type: ignore\n                token: str = Header.i(description=\"User Token\"),  # \u901a\u8fc7Header\u83b7\u53d6token\n                req_id: str = Header.i(alias=\"X-Request-Id\", default_factory=lambda: str(uuid4())),  # \u901a\u8fc7Header\u83b7\u53d6\u8bf7\u6c42id\n            ) -&gt; Any:\n                # \u83b7\u53d6gRPC\u63a5\u53e3\u5bf9\u5e94\u7684\u8c03\u7528\u51fd\u6570\uff0c\u9700\u8981\u653e\u5728\u6700\u524d\uff0c\u56e0\u4e3a\u5b83\u5305\u62ec\u4e86\u5224\u65adchannel\u662f\u5426\u521b\u5efa\u7684\u903b\u8f91\u3002\n                func: Callable = self.get_grpc_func(method_name)\n                request_dict: dict = request_pydantic_model.dict()  # type: ignore\n                if method_name == \"/user.User/logout_user\":\n                    # logout_user\u63a5\u53e3\u9700\u8981\u4e00\u4e2atoken\u53c2\u6570\n                    request_dict[\"token\"] = token\n                else:\n                    # \u5176\u5b83\u63a5\u53e3\u9700\u8981\u901a\u8fc7\u6821\u9a8cToken\u6765\u5224\u65ad\u7528\u6237\u662f\u5426\u5408\u6cd5\n                    result: user_pb2.GetUidByTokenResult = await user_pb2_grpc.UserStub(\n                        self.channel\n                    ).get_uid_by_token(user_pb2.GetUidByTokenRequest(token=token))\n                    if not result.uid:\n                        # \u5982\u679c\u4e0d\u5408\u6cd5\u5c31\u62a5\u9519\n                        raise RuntimeError(f\"Not found user by token:{token}\")\n                # \u5408\u6cd5\u5c31\u8c03\u7528\u5bf9\u5e94\u7684gRPC\u63a5\u53e3\n                request_msg: Message = self.get_msg_from_dict(grpc_model.request, request_dict)\n                # \u6dfb\u52a0\u4e00\u4e2a\u8bf7\u6c42ID\u7ed9gRPC\u670d\u52a1\n                grpc_msg: Message = await func(request_msg, metadata=[(\"req_id\", req_id)])\n                return self._make_response(self.get_dict_from_msg(grpc_msg))\n\n            # \u7531\u4e8erequest_pydantic_model_class\u662f\u5728\u7236\u7c7b\u751f\u6210\u7684\uff0c\u6240\u4ee5Pait\u5728\u517c\u5bb9\u5ef6\u8fdf\u6ce8\u91ca\u65f6\u83b7\u53d6\u4e0d\u5230\u8be5\u6a21\u5757\u7684request_pydantic_model_class\u503c\uff0c\n            # \u6240\u4ee5\u8981\u628arequest_pydantic_model_class\u6ce8\u5165\u672c\u6a21\u5757\uff0c\u5728\u4e0b\u4e00\u4e2a\u7248\u672c`GrpcGatewayRoute`\u4f1a\u81ea\u52a8\u5904\u7406\u8fd9\u4e2a\u95ee\u9898\u3002\n            modules[_route.__module__].__dict__[\"request_pydantic_model_class\"] = request_pydantic_model_class\n            return _route\n        else:\n            # login_user\u63a5\u53e3\u5219\u8d70\u81ea\u52a8\u751f\u6210\u903b\u8f91\u3002\n            return super().gen_route(grpc_model, request_pydantic_model_class)\n</code></pre> \u4e4b\u540e\u5c31\u53ef\u4ee5\u8ddf\u539f\u6765\u4f7f\u7528<code>GrpcGatewayRoute</code>\u7684\u65b9\u6cd5\u4e00\u6837\u4f7f\u7528\u6211\u4eec\u65b0\u521b\u5efa\u7684<code>CustomerGrpcGatewayRoute</code>\uff0c\u4e4b\u540e\u5c31\u53ef\u4ee5\u770b\u5230\u5982\u4e0b\u6548\u679c\uff1a  \u53ef\u4ee5\u770b\u5230<code>/api/user/login</code>\u548c<code>/api/user/create</code>\u6ca1\u6709\u4ec0\u4e48\u53d8\u5316\uff0c\u800c<code>/api/user/logout</code>\u9700\u8981\u901a\u8fc7Header\u83b7\u53d6token\u548c<code>X-Request-ID</code></p>"},{"location":"8_other/","title":"Other","text":""},{"location":"8_other/#1implicit-or-explicit-import","title":"1.Implicit or explicit import","text":"<p><code>pait</code> supports multiple web frameworks and if only one of them is installed in the project's dependency environment, can use implicit import: <pre><code>from pait.app.any import pait, load_app, add_simple_route\n</code></pre> But if multiple frameworks are installed at the same time, then the implicit import will throw an exception, and it is recommended to use explicit import, as follows: <pre><code>from pait.app.flask import pait, load_app, add_simple_route\nfrom pait.app.sanic import pait, load_app, add_simple_route\nfrom pait.app.starlette import pait, load_app, add_simple_route\nfrom pait.app.tornado import pait, load_app, add_simple_route\n</code></pre></p>"},{"location":"8_other/#2internal-methods","title":"2.Internal Methods","text":"<p><code>Pait</code> encapsulates a number of common methods. Through these methods developers can quickly develop extension packages without considering compatibility with different web frameworks. OpenAPI routing and grpc-gateway are developed based on these methods.</p>"},{"location":"8_other/#21data","title":"2.1.data","text":"<p><code>data</code> is the carrier for each <code>CoreModel</code>. <code>Pait</code> decorates the route function to generate a <code>CoreModel</code> and store it in <code>pait.g.data</code> to support for configuration, documentation, etc feature.</p>"},{"location":"8_other/#22load_app","title":"2.2.load_app","text":"<p>The <code>CoreModel</code> stores a lot of information about the route functions, but the route functions are missing key OpenAPI information such as <code>url</code>, <code>method</code>, etc. So you need to use <code>load_app</code> to get more data before using OpenAPI. So before using OpenAPI you need to use <code>load_app</code> to fill in the data, it's very simple to use, but you need to call it after registering all the routes, as follows.</p> <p>Note</p> <p>OpenAPI routing automatically calls <code>load_app</code> before initialization</p> FlaskStarletteSanicTornado <pre><code>from flask import Flask\n\nfrom pait.app.flask import load_app\n\napp: Flask = Flask()\n\nload_app(app) # Wrong!!!\n# --------\n# app.add_url_rule\n# --------\n\nload_app(app) #  That's right\napp.run()\n</code></pre> <pre><code>import uvicorn\nfrom starlette.applications import Starlette\n\nfrom pait.app.starlette import load_app\n\napp: Starlette = Starlette()\nload_app(app) # Wrong!!!\n# --------\n# app.add_route\n# --------\n\nload_app(app) #  That's right\nuvicorn.run(app)\n</code></pre> <pre><code>from sanic import Sanic\n\nfrom pait.app.sanic import load_app\n\napp: Sanic = Sanic()\nload_app(app) # Wrong!!!\n\n# --------\n# app.add_route\n# --------\n\nload_app(app) #  That's right\napp.run()\n</code></pre> <pre><code>from tornado.web import Application\nfrom tornado.ioloop import IOLoop\n\nfrom pait.app.tornado import load_app\n\napp: Application = Application()\nload_app(app) # Wrong!!!\n# --------\n# app.add_handlers\n# --------\nload_app(app) #  That's right\napp.listen(8000)\nIOLoop.instance().start()\n</code></pre>"},{"location":"8_other/#23http-exceptions","title":"2.3.HTTP exceptions","text":"<p><code>Pait</code> provides an HTTP exception generator function for each web framework, which generates HTTP standard exceptions for web frameworks by parameters such as HTTP status code, error content, Headers, etc. They are used as follows.</p> FlaskSanicStarletteTornado <pre><code>from pait.app.flask import http_exception\n\nhttp_exception(status_code=401, message=\"Unauthorized\", headers={\"WWW-Authenticate\": \"Basic\"})\n</code></pre> <pre><code>from pait.app.sanic import http_exception\n\nhttp_exception(status_code=401, message=\"Unauthorized\", headers={\"WWW-Authenticate\": \"Basic\"})\n</code></pre> <pre><code>from pait.app.starlette import http_exception\n\nhttp_exception(status_code=401, message=\"Unauthorized\", headers={\"WWW-Authenticate\": \"Basic\"})\n</code></pre> <pre><code>from pait.app.tornado import http_exception\n\nhttp_exception(status_code=401, message=\"Unauthorized\", headers={\"WWW-Authenticate\": \"Basic\"})\n</code></pre> <p>In addition, <code>Pait</code> provides some HTTP exception responses as follows: <pre><code>from pait.app.any import pait\nfrom pait.model import response\n\n# response.Http400RespModel\n# response.Http401RespModel\n# response.Http403RespModel\n# response.Http404RespModel\n# response.Http405RespModel\n# response.Http406RespModel\n# response.Http407RespModel\n# response.Http408RespModel\n# response.Http429RespModel\n\n@pait(response_model_list=[response.Http400RespModel])\ndef demo() -&gt; None:\n    pass\n</code></pre> At the same time HTTP exception response Model also supports custom creation, the following example of use: <pre><code>from pait.model import response\n\n# Create a response model with a status code of 500 and content-type as html\nresponse.HttpStatusCodeBaseModel.clone(resp_model=response.HtmlResponseModel, status_code=500)\n# Create a response model with status code 500 and content-type set to text\nresponse.HttpStatusCodeBaseModel.clone(resp_model=response.TextResponseModel, status_code=500)\n</code></pre></p>"},{"location":"8_other/#24simpleroute","title":"2.4.SimpleRoute","text":"<p><code>Pait</code> unifies the route registration and response generation of different web frameworks through SimpleRoute. Developers can easily create and register routes through SimpleRoute without considering compatibility.</p> <p>Note</p> <p>Unified route response generation is provided by the <code>UnifiedResponsePluginProtocol</code> plugin. The <code>UnifiedResponsePluginProtocol</code> plugin is added to the route function when the route function is registered.</p> <p>SimpleRoute is used as follows:</p> FlaskStarletteSanicTornado docs_source_code/other/flask_with_simple_route_demo.py<pre><code>from flask import Flask\n\nfrom pait.app.any import SimpleRoute, add_multi_simple_route, add_simple_route\nfrom pait.app.flask import pait\nfrom pait.model import response\n\n\n@pait(response_model_list=[response.JsonResponseModel])\ndef json_route() -&gt; dict:\n    return {}\n\n\n@pait(response_model_list=[response.TextResponseModel])\ndef text_route() -&gt; str:\n    return \"demo\"\n\n\n@pait(response_model_list=[response.HtmlResponseModel])\ndef html_route() -&gt; str:\n    return \"&lt;h1&gt;demo&lt;/h1&gt;\"\n\n\napp: Flask = Flask(\"demo\")\nadd_simple_route(app, SimpleRoute(route=json_route, url=\"/json\", methods=[\"GET\"]))\nadd_multi_simple_route(\n    app,\n    SimpleRoute(route=json_route, url=\"/json\", methods=[\"GET\"]),\n    SimpleRoute(route=text_route, url=\"/text\", methods=[\"GET\"]),\n    SimpleRoute(route=html_route, url=\"/html\", methods=[\"GET\"]),\n    prefix=\"/api\",\n    title=\"api\",\n)\n\n\nif __name__ == \"__main__\":\n    app.run(port=8000)\n</code></pre> docs_source_code/other/starlette_with_simple_route_demo.py<pre><code>from starlette.applications import Starlette\n\nfrom pait.app.any import SimpleRoute, add_multi_simple_route, add_simple_route\nfrom pait.app.starlette import pait\nfrom pait.model import response\n\n\n@pait(response_model_list=[response.JsonResponseModel])\nasync def json_route() -&gt; dict:\n    return {}\n\n\n@pait(response_model_list=[response.TextResponseModel])\nasync def text_route() -&gt; str:\n    return \"demo\"\n\n\n@pait(response_model_list=[response.HtmlResponseModel])\nasync def html_route() -&gt; str:\n    return \"&lt;h1&gt;demo&lt;/h1&gt;\"\n\n\napp: Starlette = Starlette()\nadd_simple_route(app, SimpleRoute(route=json_route, url=\"/json\", methods=[\"GET\"]))\nadd_multi_simple_route(\n    app,\n    SimpleRoute(route=json_route, url=\"/json\", methods=[\"GET\"]),\n    SimpleRoute(route=text_route, url=\"/text\", methods=[\"GET\"]),\n    SimpleRoute(route=html_route, url=\"/html\", methods=[\"GET\"]),\n    prefix=\"/api\",\n    title=\"api\",\n)\n\n\nif __name__ == \"__main__\":\n    import uvicorn\n\n    uvicorn.run(app)\n</code></pre> docs_source_code/other/sanic_with_simple_route_demo.py<pre><code>from sanic import Sanic\nfrom sanic.request import Request\n\nfrom pait.app.any import SimpleRoute, add_multi_simple_route, add_simple_route\nfrom pait.app.sanic import pait\nfrom pait.model import response\n\n\n@pait(response_model_list=[response.JsonResponseModel])\nasync def json_route(request: Request) -&gt; dict:\n    return {}\n\n\n@pait(response_model_list=[response.TextResponseModel])\nasync def text_route(request: Request) -&gt; str:\n    return \"demo\"\n\n\n@pait(response_model_list=[response.HtmlResponseModel])\nasync def html_route(request: Request) -&gt; str:\n    return \"&lt;h1&gt;demo&lt;/h1&gt;\"\n\n\napp: Sanic = Sanic(\"demo\")\nadd_simple_route(app, SimpleRoute(route=json_route, url=\"/json\", methods=[\"GET\"]))\nadd_multi_simple_route(\n    app,\n    SimpleRoute(route=json_route, url=\"/json\", methods=[\"GET\"]),\n    SimpleRoute(route=text_route, url=\"/text\", methods=[\"GET\"]),\n    SimpleRoute(route=html_route, url=\"/html\", methods=[\"GET\"]),\n    prefix=\"/api\",\n    title=\"api\",\n)\n\n\nif __name__ == \"__main__\":\n    import uvicorn\n\n    uvicorn.run(app)\n</code></pre> docs_source_code/other/tornado_with_simple_route_demo.py<pre><code>from tornado.ioloop import IOLoop\nfrom tornado.web import Application\n\nfrom pait.app.any import SimpleRoute, add_multi_simple_route, add_simple_route\nfrom pait.app.tornado import pait\nfrom pait.model import response\n\n\n@pait(response_model_list=[response.JsonResponseModel])\nasync def json_route() -&gt; dict:\n    return {}\n\n\n@pait(response_model_list=[response.TextResponseModel])\nasync def text_route() -&gt; str:\n    return \"demo\"\n\n\n@pait(response_model_list=[response.HtmlResponseModel])\nasync def html_route() -&gt; str:\n    return \"&lt;h1&gt;demo&lt;/h1&gt;\"\n\n\napp: Application = Application()\nadd_simple_route(app, SimpleRoute(route=json_route, url=\"/json\", methods=[\"GET\"]))\nadd_multi_simple_route(\n    app,\n    SimpleRoute(route=json_route, url=\"/json\", methods=[\"GET\"]),\n    SimpleRoute(route=text_route, url=\"/text\", methods=[\"GET\"]),\n    SimpleRoute(route=html_route, url=\"/html\", methods=[\"GET\"]),\n    prefix=\"/api\",\n    title=\"api\",\n)\n\n\nif __name__ == \"__main__\":\n    app.listen(8000)\n    IOLoop.instance().start()\n</code></pre> <p>The first highlighted code creates three route functions according to the <code>SimpleRoute</code> standard, which is as follows:</p> <ul> <li>1.The route functions need to be decorated by <code>pait</code>, and the <code>response_model_list</code> attribute cannot be empty (the response models of the route functions in the code are <code>JsonResponseModel</code>, <code>TextResponseModel</code>, <code>HtmlResponseModel</code>, these are all required by SimpleRoute, if there is no response model, then SimpleRoute can't register the route function to the web framework.)</li> <li>2.The return value of the route function changes from a response object to a <code>Python</code> base type, and the returned <code>Python</code> base type needs to be consistent with the <code>response_data</code> of the response model.</li> </ul> <p>The second highlight code is the registration of routes via the <code>add_simple_route</code> and <code>add_multi_simple_route</code> methods, where <code>add_simple_route</code> can only register a single route and <code>add_multi_simple_route</code> can register multiple routes. Both <code>add_simple_route</code> and <code>add_multi_simple_route</code> receive app and SimpleRoute instances, whereas SimpleRoute supports only three attributes, as follows:</p> Parameters Description route A route function that conforms to the SimpleRoute standard url The URL of the route method HTTP method of the route <p>In addition, <code>add_multi_simple_route</code> supports two optional parameters, as follows:</p> Parameters Description prefix Route prefix, for example, if the prefix is \"/api\" and the url of SimpleRoute is \"/user\", the registered route URL is \"/api/user\". title The title of the route group. For some frameworks, the route groups or blueprints they use need to be uniquely named, so the <code>title</code> should be different for different <code>add_multi_simple_route</code>s <p>After running the code, test that the route works properly via the <code>curl</code> command:</p>  curl http://127.0.0.1:8000/json{} curl http://127.0.0.1:8000/api/json{} curl http://127.0.0.1:8000/api/textdemo curl http://127.0.0.1:8000/api/html&lt;h1&gt;demo&lt;/h1&gt;"},{"location":"8_other/#25set-and-get-web-framework-properties","title":"2.5.Set and get web framework properties","text":"<p><code>Pait</code> provides a unified method for setting and getting attribute values for Web frameworks, which are <code>set_app_attribute</code> and <code>get_app_attribute</code>. The <code>set_app_attribute</code> and <code>get_app_attribute</code> can be used to set and get Web framework attributes at any time, as follows:</p> FlaskStarletteSanicTornado docs_source_code/other/flask_with_attribute_demo.py<pre><code>import httpx\nfrom flask import Flask, Response, current_app, jsonify\n\nfrom pait.app.any import get_app_attribute, set_app_attribute\n\n\ndef demo_route() -&gt; Response:\n    client: httpx.Client = get_app_attribute(current_app, \"client\")\n    return jsonify({\"status_code\": client.get(\"http://so1n.me\").status_code})\n\n\napp: Flask = Flask(\"demo\")\napp.add_url_rule(\"/api/demo\", \"demo\", demo_route, methods=[\"GET\"])\nset_app_attribute(app, \"client\", httpx.Client())\n\n\nif __name__ == \"__main__\":\n    app.run(port=8000)\n</code></pre> docs_source_code/other/starlette_with_attribute_demo.py<pre><code>import httpx\nfrom starlette.applications import Starlette\nfrom starlette.requests import Request\nfrom starlette.responses import JSONResponse\n\nfrom pait.app.any import get_app_attribute, set_app_attribute\n\n\nasync def demo_route(request: Request) -&gt; JSONResponse:\n    client: httpx.AsyncClient = get_app_attribute(request.app, \"client\")\n    return JSONResponse({\"status_code\": (await client.get(\"http://so1n.me\")).status_code})\n\n\napp: Starlette = Starlette()\napp.add_route(\"/api/demo\", demo_route, methods=[\"GET\"])\nset_app_attribute(app, \"client\", httpx.AsyncClient())\n\n\nif __name__ == \"__main__\":\n    import uvicorn\n\n    uvicorn.run(app)\n</code></pre> docs_source_code/other/sanic_with_attribute_demo.py<pre><code>import httpx\nfrom sanic import HTTPResponse, Request, Sanic, json\n\nfrom pait.app.any import get_app_attribute, set_app_attribute\n\n\nasync def demo_route(request: Request) -&gt; HTTPResponse:\n    client: httpx.AsyncClient = get_app_attribute(request.app, \"client\")\n    return json({\"status_code\": (await client.get(\"http://so1n.me\")).status_code})\n\n\napp: Sanic = Sanic(\"demo\")\napp.add_route(demo_route, \"/api/demo\", methods=[\"GET\"])\nset_app_attribute(app, \"client\", httpx.AsyncClient())\n\n\nif __name__ == \"__main__\":\n    import uvicorn\n\n    uvicorn.run(app)\n</code></pre> docs_source_code/other/tornado_with_attribute_demo.py<pre><code>import httpx\nfrom tornado.ioloop import IOLoop\nfrom tornado.web import Application, RequestHandler\n\nfrom pait.app.any import get_app_attribute, set_app_attribute\n\n\nclass DemoHandler(RequestHandler):\n    async def get(self) -&gt; None:\n        client: httpx.AsyncClient = get_app_attribute(self.application, \"client\")\n        self.write({\"status_code\": (await client.get(\"http://so1n.me\")).status_code})\n\n\napp: Application = Application()\napp.add_handlers(\".*$\", [(\"/api/demo\", DemoHandler)])\nset_app_attribute(app, \"client\", httpx.AsyncClient())\n\n\nif __name__ == \"__main__\":\n    app.listen(8000)\n    IOLoop.instance().start()\n</code></pre> <p>After running the code, test that the route works properly via the <code>curl</code> command: <pre><code>\u279c  curl http://127.0.0.1:8000/api/demo\n{\"status_code\": 200}\n</code></pre> As you can see by the result, the route function is able to get <code>client</code> and through <code>client</code> get the <code>status_code</code> of the url.</p> <p>Note</p> <p>By setting property values for the web framework, can decouple the component from the framework and also make the component more flexible, but it is more recommended to use DI tools to realize decoupling, see Awesome Dependency Injection in Python.</p>"},{"location":"8_other/#3how-to-use-pait-with-other-web-frameworks","title":"3.How to use Pait with other web frameworks","text":"<p>Currently, <code>Pait</code> is still in the process of rapid iteration, so the main focus is on feature development. If you want to use <code>Pait</code> in other frameworks that are not yet supported, or if you want to extend the functionality, can refer to the two frameworks to make simple adaptations.</p> <p>For synchronous web frameworks, please refer to pait.app.flask.</p> <p>For asynchronous web framework, please refer to pait.app.starlette.</p>"},{"location":"8_other/#4example-code","title":"4.Example code","text":"<p>See example for more complete examples.</p>"},{"location":"8_other/#5release","title":"5.Release","text":"<p>For detailed release info, please see CHANGELOG</p>"}]}